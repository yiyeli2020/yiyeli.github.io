<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-10-28T08:11:31.454Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>209. 长度最小的子数组</title>
    <link href="http://yoursite.com/2021/10/28/209.%20%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2021/10/28/209. 长度最小的子数组/</id>
    <published>2021-10-28T03:12:12.000Z</published>
    <updated>2021-10-28T08:11:31.454Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。</code></pre><p>示例 2：</p><pre><code>输入：target = 4, nums = [1,4,4]输出：1</code></pre><p>示例 3：</p><pre><code>输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0</code></pre><p>提示：</p><p>1 &lt;= target &lt;= 109<br>1 &lt;= nums.length &lt;= 105<br>1 &lt;= nums[i] &lt;= 105</p><p>进阶：</p><p>如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。</p><h1 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h1><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/" target="_blank" rel="noopener">^1</a>注意：使用 <code>Python</code> 语言实现方法一会超出时间限制。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123;</span><br><span class="line">                    ans = Math.min(ans, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>cpp</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123;</span><br><span class="line">                    ans = min(ans, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight csharp"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MinSubArrayLen</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">int</span>[] nums</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.Length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="keyword">int</span>.MaxValue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) </span><br><span class="line">            &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = Math.Min(ans, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans == <span class="keyword">int</span>.MaxValue ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(s <span class="keyword">int</span>, nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := math.MaxInt32</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; n; j++ &#123;</span><br><span class="line">            sum += nums[j]</span><br><span class="line">            <span class="keyword">if</span> sum &gt;= s &#123;</span><br><span class="line">                ans = min(ans, j - i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ans == math.MaxInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, s: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        ans = n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">                total += nums[j]</span><br><span class="line">                <span class="keyword">if</span> total &gt;= s:</span><br><span class="line">                    ans = min(ans, j - i + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans == n + <span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; numsSize; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= s) &#123;</span><br><span class="line">                ans = fmin(ans, j - i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)*，其中 *n</em> 是数组的长度。需要遍历每个下标作为子数组的开始下标，对于每个开始下标，需要遍历其后面的下标得到长度最小的子数组。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法二：前缀和-二分查找"><a href="#方法二：前缀和-二分查找" class="headerlink" title="方法二：前缀和 + 二分查找"></a>方法二：前缀和 + 二分查找</h1><p>题解二分查找中java的binarySearch方法返回有两种：</p><p>一种是刚好找到目标值，返回目标值的下标。</p><p>一种是找不到目标值，则会返回比目标值大的元素的下标，下标带有负数，且从1开始数起。</p><p>例如一个数组有3个元素，但是查找的元素值比那三个元素都大，则会返回-4</p><p>注意题目要找的是大于等于target的连续子数组和。</p><details>    <summary>C#</summary><figure class="highlight csharp"><figcaption><span>[lowerbound-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">LowerBound</span>(<span class="params"><span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">-1</span>, originL = l, originR = r;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) </span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (a[l] &gt;= target) ? l : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>下面是这道题的代码。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; </span><br><span class="line">        <span class="comment">// 为了方便计算，令 size = n + 1 </span></span><br><span class="line">        <span class="comment">// sums[0] = 0 意味着前 0 个元素的前缀和为 0</span></span><br><span class="line">        <span class="comment">// sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span></span><br><span class="line">        <span class="comment">// 以此类推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = s + sums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> bound = Arrays.binarySearch(sums, target);</span><br><span class="line">            <span class="comment">//找不到目标值，则会返回比目标值大的元素的下标，下标带有负数，且从1开始数起</span></span><br><span class="line">            <span class="keyword">if</span> (bound &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                bound = -bound - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bound &lt;= n) &#123;</span><br><span class="line">                ans = Math.min(ans, bound - (i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums(n + <span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">        <span class="comment">// 为了方便计算，令 size = n + 1 </span></span><br><span class="line">        <span class="comment">// sums[0] = 0 意味着前 0 个元素的前缀和为 0</span></span><br><span class="line">        <span class="comment">// sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span></span><br><span class="line">        <span class="comment">// 以此类推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = s + sums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">auto</span> bound = lower_bound(sums.begin(), sums.end(), target);</span><br><span class="line">            <span class="keyword">if</span> (bound != sums.end()) &#123;</span><br><span class="line">                ans = min(ans, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((bound - sums.begin()) - (i - <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight csharp"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">LowerBound</span>(<span class="params"><span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">-1</span>, originL = l, originR = r;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) </span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (a[l] &gt;= target) ? l : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MinSubArrayLen</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">int</span>[] nums</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.Length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="keyword">int</span>.MaxValue;</span><br><span class="line">        <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; </span><br><span class="line">        <span class="comment">// 为了方便计算，令 size = n + 1 </span></span><br><span class="line">        <span class="comment">// sums[0] = 0 意味着前 0 个元素的前缀和为 0</span></span><br><span class="line">        <span class="comment">// sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span></span><br><span class="line">        <span class="comment">// 以此类推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> target = s + sums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> bound = LowerBound(sums, i, n, target);</span><br><span class="line">            <span class="keyword">if</span> (bound != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = Math.Min(ans, bound - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans == <span class="keyword">int</span>.MaxValue ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(s <span class="keyword">int</span>, nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := math.MaxInt32</span><br><span class="line">    sums := <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 为了方便计算，令 size = n + 1 </span></span><br><span class="line">    <span class="comment">// sums[0] = 0 意味着前 0 个元素的前缀和为 0</span></span><br><span class="line">    <span class="comment">// sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span></span><br><span class="line">    <span class="comment">// 以此类推</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        target := s + sums[i<span class="number">-1</span>]</span><br><span class="line">        bound := sort.SearchInts(sums, target)</span><br><span class="line">        <span class="keyword">if</span> bound &lt; <span class="number">0</span> &#123;</span><br><span class="line">            bound = -bound - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> bound &lt;= n &#123;</span><br><span class="line">            ans = min(ans, bound - (i - <span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ans == math.MaxInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, s: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        ans = n + <span class="number">1</span></span><br><span class="line">        sums = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sums.append(sums[<span class="number">-1</span>] + nums[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            target = s + sums[i - <span class="number">1</span>]</span><br><span class="line">            bound = bisect.bisect_left(sums, target)</span><br><span class="line">            <span class="keyword">if</span> bound != len(sums):</span><br><span class="line">                ans = min(ans, bound - (i - <span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans == n + <span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[r] &lt; q) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= q) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> *sums = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (numsSize + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 为了方便计算，令 size = n + 1</span></span><br><span class="line">    <span class="comment">// sums[0] = 0 意味着前 0 个元素的前缀和为 0</span></span><br><span class="line">    <span class="comment">// sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span></span><br><span class="line">    <span class="comment">// 以此类推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numsSize; i++) &#123;</span><br><span class="line">        sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> target = s + sums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> bound = lower_bound(sums, <span class="number">1</span>, numsSize, target);</span><br><span class="line">        <span class="keyword">if</span> (bound != <span class="number">-1</span>) &#123;</span><br><span class="line">            ans = fmin(ans, bound - (i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法三：滑动窗口"><a href="#方法三：滑动窗口" class="headerlink" title="方法三：滑动窗口"></a>方法三：滑动窗口</h1><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; n) &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                ans = Math.min(ans, end - start + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; n) &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                ans = min(ans, end - start + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight csharp"><figcaption><span>[sol3-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MinSubArrayLen</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">int</span>[] nums</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.Length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="keyword">int</span>.MaxValue;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; n) </span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) </span><br><span class="line">            &#123;</span><br><span class="line">                ans = Math.Min(ans, end - start + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                ++start;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans == <span class="keyword">int</span>.MaxValue ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(s <span class="keyword">int</span>, nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := math.MaxInt32</span><br><span class="line">    start, end := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> end &lt; n &#123;</span><br><span class="line">        sum += nums[end]</span><br><span class="line">        <span class="keyword">for</span> sum &gt;= s &#123;</span><br><span class="line">            ans = min(ans, end - start + <span class="number">1</span>)</span><br><span class="line">            sum -= nums[start]</span><br><span class="line">            start++</span><br><span class="line">        &#125;</span><br><span class="line">        end++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ans == math.MaxInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, s: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        ans = n + <span class="number">1</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; n:</span><br><span class="line">            total += nums[end]</span><br><span class="line">            <span class="keyword">while</span> total &gt;= s:</span><br><span class="line">                ans = min(ans, end - start + <span class="number">1</span>)</span><br><span class="line">                total -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans == n + <span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol3-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; numsSize) &#123;</span><br><span class="line">        sum += nums[end];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">            ans = fmin(ans, end - start + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[start];</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个含有 n 个正整数的数组和一个正整数 target 。&lt;/p&gt;
&lt;p&gt;找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年10月" scheme="http://yoursite.com/categories/2021%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Prefix Sum" scheme="http://yoursite.com/tags/Prefix-Sum/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>318. 最大单词长度乘积</title>
    <link href="http://yoursite.com/2021/10/27/318.%20%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/"/>
    <id>http://yoursite.com/2021/10/27/318. 最大单词长度乘积/</id>
    <published>2021-10-27T09:12:12.000Z</published>
    <updated>2021-10-27T10:28:55.078Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]输出: 16 解释: 这两个单词为 &quot;abcw&quot;, &quot;xtfn&quot;。</code></pre><p>示例 2:</p><pre><code>输入: [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]输出: 4 解释: 这两个单词为 &quot;ab&quot;, &quot;cd&quot;。</code></pre><p>示例 3:</p><pre><code>输入: [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]输出: 0 解释: 不存在这样的两个单词。</code></pre><p>提示：</p><p>2 &lt;= words.length &lt;= 1000<br>1 &lt;= words[i].length &lt;= 1000<br>words[i] 仅包含小写字母</p><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>从简单方法开始慢慢深入。<a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/solution/zui-da-dan-ci-chang-du-cheng-ji-by-leetcode/" target="_blank" rel="noopener">^1</a></p><blockquote><p>将每个单词与其他所有单词一一比较。如果两个单词没有公共字母，则更新 <code>maxProd</code>。</p></blockquote><p>先不考虑实现方法 <code>noCommonLetters</code>，该解法的代码如下：</p><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[snippet1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, words: List[str])</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">no_common_letters</span><span class="params">(s1, s2)</span>:</span></span><br><span class="line">            <span class="comment"># TODO</span></span><br><span class="line">            </span><br><span class="line">        n = len(words)</span><br><span class="line">        max_prod = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> no_common_letters(words[i], words[j]):</span><br><span class="line">                    max_prod = max(max_prod, len(words[i]) * len(words[j]))</span><br><span class="line">        <span class="keyword">return</span> max_prod</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[snippet1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">noCommonLetters</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = words.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxProd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">        <span class="keyword">if</span> (noCommonLetters(words[i], words[j]))</span><br><span class="line">          maxProd = Math.max(maxProd, words[i].length() * words[j].length());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxProd;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li><p>方法一：最小化方法 <em>f(L_1, L_2)</em> 的复杂度。</p></li><li><p>方法二：最小化单词的比较次数。不需要O(N^2) 次比较，在所有具有相同字符集的单词中只保留最长的一个单词。例：（<em>ab</em>，<em>aaaaabaabaaabb</em>，<em>bbabbabba</em>）中只保留最长的一个单词（<em>aaaaabaabaaabb</em>）。</p></li></ul><h1 id="方法一：优化的方法-noCommonLetters：位操作-预计算"><a href="#方法一：优化的方法-noCommonLetters：位操作-预计算" class="headerlink" title="方法一：优化的方法 noCommonLetters：位操作+预计算"></a>方法一：优化的方法 noCommonLetters：位操作+预计算</h1><p>首先最小化单词比较 <em>f(L_1, L_2)</em> 的复杂度。</p><p>逐个检查第一个单词的每个字母是否出现在第二个单词中，这种方法不是最优的。</p><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[snippet2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">no_common_letters</span><span class="params">(s1, s2)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> s1:</span><br><span class="line">        <span class="keyword">if</span> ch <span class="keyword">in</span> s2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[snippet2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">noCommonLetters</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> ch : s1.toCharArray())</span><br><span class="line">    <span class="keyword">if</span> (s2.indexOf(ch) != -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </details><p>更好的方法是使用位操作。</p><p>单词仅包含小写字母，可以使用 26 个字母的位掩码对单词的每个字母处理，判断是否存在某个字母。如果单词中存在字母 <code>a</code>，则将位掩码的第一位设为 <code>1</code>，否则设为 <code>0</code>。如果单词中存在字母 <code>b</code>，则将位掩码的第二位设为 <code>1</code>，否则设为 <code>0</code>。依次类推，一直判断到字母 <code>z</code>。</p><blockquote><p>如何设置掩码的第 n 位？使用标准的位操作：<code>n_th_bit = 1 &lt;&lt; n</code>。</p></blockquote><blockquote><p>如何计算一个单词的位掩码？遍历单词的每个字母，计算该字母在掩码中的位置 <code>n = (int)ch - (int)&#39;a&#39;</code>，然后创建一个第 n 位为 1 的掩码 <code>n_th_bit = 1 &lt;&lt; n</code>，通过或操作将该码合并到位掩码中 <code>bitmask |= n_th_bit</code>。</p></blockquote><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[snippet3-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">no_common_letters</span><span class="params">(s1, s2)</span>:</span></span><br><span class="line">    bit_number = <span class="keyword">lambda</span> ch : ord(ch) - ord(<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">    bitmask1 = bitmask2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> s1:</span><br><span class="line">        bitmask1 |= <span class="number">1</span> &lt;&lt; bit_number(ch)</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> s2:</span><br><span class="line">        bitmask2 |= <span class="number">1</span> &lt;&lt; bit_number(ch)</span><br><span class="line">    <span class="keyword">return</span> bitmask1 &amp; bitmask2 == <span class="number">0</span></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[snippet3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitNumber</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)ch - (<span class="keyword">int</span>)<span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">noCommonLetters</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> bitmask1 = <span class="number">0</span>, bitmask2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> ch : s1.toCharArray())</span><br><span class="line">    bitmask1 |= <span class="number">1</span> &lt;&lt; bitNumber(ch);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> ch : s2.toCharArray())</span><br><span class="line">    bitmask2 |= <span class="number">1</span> &lt;&lt; bitNumber(ch);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (bitmask1 &amp; bitmask2) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>前面方法中，每个单词需要计算 N 次位掩码。实际上，每个单词的位掩码可以预先计算并存储起来，之后每次直接拿来比较。</p><p>因为 Java 的优化，操作数组比 HashMap 更快，所以使用两个整数数组存储位掩码和字符串长度。</p><p><strong>算法</strong></p><ul><li><p>预计算所有单词的位掩码，并把它们存储在数组 <code>masks</code> 中。使用数组 <code>lens</code> 存储所有单词的长度。</p></li><li><p>逐一两两比较单词。如果两个单词不存在公共字母，则更新最大单词长度乘积 <code>maxProd</code>。使用数组 <code>masks</code> 可以在常数时间内判断两个单词是否包含公共字母：<code>(masks[i] &amp; masks[j]) == 0</code>。</p></li><li><p>返回 <code>maxProd</code>。</p></li></ul><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, words: List[str])</span> -&gt; int:</span></span><br><span class="line">        n = len(words)</span><br><span class="line">        masks = [<span class="number">0</span>] * n</span><br><span class="line">        lens = [<span class="number">0</span>] * n</span><br><span class="line">        bit_number = <span class="keyword">lambda</span> ch : ord(ch) - ord(<span class="string">'a'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            bitmask = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> words[i]:</span><br><span class="line">                <span class="comment"># add bit number bit_number in bitmask</span></span><br><span class="line">                bitmask |= <span class="number">1</span> &lt;&lt; bit_number(ch)</span><br><span class="line">            masks[i] = bitmask</span><br><span class="line">            lens[i] = len(words[i])</span><br><span class="line">            </span><br><span class="line">        max_val = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> masks[i] &amp; masks[j] == <span class="number">0</span>:</span><br><span class="line">                    max_val = max(max_val, lens[i] * lens[j])</span><br><span class="line">        <span class="keyword">return</span> max_val</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitNumber</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)ch - (<span class="keyword">int</span>)<span class="string">'a'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = words.length;</span><br><span class="line">    <span class="keyword">int</span>[] masks = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] lens = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bitmask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      bitmask = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">char</span> ch : words[i].toCharArray()) &#123;</span><br><span class="line">        <span class="comment">// add bit number bit_number in bitmask</span></span><br><span class="line">        bitmask |= <span class="number">1</span> &lt;&lt; bitNumber(ch);</span><br><span class="line">      &#125;</span><br><span class="line">      masks[i] = bitmask;</span><br><span class="line">      lens[i] = words[i].length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">        <span class="keyword">if</span> ((masks[i] &amp; masks[j]) == <span class="number">0</span>)</span><br><span class="line">          maxVal = Math.max(maxVal, lens[i] * lens[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：优化比较次数：位操作-预计算-HashMap"><a href="#方法二：优化比较次数：位操作-预计算-HashMap" class="headerlink" title="方法二：优化比较次数：位操作+预计算+HashMap"></a>方法二：优化比较次数：位操作+预计算+HashMap</h1><p>方法一优化了比较过程，方法二优化比较次数。完成所有的两两比较需要 O(N^2)  。一些单词具有相同的字符集，则只保留这些单词中最长的一个单词即可。例如：单词集合（<em>ab<em>，</em>aaaaabaabaaabb<em>，</em>bbabbabba*）只保留单词 *aaaaabaabaaabb</em> 即可。使用 HashMap 代替方法一中的两个长度为 <em>N</em> 的数组，存储结构为：位掩码 -&gt; 该掩码对应的最大长度字符串。</p><p>这种方法单词比较次数可能会减少，从而提高 Python 解法的效率。由于 Java 中 HashMap 的性能问题，这种方法不会改善 Java 解法的效率。</p><p><strong>算法</strong></p><ul><li><p>预计算所有单词的位掩码，并将它们存储在 HashMap 中：位掩码 -&gt; 该掩码对应的最大长度字符串。例如：单词 “aaaaaaa” 和 “a” 具有相同的掩码。 </p></li><li><p>逐一两两比较 HashMap 中的单词。如果两个单词没有公共字母，更新最大单词长度乘积 <code>maxProd</code>。使用位掩码可以在常数时间内判断两个单词是否包含公共字母：<code>(x &amp; y) == 0</code>。</p></li><li><p>返回 <code>maxProd</code>。</p></li></ul><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, words: List[str])</span> -&gt; int:</span></span><br><span class="line">        hashmap = defaultdict(int)</span><br><span class="line">        bit_number = <span class="keyword">lambda</span> ch : ord(ch) - ord(<span class="string">'a'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            bitmask = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">                <span class="comment"># add bit number bit_number in bitmask</span></span><br><span class="line">                bitmask |= <span class="number">1</span> &lt;&lt; bit_number(ch)</span><br><span class="line">            <span class="comment"># there could be different words with the same bitmask</span></span><br><span class="line">            <span class="comment"># ex. ab and aabb</span></span><br><span class="line">            hashmap[bitmask] = max(hashmap[bitmask], len(word))</span><br><span class="line">        </span><br><span class="line">        max_prod = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> hashmap:</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> hashmap:</span><br><span class="line">                <span class="keyword">if</span> x &amp; y == <span class="number">0</span>:</span><br><span class="line">                    max_prod = max(max_prod, hashmap[x] * hashmap[y])</span><br><span class="line">        <span class="keyword">return</span> max_prod</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitNumber</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)ch - (<span class="keyword">int</span>)<span class="string">'a'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; hashmap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bitmask = <span class="number">0</span>, bitNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">      bitmask = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">        <span class="comment">// add bit number bitNumber in bitmask</span></span><br><span class="line">        bitmask |= <span class="number">1</span> &lt;&lt; bitNumber(ch);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// there could be different words with the same bitmask</span></span><br><span class="line">      <span class="comment">// ex. ab and aabb</span></span><br><span class="line">      hashmap.put(bitmask, Math.max(hashmap.getOrDefault(bitmask, <span class="number">0</span>), word.length()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxProd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : hashmap.keySet())</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> y : hashmap.keySet())</span><br><span class="line">        <span class="keyword">if</span> ((x &amp; y) == <span class="number">0</span>) maxProd = Math.max(maxProd, hashmap.get(x) * hashmap.get(y));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxProd;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年10月" scheme="http://yoursite.com/categories/2021%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>1531. 压缩字符串 II</title>
    <link href="http://yoursite.com/2021/10/25/1531.%20%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%20II/"/>
    <id>http://yoursite.com/2021/10/25/1531. 压缩字符串 II/</id>
    <published>2021-10-25T06:12:12.000Z</published>
    <updated>2021-10-26T02:08:45.928Z</updated>
    
    <content type="html"><![CDATA[<p>请你返回删除最多k个字符后，s行程长度编码的最小长度 。</p><a id="more"></a><p>[TOC]</p><p>行程长度编码 是一种常用的字符串压缩方法，它将连续的相同字符（重复 2 次或更多次）替换为字符和表示字符计数的数字（行程长度）。例如，用此方法压缩字符串 “aabccc” ，将 “aa” 替换为 “a2” ，”ccc” 替换为` “c3” 。因此压缩后的字符串变为 “a2bc3” 。</p><p>注意，本问题中，压缩时没有在单个字符后附加计数 ‘1’ 。</p><p>给你一个字符串 s 和一个整数 k 。你需要从字符串 s 中删除最多 k 个字符，以使 s 的行程长度编码长度最小。</p><p>请你返回删除最多 k 个字符后，s 行程长度编码的最小长度 。</p><p>示例 1：</p><pre><code>输入：s = &quot;aaabcccd&quot;, k = 2输出：4解释：在不删除任何内容的情况下，压缩后的字符串是 &quot;a3bc3d&quot; ，长度为 6 。最优的方案是删除 &apos;b&apos; 和 &apos;d&apos;，这样一来，压缩后的字符串为 &quot;a3c3&quot; ，长度是 4 。</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;aabbaa&quot;, k = 2输出：2解释：如果删去两个 &apos;b&apos; 字符，那么压缩后的字符串是长度为 2 的 &quot;a4&quot; 。</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;aaaaaaaaaaa&quot;, k = 0输出：3解释：由于 k 等于 0 ，不能删去任何字符。压缩后的字符串是 &quot;a11&quot; ，长度为 3 。</code></pre><p>提示：</p><pre><code>1 &lt;= s.length &lt;= 1000 &lt;= k &lt;= s.lengths 仅包含小写英文字母</code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本题难度较大，题解中包含较多变量以及公式，希望读者认真阅读。</p><p>为了叙述方便，我们称给定的字符串 <em>s</em> 为「原串」，压缩后的字符串 <em>t</em> 为「压缩串」。我们的目标是从 <em>s</em> 中删除至多 <em>k</em> 个字符，使得其对应的 <em>t</em> 的长度最小。</p><h1 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h1><p><strong>思路与算法</strong><a href="https://leetcode-cn.com/problems/string-compression-ii/solution/ya-suo-zi-fu-chuan-ii-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> calc = [](<span class="keyword">int</span> x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k + <span class="number">1</span>, INT_MAX &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k &amp;&amp; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="comment">// 情况1:删除第i个字符</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况2：保留第i个字符</span></span><br><span class="line">                <span class="keyword">int</span> same = <span class="number">0</span>, diff = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//向前遍历与第i个字符相同的字符则考虑保留</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i0 = i; i0 &gt;= <span class="number">1</span> &amp;&amp; diff &lt;= j; --i0) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i0 - <span class="number">1</span>] == s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                        ++same;</span><br><span class="line">                        f[i][j] = min(f[i][j], f[i0 - <span class="number">1</span>][j - diff] + calc(same));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ++diff;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> f[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//防止后面f[i0 - 1][j - diff] + calc(same)溢出,最大为Integer.MAX_VALUE - 3</span></span><br><span class="line">            Arrays.fill(f[i], Integer.MAX_VALUE - <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k &amp;&amp; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="comment">//???</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> same = <span class="number">0</span>, diff = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i0 = i; i0 &gt;= <span class="number">1</span> &amp;&amp; diff &lt;= j; i0--) &#123;</span><br><span class="line">                    <span class="comment">//为了方便对边界条件进行处理，这里的 i和 j 都从 1 开始编号，但在字符串中仍然从0开始</span></span><br><span class="line">                    <span class="keyword">if</span> (s.charAt(i0 - <span class="number">1</span>) == s.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                        ++same;</span><br><span class="line">                        f[i][j] = Math.min(f[i][j], f[i0 - <span class="number">1</span>][j - diff] + calc(same));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        diff++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class="line">        calc = <span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x == <span class="number">1</span> <span class="keyword">else</span> (<span class="number">2</span> <span class="keyword">if</span> x &lt; <span class="number">10</span> <span class="keyword">else</span> (<span class="number">3</span> <span class="keyword">if</span> x &lt; <span class="number">100</span> <span class="keyword">else</span> <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">        n = len(s)</span><br><span class="line">        f = [[<span class="number">10</span>**<span class="number">9</span>] * (k + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(min(k, i) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                same = diff = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i0 <span class="keyword">in</span> range(i, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">if</span> s[i0 - <span class="number">1</span>] == s[i - <span class="number">1</span>]:</span><br><span class="line">                        same += <span class="number">1</span></span><br><span class="line">                        f[i][j] = min(f[i][j], f[i0 - <span class="number">1</span>][j - diff] + calc(same))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        diff += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> diff &gt; j:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> f[n][k]</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> f[n + <span class="number">1</span>][k + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k &amp;&amp; j &lt;= i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> same = <span class="number">0</span>, diff = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i0 = i; i0 &gt;= <span class="number">1</span> &amp;&amp; diff &lt;= j; --i0) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i0 - <span class="number">1</span>] == s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    ++same;</span><br><span class="line">                    f[i][j] = fmin(f[i][j], f[i0 - <span class="number">1</span>][j - diff] + calc(same));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++diff;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[n][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(|s|^2k)，其中 <em>|s|</em> 是原串 <em>s</em> 的长度。动态规划中状态的数目为 O(|s|k)，每一个状态需要 O(|s|) 的时间进行转移，相乘即可得到总时间复杂度。</p></li><li><p>空间复杂度：O(|s|k)，即为动态规划中状态的数目。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请你返回删除最多k个字符后，s行程长度编码的最小长度 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年10月" scheme="http://yoursite.com/categories/2021%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>443. 压缩字符串</title>
    <link href="http://yoursite.com/2021/10/25/443.%20%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2021/10/25/443. 压缩字符串/</id>
    <published>2021-10-25T06:12:12.000Z</published>
    <updated>2021-10-25T09:08:02.616Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个字符数组 chars ，请使用下述算法压缩</p><a id="more"></a><p>[TOC]</p><p>从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ：</p><p>如果这一组长度为 1 ，则将字符追加到 s 中。<br>否则，需要向 s 追加字符，后跟这一组的长度。<br>压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。</p><p>请在 修改完输入数组后 ，返回该数组的新长度。</p><p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p><p>示例 1：</p><pre><code>输入：chars = [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]输出：返回 6 ，输入数组的前 6 个字符应该是：[&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]解释：&quot;aa&quot; 被 &quot;a2&quot; 替代。&quot;bb&quot; 被 &quot;b2&quot; 替代。&quot;ccc&quot; 被 &quot;c3&quot; 替代。</code></pre><p>示例 2：</p><pre><code>输入：chars = [&quot;a&quot;]输出：返回 1 ，输入数组的前 1 个字符应该是：[&quot;a&quot;]解释：没有任何字符串被替代。</code></pre><p>示例 3：</p><pre><code>输入：chars = [&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]输出：返回 4 ，输入数组的前 4 个字符应该是：[&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;]。解释：由于字符 &quot;a&quot; 不重复，所以不会被压缩。&quot;bbbbbbbbbbbb&quot; 被 “b12” 替代。注意每个数字在数组中都有它自己的位置。</code></pre><p>提示：</p><pre><code>1 &lt;= chars.length &lt;= 2000chars[i] 可以是小写英文字母、大写英文字母、数字或符号</code></pre><h1 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h1><p><strong>思路和算法</strong></p><p>为了实现原地压缩，我们可以使用双指针分别标志我们在字符串中读和写的位置。每次当读指针read 移动到某一段连续相同子串的最右侧，我们就在写指针 write 处依次写入该子串对应的字符和子串长度即可。</p><p>在实际代码中，当读指针位于字符串的末尾，或读指针指向的字符不同于下一个字符时，我们就认为读指针位于某一段连续相同子串的最右侧。该子串对应的字符即为读指针指向的字符串。我们使用变量记录该子串的最左侧的位置，这样子串长度即为read-left+1 。</p><p>特别地，为了达到 <em>O(1)</em> 空间复杂度，我们需要自行实现将数字转化为字符串写入到原字符串的功能。这里我们采用短除法将子串长度倒序写入原字符串中，然后再将其反转即可。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = chars.size();</span><br><span class="line">        <span class="keyword">int</span> write = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> read = <span class="number">0</span>; read &lt; n; read++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (read == n - <span class="number">1</span> || chars[read] != chars[read + <span class="number">1</span>]) &#123;</span><br><span class="line">                chars[write++] = chars[read];</span><br><span class="line">                <span class="keyword">int</span> num = read - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> anchor = write;</span><br><span class="line">                    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        chars[write++] = num % <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                        num /= <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    reverse(&amp;chars[anchor], &amp;chars[write]);</span><br><span class="line">                &#125;</span><br><span class="line">                left = read + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> write;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = chars.length;</span><br><span class="line">        <span class="keyword">int</span> write = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> read = <span class="number">0</span>; read &lt; n; read++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (read == n - <span class="number">1</span> || chars[read] != chars[read + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//为了记录新连续字符串字符内容，覆盖原有记录</span></span><br><span class="line">                chars[write++] = chars[read];</span><br><span class="line">                <span class="keyword">int</span> num = read - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//数字的起点位置</span></span><br><span class="line">                    <span class="keyword">int</span> anchor = write;</span><br><span class="line">                    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//数字从右到左写入字符数组中</span></span><br><span class="line">                        chars[write++] = (<span class="keyword">char</span>) (num % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">                        num /= <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//将数字倒转过来</span></span><br><span class="line">                    reverse(chars, anchor, write - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                left = read + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> write;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[left];</span><br><span class="line">            chars[left] = chars[right];</span><br><span class="line">            chars[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Compress(char[] chars) &#123;</span><br><span class="line">        int n = chars.Length;</span><br><span class="line">        int write = 0, left = 0;</span><br><span class="line">        for (int read = 0; read &lt; n; read++) &#123;</span><br><span class="line">            if (read == n - 1 || chars[read] != chars[read + 1]) &#123;</span><br><span class="line">                chars[write++] = chars[read];</span><br><span class="line">                int num = read - left + 1;</span><br><span class="line">                if (num &gt; 1) &#123;</span><br><span class="line">                    int anchor = write;</span><br><span class="line">                    while (num &gt; 0) &#123;</span><br><span class="line">                        chars[write++] = (char) (num % 10 + &apos;0&apos;);</span><br><span class="line">                        num /= 10;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Reverse(chars, anchor, write - 1);</span><br><span class="line">                &#125;</span><br><span class="line">                left = read + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return write;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Reverse(char[] chars, int left, int right) &#123;</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            char temp = chars[left];</span><br><span class="line">            chars[left] = chars[right];</span><br><span class="line">            chars[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> t = *a;</span><br><span class="line">    *a = *b, *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (a &lt; b) &#123;</span><br><span class="line">        swap(a++, --b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span> *chars, <span class="keyword">int</span> charsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> write = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> read = <span class="number">0</span>; read &lt; charsSize; read++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (read == charsSize - <span class="number">1</span> || chars[read] != chars[read + <span class="number">1</span>]) &#123;</span><br><span class="line">            chars[write++] = chars[read];</span><br><span class="line">            <span class="keyword">int</span> num = read - left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> anchor = write;</span><br><span class="line">                <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    chars[write++] = num % <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                    num /= <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                reverse(&amp;chars[anchor], &amp;chars[write]);</span><br><span class="line">            &#125;</span><br><span class="line">            left = read + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> write;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compress</span><span class="params">(self, chars: List[str])</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(left: int, right: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                chars[left], chars[right] = chars[right], chars[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        n = len(chars)</span><br><span class="line">        write = left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> read <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> read == n - <span class="number">1</span> <span class="keyword">or</span> chars[read] != chars[read + <span class="number">1</span>]:</span><br><span class="line">                chars[write] = chars[read]</span><br><span class="line">                write += <span class="number">1</span></span><br><span class="line">                num = read - left + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                    anchor = write</span><br><span class="line">                    <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                        chars[write] = str(num % <span class="number">10</span>)</span><br><span class="line">                        write += <span class="number">1</span></span><br><span class="line">                        num //= <span class="number">10</span></span><br><span class="line">                    reverse(anchor, write - <span class="number">1</span>)</span><br><span class="line">                left = read + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> write</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compress</span><span class="params">(chars []<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    write, left := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> read, ch := <span class="keyword">range</span> chars &#123;</span><br><span class="line">        <span class="keyword">if</span> read == <span class="built_in">len</span>(chars)<span class="number">-1</span> || ch != chars[read+<span class="number">1</span>] &#123;</span><br><span class="line">            chars[write] = ch</span><br><span class="line">            write++</span><br><span class="line">            num := read - left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span> &#123;</span><br><span class="line">                anchor := write</span><br><span class="line">                <span class="keyword">for</span> ; num &gt; <span class="number">0</span>; num /= <span class="number">10</span> &#123;</span><br><span class="line">                    chars[write] = <span class="string">'0'</span> + <span class="keyword">byte</span>(num%<span class="number">10</span>)</span><br><span class="line">                    write++</span><br><span class="line">                &#125;</span><br><span class="line">                s := chars[anchor:write]</span><br><span class="line">                <span class="keyword">for</span> i, n := <span class="number">0</span>, <span class="built_in">len</span>(s); i &lt; n/<span class="number">2</span>; i++ &#123;</span><br><span class="line">                    s[i], s[n<span class="number">-1</span>-i] = s[n<span class="number">-1</span>-i], s[i]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left = read + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> write</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compress = <span class="function"><span class="keyword">function</span>(<span class="params">chars</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = chars.length;</span><br><span class="line">    <span class="keyword">let</span> write = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> read = <span class="number">0</span>; read &lt; n; read++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (read === n - <span class="number">1</span> || chars[read] !== chars[read + <span class="number">1</span>]) &#123;</span><br><span class="line">            chars[write++] = chars[read];</span><br><span class="line">            <span class="keyword">let</span> num = read - left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> anchor = write;</span><br><span class="line">                <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    chars[write++] = <span class="string">''</span> + num % <span class="number">10</span>;</span><br><span class="line">                    num = <span class="built_in">Math</span>.floor(num / <span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                reverse(chars, anchor, write - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            left = read + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> write;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reverse = <span class="function">(<span class="params">chars, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = chars[left];</span><br><span class="line">        chars[left] = chars[right];</span><br><span class="line">        chars[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 为字符串长度，我们只需要遍历该字符串一次。</p></li><li><p>空间复杂度：<em>O(1)</em>。我们只需要常数的空间保存若干变量。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个字符数组 chars ，请使用下述算法压缩&lt;/p&gt;
    
    </summary>
    
      <category term="2021年10月" scheme="http://yoursite.com/categories/2021%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>338. 比特位计数</title>
    <link href="http://yoursite.com/2021/10/24/338.%20%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2021/10/24/338. 比特位计数/</id>
    <published>2021-10-24T13:12:12.000Z</published>
    <updated>2021-10-24T14:03:05.727Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><p>输入：n = 2<br>输出：[0,1,1]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10<br>示例 2：</p><p>输入：n = 5<br>输出：[0,1,1,2,1,2]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10<br>3 –&gt; 11<br>4 –&gt; 100<br>5 –&gt; 101</p><p>提示：</p><p>0 &lt;= n &lt;= 105</p><p>进阶：</p><p>很容易就能实现时间复杂度为 O(n log n) 的解决方案，你可以在线性时间复杂度 O(n) 内用一趟扫描解决此问题吗？</p><p>你能不使用任何内置函数解决此问题吗？（如，C++ 中的 __builtin_popcount ）</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这道题需要计算从 <em>0</em> 到 <em>n</em> 的每个整数的二进制表示中的 <em>1</em> 的数目。</p><p>部分编程语言有相应的内置函数用于计算给定的整数的二进制表示中的 <em>1</em> 的数目，下列各种方法均为不使用内置函数的解法。</p><p>为了表述简洁，下文用「一比特数」表示二进制表示中的 <em>1</em> 的数目。</p><p>参考<a href="https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/" target="_blank" rel="noopener">^1</a></p><h1 id="方法一：BrianKernighan-算法"><a href="#方法一：BrianKernighan-算法" class="headerlink" title="方法一：BrianKernighan  算法"></a>方法一：BrianKernighan  算法</h1><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = countOnes(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countOnes</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x &amp;= (x - <span class="number">1</span>);</span><br><span class="line">            ones++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bits = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        bits[i] = countOnes(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countOnes = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ones = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        x &amp;= (x - <span class="number">1</span>);</span><br><span class="line">        ones++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">onesCount</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="params">(ones <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ; x &gt; <span class="number">0</span>; x &amp;= x - <span class="number">1</span> &#123;</span><br><span class="line">        ones++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countBits</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    bits := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> bits &#123;</span><br><span class="line">        bits[i] = onesCount(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">countOnes</span><span class="params">(x: int)</span> -&gt; int:</span></span><br><span class="line">            ones = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">                x &amp;= (x - <span class="number">1</span>)</span><br><span class="line">                ones += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ones</span><br><span class="line">        </span><br><span class="line">        bits = [countOnes(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> bits</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countOnes</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x &amp;= (x - <span class="number">1</span>);</span><br><span class="line">            ones++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bits(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = countOnes(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOnes</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        x &amp;= (x - <span class="number">1</span>);</span><br><span class="line">        ones++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* bits = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    *returnSize = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        bits[i] = countOnes(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度O(nlogn) 。需要对从 <em>0</em> 到 <em>n</em> 的每个整数使用计算「一比特数」，对于每个整数计算「一比特数」的时间都不会超过O(logn)。</p></li><li><p>空间复杂度：<em>O(1)</em>。除了返回的数组以外，空间复杂度为常数。</p></li></ul><h1 id="方法二：动态规划——最高有效位"><a href="#方法二：动态规划——最高有效位" class="headerlink" title="方法二：动态规划——最高有效位"></a>方法二：动态规划——最高有效位</h1><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                highBit = i;</span><br><span class="line">            &#125;</span><br><span class="line">            bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bits = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> highBit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            highBit = i;</span><br><span class="line">        &#125;</span><br><span class="line">        bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countBits</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    bits := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    highBit := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i&amp;(i<span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">            highBit = i</span><br><span class="line">        &#125;</span><br><span class="line">        bits[i] = bits[i-highBit] + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        bits = [<span class="number">0</span>]</span><br><span class="line">        highBit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &amp; (i - <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">                highBit = i</span><br><span class="line">            bits.append(bits[i - highBit] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> bits</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bits(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                highBit = i;</span><br><span class="line">            &#125;</span><br><span class="line">            bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* bits = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    *returnSize = n + <span class="number">1</span>;</span><br><span class="line">    bits[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            highBit = i;</span><br><span class="line">        &#125;</span><br><span class="line">        bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*。对于每个整数，只需要 *O(1)</em> 的时间计算「一比特数」。</p></li><li><p>空间复杂度：<em>O(1)</em>。除了返回的数组以外，空间复杂度为常数。</p></li></ul><h1 id="方法三：动态规划——最低有效位"><a href="#方法三：动态规划——最低有效位" class="headerlink" title="方法三：动态规划——最低有效位"></a>方法三：动态规划——最低有效位</h1><p>方法二需要实时维护最高有效位，当遍历到的数是 <em>2</em> 的整数次幂时，需要更新最高有效位。如果再换一个思路，可以使用「最低有效位」计算「一比特数」。</p><p>对于正整数 <em>x</em>，将其二进制表示右移一位，等价于将其二进制表示的最低位去掉。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol3-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bits = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countBits</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    bits := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        bits[i] = bits[i&gt;&gt;<span class="number">1</span>] + i&amp;<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        bits = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            bits.append(bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> bits</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bits(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol3-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* bits = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    *returnSize = n + <span class="number">1</span>;</span><br><span class="line">    bits[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*。对于每个整数，只需要 *O(1)</em> 的时间计算「一比特数」。</p></li><li><p>空间复杂度：<em>O(1)</em>。除了返回的数组以外，空间复杂度为常数。</p></li></ul><h1 id="方法四：动态规划——最低设置位"><a href="#方法四：动态规划——最低设置位" class="headerlink" title="方法四：动态规划——最低设置位"></a>方法四：动态规划——最低设置位</h1><p>定义正整数 <em>x</em> 的「最低设置位」为 <em>x</em> 的二进制表示中的最低的 <em>1</em> 所在位。例如，<em>10</em> 的二进制表示是 <em>1010_{(2)}</em>，其最低设置位为 <em>2</em>，对应的二进制表示是 <em>10_{(2)}</em>。</p><p>遍历从 <em>1</em> 到 <em>n</em> 的每个正整数 <em>i</em>，计算 <img src="./p__textit%7Bbits%7D_.png" alt="\textit{bits} ">  的值。最终得到的数组 <img src="./p__textit%7Bbits%7D_.png" alt="\textit{bits} ">  即为答案。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol4-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol4-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bits = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol4-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countBits</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    bits := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        bits[i] = bits[i&amp;(i<span class="number">-1</span>)] + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol4-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        bits = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            bits.append(bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> bits</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol4-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bits(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol4-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* bits = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    *returnSize = n + <span class="number">1</span>;</span><br><span class="line">    bits[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*。对于每个整数，只需要 *O(1)</em> 的时间计算「一比特数」。</p></li><li><p>空间复杂度：<em>O(1)</em>。除了返回的数组以外，空间复杂度为常数。</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题虽然看起来简单，但做的时候还是有几个值得注意的点</p><h2 id="判断一个正整数是不是-2-的整数次幂-i-amp-i-1-0"><a href="#判断一个正整数是不是-2-的整数次幂-i-amp-i-1-0" class="headerlink" title="判断一个正整数是不是 2 的整数次幂(i &amp; (i - 1)) == 0"></a>判断一个正整数是不是 2 的整数次幂(i &amp; (i - 1)) == 0</h2><h2 id="与-amp-符号的运算优先级，注意加括号-bits-i-bits-i-gt-gt-1-i-amp-1"><a href="#与-amp-符号的运算优先级，注意加括号-bits-i-bits-i-gt-gt-1-i-amp-1" class="headerlink" title="与&amp;符号的运算优先级，注意加括号 bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1);"></a>与&amp;符号的运算优先级，注意加括号 bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1);</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个整数 n ，对于 0 &amp;lt;= i &amp;lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年10月" scheme="http://yoursite.com/categories/2021%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>262. 行程和用户</title>
    <link href="http://yoursite.com/2021/10/21/262.%20%E8%A1%8C%E7%A8%8B%E5%92%8C%E7%94%A8%E6%88%B7/"/>
    <id>http://yoursite.com/2021/10/21/262. 行程和用户/</id>
    <published>2021-10-21T11:12:12.000Z</published>
    <updated>2021-10-21T12:16:04.136Z</updated>
    
    <content type="html"><![CDATA[<p>写一段 SQL 语句查出 “2013-10-01” 至 “2013-10-03” 期间非禁止用户（乘客和司机都必须未被禁止）的取消率。非禁止用户即 Ban<br>ned 为 No 的用户，禁止用户即 Banned 为 Yes 的用户。 </p><a id="more"></a><p>[TOC]</p><p>表：Trips</p><pre><code>+-------------+----------+| Column Name | Type     |+-------------+----------+| Id          | int      || Client_Id   | int      || Driver_Id   | int      || City_Id     | int      || Status      | enum     || Request_at  | date     |     +-------------+----------+</code></pre><p>Id 是这张表的主键。<br>这张表中存所有出租车的行程信息。每段行程有唯一 Id ，其中 Client_Id 和 Driver_Id 是 Users 表中 Users_Id 的外键。<br>Status 是一个表示行程状态的枚举类型，枚举成员为(‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_<br>client’) 。</p><p> 表：Users </p><pre><code>+-------------+----------+| Column Name | Type     |+-------------+----------+| Users_Id    | int      || Banned      | enum     || Role        | enum     |+-------------+----------+</code></pre><p>Users_Id 是这张表的主键。<br>这张表中存所有用户，每个用户都有一个唯一的 Users_Id ，Role 是一个表示用户身份的枚举类型，枚举成员为 (‘client’, ‘driver’,<br> ‘partner’) 。<br>Banned 是一个表示用户是否被禁止的枚举类型，枚举成员为 (‘Yes’, ‘No’) 。</p><p> 写一段 SQL 语句查出 “2013-10-01” 至 “2013-10-03” 期间非禁止用户（乘客和司机都必须未被禁止）的取消率。非禁止用户即 Ban<br>ned 为 No 的用户，禁止用户即 Banned 为 Yes 的用户。 </p><p> 取消率 的计算方式如下：(被司机或乘客取消的非禁止用户生成的订单数量) / (非禁止用户生成的订单总数)。 </p><p> 返回结果表中的数据可以按任意顺序组织。其中取消率 Cancellation Rate 需要四舍五入保留 两位小数 。 </p><p> 查询结果格式如下例所示： </p><p>Trips 表：</p><pre><code>+----+-----------+-----------+---------+---------------------+------------+| Id | Client_Id | Driver_Id | City_Id | Status              | Request_at |+----+-----------+-----------+---------+---------------------+------------+| 1  | 1         | 10        | 1       | completed           | 2013-10-01 || 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 || 3  | 3         | 12        | 6       | completed           | 2013-10-01 || 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 || 5  | 1         | 10        | 1       | completed           | 2013-10-02 || 6  | 2         | 11        | 6       | completed           | 2013-10-02 || 7  | 3         | 12        | 6       | completed           | 2013-10-02 || 8  | 2         | 12        | 12      | completed           | 2013-10-03 || 9  | 3         | 10        | 12      | completed           | 2013-10-03 || 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |+----+-----------+-----------+---------+---------------------+------------+</code></pre><p>Users 表：</p><pre><code>+----------+--------+--------+| Users_Id | Banned | Role   |+----------+--------+--------+| 1        | No     | client || 2        | Yes    | client || 3        | No     | client || 4        | No     | client || 10       | No     | driver || 11       | No     | driver || 12       | No     | driver || 13       | No     | driver |+----------+--------+--------+</code></pre><p>Result 表：</p><pre><code>+------------+-------------------+| Day        | Cancellation Rate |+------------+-------------------+| 2013-10-01 | 0.33              || 2013-10-02 | 0.00              || 2013-10-03 | 0.50              |+------------+-------------------+</code></pre><p>2013-10-01：</p><ul><li>共有 4 条请求，其中 2 条取消。</li><li>然而，Id=2 的请求是由禁止用户（User_Id=2）发出的，所以计算时应当忽略它。</li><li>因此，总共有 3 条非禁止请求参与计算，其中 1 条取消。</li><li>取消率为 (1 / 3) = 0.33<br>2013-10-02：</li><li>共有 3 条请求，其中 0 条取消。</li><li>然而，Id=6 的请求是由禁止用户发出的，所以计算时应当忽略它。</li><li>因此，总共有 2 条非禁止请求参与计算，其中 0 条取消。</li><li>取消率为 (0 / 2) = 0.00<br>2013-10-03：</li><li>共有 3 条请求，其中 1 条取消。</li><li>然而，Id=8 的请求是由禁止用户发出的，所以计算时应当忽略它。</li><li>因此，总共有 2 条非禁止请求参与计算，其中 1 条取消。</li><li>取消率为 (1 / 2) = 0.50</li></ul><p>统计每天非禁止用户的取消率，需要知道非禁止用户有哪些，总行程数，取消的行程数。</p><h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><p>首先确定被禁止用户的行程记录，再剔除这些行程记录。</p><p>行程表中，字段 client_id 和 driver_id，都与用户表中的 users_id 关联。因此只要 client_id 和 driver_id 中有一个被禁止了，此条行程记录要被剔除。</p><p>先说一种错误的找出没被禁止用户行程记录的方法。此方法很有迷惑性。</p><p>思路：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (client_id = users_id 或 driver_id = users_id) 且 users_id没有被禁止</span><br><span class="line">&#123;</span><br><span class="line">    此条记录没被禁止。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SQL 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM Trips AS T JOIN Users AS U </span><br><span class="line">ON (T.client_id = U.users_id  OR T.driver_id = U.users_id )  AND U.banned =&apos;No&apos;</span><br></pre></td></tr></table></figure><p>乍一看，思路是对。其实是错误的。因为，我们不知觉得肯定了一个假设—— client_id 与 driver_id 是相同的。只有当两者相同时，才能用此条件排除被禁止用户的行程记录。</p><p>错误的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+------+-----------+-----------+---------+---------------------+------------+----------+--------+--------+</span><br><span class="line">| Id   | Client_Id | Driver_Id | City_Id | STATUS              | Request_at | Users_Id | Banned | Role   |</span><br><span class="line">+------+-----------+-----------+---------+---------------------+------------+----------+--------+--------+</span><br><span class="line">|    1 |         1 |        10 |       1 | completed           | 2013-10-01 |        1 | No     | client |</span><br><span class="line">|    1 |         1 |        10 |       1 | completed           | 2013-10-01 |       10 | No     | driver |</span><br><span class="line">|    2 |         2 |        11 |       1 | cancelled_by_driver | 2013-10-01 |       11 | No     | driver |</span><br><span class="line">|    3 |         3 |        12 |       6 | completed           | 2013-10-01 |        3 | No     | client |</span><br><span class="line">|    3 |         3 |        12 |       6 | completed           | 2013-10-01 |       12 | No     | driver |</span><br><span class="line">|    4 |         4 |        13 |       6 | cancelled_by_client | 2013-10-01 |        4 | No     | client |</span><br><span class="line">|    4 |         4 |        13 |       6 | cancelled_by_client | 2013-10-01 |       13 | No     | driver |</span><br><span class="line">|    5 |         1 |        10 |       1 | completed           | 2013-10-02 |        1 | No     | client |</span><br><span class="line">|    5 |         1 |        10 |       1 | completed           | 2013-10-02 |       10 | No     | driver |</span><br><span class="line">|    6 |         2 |        11 |       6 | completed           | 2013-10-02 |       11 | No     | driver |</span><br><span class="line">|    7 |         3 |        12 |       6 | completed           | 2013-10-02 |        3 | No     | client |</span><br><span class="line">|    7 |         3 |        12 |       6 | completed           | 2013-10-02 |       12 | No     | driver |</span><br><span class="line">|    8 |         2 |        12 |      12 | completed           | 2013-10-03 |       12 | No     | driver |</span><br><span class="line">|    9 |         3 |        10 |      12 | completed           | 2013-10-03 |        3 | No     | client |</span><br><span class="line">|    9 |         3 |        10 |      12 | completed           | 2013-10-03 |       10 | No     | driver |</span><br><span class="line">|   10 |         4 |        13 |      12 | cancelled_by_driver | 2013-10-03 |        4 | No     | client |</span><br><span class="line">|   10 |         4 |        13 |      12 | cancelled_by_driver | 2013-10-03 |       13 | No     | driver |</span><br><span class="line">+------+-----------+-----------+---------+---------------------+------------+----------+--------+--------+</span><br></pre></td></tr></table></figure><p>结果中，被禁止的 users_id = 2，其行程记录没被剔除掉。</p><p>明显， client_id 与 driver_id 不一定相同 。</p><p>正确的做法是对 client_id 和 driver_id 各自关联的 users_id，同时检测是否被禁止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (client_id = users_id_1 且 users_id_1没被禁止 并且 client_id = users_id_2 且 users_id_2没被禁止)&#123;</span><br><span class="line">    此条记录没被禁止。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SQL 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM Trips AS T</span><br><span class="line">JOIN Users AS U1 ON (T.client_id = U1.users_id AND U1.banned =&apos;No&apos;)</span><br><span class="line">JOIN Users AS U2 ON (T.driver_id = U2.users_id AND U2.banned =&apos;No&apos;)</span><br></pre></td></tr></table></figure><p>在此基础上，按日期分组，统计每组的 总行程数，取消的行程数 。</p><p>每组的总行程数：COUNT(T.STATUS)。</p><p>每组的取消的行程数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SUM(</span><br><span class="line">IF(T.STATUS = &apos;completed&apos;,0,1)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>取消率 = 每组的取消的行程数 / 每组的总行程数</p><p>完整逻辑为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT T.request_at AS `Day`, </span><br><span class="line">ROUND(</span><br><span class="line">SUM(</span><br><span class="line">IF(T.STATUS = &apos;completed&apos;,0,1)</span><br><span class="line">)</span><br><span class="line">/ </span><br><span class="line">COUNT(T.STATUS),</span><br><span class="line">2</span><br><span class="line">) AS `Cancellation Rate`</span><br><span class="line">FROM Trips AS T</span><br><span class="line">JOIN Users AS U1 ON (T.client_id = U1.users_id AND U1.banned =&apos;No&apos;)</span><br><span class="line">JOIN Users AS U2 ON (T.driver_id = U2.users_id AND U2.banned =&apos;No&apos;)</span><br><span class="line">WHERE T.request_at BETWEEN &apos;2013-10-01&apos; AND &apos;2013-10-03&apos;</span><br><span class="line">GROUP BY T.request_at</span><br></pre></td></tr></table></figure><p>其中 SUM 求和函数，COUNT 计数函数，ROUND 四舍五入函数。</p><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>思路与解法一相同。而采用不同的方法排除掉被禁止用户的行程记录。想到排除，就联想到集合差。</p><p>client_id 和 driver_id 的全部为集合 U。被禁止的 users_id 集合为 A。</p><p>U 减去 A 的结果为没被禁止的用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">) AS A</span><br></pre></td></tr></table></figure><p>好了，先演示一个错误的解法：</p><p>行程表连接表 A，排除掉被被禁止的行程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM trips AS T,</span><br><span class="line">(</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">) AS A</span><br><span class="line">WHERE (T.Client_Id != A.users_id AND T.Driver_Id != A.users_id)</span><br></pre></td></tr></table></figure><p>剩下的逻辑与解法一后部分相同，完善后的逻辑为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT T.request_at AS `Day`, </span><br><span class="line">ROUND(</span><br><span class="line">SUM(</span><br><span class="line">IF(T.STATUS = &apos;completed&apos;,0,1)</span><br><span class="line">)</span><br><span class="line">/ </span><br><span class="line">COUNT(T.STATUS),</span><br><span class="line">2</span><br><span class="line">) AS `Cancellation Rate`</span><br><span class="line">FROM trips AS T,</span><br><span class="line">(</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">) AS A</span><br><span class="line">WHERE (T.Client_Id != A.users_id AND T.Driver_Id != A.users_id) AND T.request_at BETWEEN &apos;2013-10-01&apos; AND &apos;2013-10-03&apos;</span><br><span class="line">GROUP BY T.request_at</span><br></pre></td></tr></table></figure><p>很可惜，当表 A 为空时，此方法的结果是空表。但是表 A 为空，可能是有用户但是没有被禁止的用户。因此方法是错误的。</p><p>正确的解法是：行程表 left join 表 A 两次，A.users_id 都为 NULL 的行都是没被排除的行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM trips AS T LEFT JOIN </span><br><span class="line">(</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">) AS A ON (T.Client_Id = A.users_id)</span><br><span class="line">LEFT JOIN (</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">) AS A1</span><br><span class="line">ON (T.Driver_Id = A1.users_id)</span><br><span class="line">WHERE A.users_id IS NULL AND A1.users_id IS NULL</span><br></pre></td></tr></table></figure><p>补上其它部分的逻辑为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SELECT T.request_at AS `Day`, </span><br><span class="line">ROUND(</span><br><span class="line">SUM(</span><br><span class="line">IF(T.STATUS = &apos;completed&apos;,0,1)</span><br><span class="line">)</span><br><span class="line">/ </span><br><span class="line">COUNT(T.STATUS),</span><br><span class="line">2</span><br><span class="line">) AS `Cancellation Rate`</span><br><span class="line">FROM trips AS T LEFT JOIN </span><br><span class="line">(</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">) AS A ON (T.Client_Id = A.users_id)</span><br><span class="line">LEFT JOIN (</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">) AS A1</span><br><span class="line">ON (T.Driver_Id = A1.users_id)</span><br><span class="line">WHERE A.users_id IS NULL AND A1.users_id IS NULL AND T.request_at BETWEEN &apos;2013-10-01&apos; AND &apos;2013-10-03&apos;</span><br><span class="line">GROUP BY T.request_at</span><br></pre></td></tr></table></figure><h1 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h1><p>与解法二思路相同。找出被禁止的用户后，不再连接行程表和用户表，直接从行程表中排除掉被被禁止用户的行程记录。</p><p>被禁止的用户用子查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>行程表中 client_id 和 driver_id 都在此子查询结果中的行要剔除掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM trips AS T</span><br><span class="line">WHERE </span><br><span class="line">T.Client_Id NOT IN (</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">)</span><br><span class="line">AND</span><br><span class="line">T.Driver_Id NOT IN (</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>补上其它部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SELECT T.request_at AS `Day`, </span><br><span class="line">ROUND(</span><br><span class="line">SUM(</span><br><span class="line">IF(T.STATUS = &apos;completed&apos;,0,1)</span><br><span class="line">)</span><br><span class="line">/ </span><br><span class="line">COUNT(T.STATUS),</span><br><span class="line">2</span><br><span class="line">) AS `Cancellation Rate`</span><br><span class="line">FROM trips AS T</span><br><span class="line">WHERE </span><br><span class="line">T.Client_Id NOT IN (</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">)</span><br><span class="line">AND</span><br><span class="line">T.Driver_Id NOT IN (</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">)</span><br><span class="line">AND T.request_at BETWEEN &apos;2013-10-01&apos; AND &apos;2013-10-03&apos;</span><br><span class="line">GROUP BY T.request_at</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写一段 SQL 语句查出 “2013-10-01” 至 “2013-10-03” 期间非禁止用户（乘客和司机都必须未被禁止）的取消率。非禁止用户即 Ban&lt;br&gt;ned 为 No 的用户，禁止用户即 Banned 为 Yes 的用户。 &lt;/p&gt;
    
    </summary>
    
      <category term="2021年10月" scheme="http://yoursite.com/categories/2021%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>29. 两数相除</title>
    <link href="http://yoursite.com/2021/10/18/29.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/"/>
    <id>http://yoursite.com/2021/10/18/29. 两数相除/</id>
    <published>2021-10-18T11:12:12.000Z</published>
    <updated>2021-10-19T11:27:50.856Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 ‘*’、除号 ‘/‘ 以及求余符号 ‘%’。</p><a id="more"></a><p>[TOC]</p><p>注意：</p><p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231−1]。本题中，如果除法结果溢出，则返回 231 − 1</p><p>示例 1：</p><pre><code>输入：a = 15, b = 2输出：7解释：15/2 = truncate(7.5) = 7</code></pre><p>示例 2：</p><pre><code>输入：a = 7, b = -3输出：-2解释：7/-3 = truncate(-2.33333..) = -2</code></pre><p>示例 3：</p><pre><code>输入：a = 0, b = 1输出：0</code></pre><p>示例 4：</p><pre><code>输入：a = 1, b = 1输出：1</code></pre><p>提示:</p><pre><code>-2^31 &lt;= a, b &lt;= 2^31 - 1b != 0</code></pre><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于题目规定了「只能存储 <em>32</em> 位整数」，本题解的正文部分和代码中都不会使用任何 <em>64</em> 位整数。<strong>诚然，使用 <em>64</em> 位整数可以极大地方便我们的编码，但这是违反题目规则的。</strong></p><p>如果除法结果溢出，那么我们需要返回 <em>2^{31} - 1</em> 作为答案。因此在编码之前，我们可以首先对于溢出或者容易出错的边界情况进行讨论：</p><ul><li><p>当被除数为 <em>32</em> 位有符号整数的最小值 <em>-2^{31}</em> 时：</p><ul><li>如果除数为 <em>1</em>，那么我们可以直接返回答案 <em>-2^{31}</em>；</li><li>如果除数为 <em>-1</em>，那么答案为 <em>2^{31}</em>，产生了溢出。此时我们需要返回 <em>2^{31} - 1</em>。</li></ul></li><li><p>当除数为 <em>32</em> 位有符号整数的最小值 <em>-2^{31}</em> 时：</p><ul><li>如果被除数同样为 <em>-2^{31}</em>，那么我们可以直接返回答案 <em>1</em>；</li><li>对于其余的情况，我们返回答案 <em>0</em>。</li></ul></li><li><p>当被除数为 <em>0</em> 时，我们可以直接返回答案 <em>0</em>。</p></li></ul><p>对于一般的情况，根据除数和被除数的符号，我们需要考虑 <em>4</em> 种不同的可能性。因此，为了方便编码，我们可以将被除数或者除数取相反数，使得它们符号相同。</p><p>如果我们将被除数和除数都变为正数，那么可能会导致溢出。例如当被除数为 <em>-2^{31}</em> 时，它的相反数 <em>2^{31}</em> 产生了溢出。因此，我们可以考虑将被除数和除数都变为负数，这样就不会有溢出的问题，在编码时只需要考虑 <em>1</em> 种情况了。</p><p>如果我们将被除数和除数的其中（恰好）一个变为了正数，那么在返回答案之前，我们需要对答案也取相反数。</p><h2 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h2><p><strong>思路与算法</strong></p><p>根据「前言」部分的讨论，我们记被除数为 <em>X</em>，除数为 <em>Y</em>，并且 <em>X</em> 和 <em>Y</em> 都是负数。我们需要找出 <em>X/Y</em> 的结果 <em>Z</em>。<em>Z</em> 一定是正数或 <em>0</em>。</p><p>根据除法以及余数的定义，我们可以将其改成乘法的等价形式</p><p><strong>细节</strong></p><p>由于我们只能使用 <em>32</em> 位整数，因此二分查找中会有很多细节。</p><p>首先，二分查找的下界为 <em>1</em>，上界为 <em>2^{31} - 1*。唯一可能出现的答案为 *2^{31}</em> 的情况已经被我们在「前言」部分进行了特殊处理，因此答案的最大值为 <em>2^{31} - 1</em>。如果二分查找失败，那么答案一定为 <em>0</em>。</p><p>在实现「快速乘」时，我们需要使用加法运算，然而较大的 <em>Z</em> 也会导致加法运算溢出。例如我们要判断 <em>A + B</em> 是否小于 <em>C</em> 时（其中 <em>A, B, C</em> 均为负数），<em>A + B</em> 可能会产生溢出，因此我们必须将判断改为 <em>A &lt; C - B</em> 是否成立。由于任意两个负数的差一定在 <em>[-2^{31} + 1, 2^{31} - 1]</em> 范围内，这样就不会产生溢出。</p><p>读者可以阅读下面的代码和注释，理解如何避免使用乘法和除法，以及正确处理溢出问题。<a href="https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (divisor == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">return</span> dividend == INT_MIN ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一般情况，使用二分查找</span></span><br><span class="line">        <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        <span class="keyword">bool</span> rev = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快速乘</span></span><br><span class="line">        <span class="keyword">auto</span> quickAdd = [](<span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> x) &#123;</span><br><span class="line">            <span class="comment">// x 和 y 是负数，z 是正数</span></span><br><span class="line">            <span class="comment">// 需要判断 z * y &gt;= x 是否成立</span></span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>, add = y;</span><br><span class="line">            <span class="keyword">while</span> (z) &#123;</span><br><span class="line">                <span class="keyword">if</span> (z &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要保证 result + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> (result &lt; x - add) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result += add;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (z != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要保证 add + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> (add &lt; x - add) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    add += add;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不能使用除法</span></span><br><span class="line">                z &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = INT_MAX, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 注意溢出，并且不能使用除法</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">bool</span> check = quickAdd(divisor, mid, dividend);</span><br><span class="line">            <span class="keyword">if</span> (check) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="comment">// 注意溢出</span></span><br><span class="line">                <span class="keyword">if</span> (mid == INT_MAX) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rev ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (divisor == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (divisor == Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> dividend == Integer.MIN_VALUE ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一般情况，使用二分查找</span></span><br><span class="line">        <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        <span class="keyword">boolean</span> rev = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = Integer.MAX_VALUE, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 注意溢出，并且不能使用除法</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">boolean</span> check = quickAdd(divisor, mid, dividend);</span><br><span class="line">            <span class="keyword">if</span> (check) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="comment">// 注意溢出</span></span><br><span class="line">                <span class="keyword">if</span> (mid == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rev ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速乘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quickAdd</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// x 和 y 是负数，z 是正数</span></span><br><span class="line">        <span class="comment">// 需要判断 z * y &gt;= x 是否成立</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>, add = y;</span><br><span class="line">        <span class="keyword">while</span> (z != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((z &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 需要保证 result + add &gt;= x</span></span><br><span class="line">                <span class="keyword">if</span> (result &lt; x - add) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                result += add;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (z != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 需要保证 add + add &gt;= x</span></span><br><span class="line">                <span class="keyword">if</span> (add &lt; x - add) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                add += add;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不能使用除法</span></span><br><span class="line">            z &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Divide(int dividend, int divisor) &#123;</span><br><span class="line">        // 考虑被除数为最小值的情况</span><br><span class="line">        if (dividend == int.MinValue) &#123;</span><br><span class="line">            if (divisor == 1) &#123;</span><br><span class="line">                return int.MinValue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (divisor == -1) &#123;</span><br><span class="line">                return int.MaxValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 考虑除数为最小值的情况</span><br><span class="line">        if (divisor == int.MinValue) &#123;</span><br><span class="line">            return dividend == int.MinValue ? 1 : 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 考虑被除数为 0 的情况</span><br><span class="line">        if (dividend == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 一般情况，使用二分查找</span><br><span class="line">        // 将所有的正数取相反数，这样就只需要考虑一种情况</span><br><span class="line">        bool rev = false;</span><br><span class="line">        if (dividend &gt; 0) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        if (divisor &gt; 0) &#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int left = 1, right = int.MaxValue, ans = 0;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            // 注意溢出，并且不能使用除法</span><br><span class="line">            int mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">            bool check = quickAdd(divisor, mid, dividend);</span><br><span class="line">            if (check) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                // 注意溢出</span><br><span class="line">                if (mid == int.MaxValue) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rev ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 快速乘</span><br><span class="line">    public bool quickAdd(int y, int z, int x) &#123;</span><br><span class="line">        // x 和 y 是负数，z 是正数</span><br><span class="line">        // 需要判断 z * y &gt;= x 是否成立</span><br><span class="line">        int result = 0, add = y;</span><br><span class="line">        while (z != 0) &#123;</span><br><span class="line">            if ((z &amp; 1) != 0) &#123;</span><br><span class="line">                // 需要保证 result + add &gt;= x</span><br><span class="line">                if (result &lt; x - add) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                result += add;</span><br><span class="line">            &#125;</span><br><span class="line">            if (z != 1) &#123;</span><br><span class="line">                // 需要保证 add + add &gt;= x</span><br><span class="line">                if (add &lt; x - add) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                add += add;</span><br><span class="line">            &#125;</span><br><span class="line">            // 不能使用除法</span><br><span class="line">            z &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class="line">        INT_MIN, INT_MAX = <span class="number">-2</span>**<span class="number">31</span>, <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> dividend == INT_MIN:</span><br><span class="line">            <span class="keyword">if</span> divisor == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> INT_MIN</span><br><span class="line">            <span class="keyword">if</span> divisor == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> INT_MAX</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> divisor == INT_MIN:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> dividend == INT_MIN <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> dividend == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 一般情况，使用二分查找</span></span><br><span class="line">        <span class="comment"># 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        rev = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> dividend &gt; <span class="number">0</span>:</span><br><span class="line">            dividend = -dividend</span><br><span class="line">            rev = <span class="keyword">not</span> rev</span><br><span class="line">        <span class="keyword">if</span> divisor &gt; <span class="number">0</span>:</span><br><span class="line">            divisor = -divisor</span><br><span class="line">            rev = <span class="keyword">not</span> rev</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 快速乘</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickAdd</span><span class="params">(y: int, z: int, x: int)</span> -&gt; bool:</span></span><br><span class="line">            <span class="comment"># x 和 y 是负数，z 是正数</span></span><br><span class="line">            <span class="comment"># 需要判断 z * y &gt;= x 是否成立</span></span><br><span class="line">            result, add = <span class="number">0</span>, y</span><br><span class="line">            <span class="keyword">while</span> z &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (z &amp; <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 需要保证 result + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> result &lt; x - add:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                    result += add</span><br><span class="line">                <span class="keyword">if</span> z != <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 需要保证 add + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> add &lt; x - add:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                    add += add</span><br><span class="line">                <span class="comment"># 不能使用除法</span></span><br><span class="line">                z &gt;&gt;= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">        left, right, ans = <span class="number">1</span>, INT_MAX, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 注意溢出，并且不能使用除法</span></span><br><span class="line">            mid = left + ((right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            check = quickAdd(divisor, mid, dividend)</span><br><span class="line">            <span class="keyword">if</span> check:</span><br><span class="line">                ans = mid</span><br><span class="line">                <span class="comment"># 注意溢出</span></span><br><span class="line">                <span class="keyword">if</span> mid == INT_MAX:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -ans <span class="keyword">if</span> rev <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速乘</span></span><br><span class="line"><span class="comment">// x 和 y 是负数，z 是正数</span></span><br><span class="line"><span class="comment">// 判断 z * y &gt;= x 是否成立</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickAdd</span><span class="params">(y, z, x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> result, add := <span class="number">0</span>, y; z &gt; <span class="number">0</span>; z &gt;&gt;= <span class="number">1</span> &#123; <span class="comment">// 不能使用除法</span></span><br><span class="line">        <span class="keyword">if</span> z&amp;<span class="number">1</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 需要保证 result + add &gt;= x</span></span><br><span class="line">            <span class="keyword">if</span> result &lt; x-add &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            result += add</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> z != <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// 需要保证 add + add &gt;= x</span></span><br><span class="line">            <span class="keyword">if</span> add &lt; x-add &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            add += add</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(dividend, divisor <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dividend == math.MinInt32 &#123; <span class="comment">// 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> divisor == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> math.MinInt32</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> divisor == <span class="number">-1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> math.MaxInt32</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> divisor == math.MinInt32 &#123; <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> dividend == math.MinInt32 &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> dividend == <span class="number">0</span> &#123; <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般情况，使用二分查找</span></span><br><span class="line">    <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">    rev := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> dividend &gt; <span class="number">0</span> &#123;</span><br><span class="line">        dividend = -dividend</span><br><span class="line">        rev = !rev</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> divisor &gt; <span class="number">0</span> &#123;</span><br><span class="line">        divisor = -divisor</span><br><span class="line">        rev = !rev</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    left, right := <span class="number">1</span>, math.MaxInt32</span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)&gt;&gt;<span class="number">1</span> <span class="comment">// 注意溢出，并且不能使用除法</span></span><br><span class="line">        <span class="keyword">if</span> quickAdd(divisor, mid, dividend) &#123;</span><br><span class="line">            ans = mid</span><br><span class="line">            <span class="keyword">if</span> mid == math.MaxInt32 &#123; <span class="comment">// 注意溢出</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> rev &#123;</span><br><span class="line">        <span class="keyword">return</span> -ans</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divide = <span class="function"><span class="keyword">function</span>(<span class="params">dividend, divisor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> MAX_VALUE = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>, MIN_VALUE = -(<span class="number">2</span> ** <span class="number">31</span>);</span><br><span class="line">    <span class="comment">// 考虑被除数为最小值的情况</span></span><br><span class="line">    <span class="keyword">if</span> (dividend === MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (divisor === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor === <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">    <span class="keyword">if</span> (divisor === MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> dividend === MIN_VALUE ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">    <span class="keyword">if</span> (dividend === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一般情况，使用二分查找</span></span><br><span class="line">    <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">    <span class="keyword">let</span> rev = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dividend = -dividend;</span><br><span class="line">        rev = !rev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        divisor = -divisor;</span><br><span class="line">        rev = !rev;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">1</span>, right = MAX_VALUE, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 注意溢出，并且不能使用除法</span></span><br><span class="line">        <span class="keyword">const</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">const</span> check = quickAdd(divisor, mid, dividend);</span><br><span class="line">        <span class="keyword">if</span> (check) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            <span class="comment">// 注意溢出</span></span><br><span class="line">            <span class="keyword">if</span> (mid === MAX_VALUE) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rev ? -ans : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速乘</span></span><br><span class="line"><span class="keyword">const</span> quickAdd = <span class="function">(<span class="params">y, z, x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// x 和 y 是负数，z 是正数</span></span><br><span class="line">    <span class="comment">// 需要判断 z * y &gt;= x 是否成立</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>, add = y;</span><br><span class="line">    <span class="keyword">while</span> (z !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((z &amp; <span class="number">1</span>) !== <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 需要保证 result + add &gt;= x</span></span><br><span class="line">            <span class="keyword">if</span> (result &lt; x - add) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result += add;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (z !== <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 需要保证 add + add &gt;= x</span></span><br><span class="line">            <span class="keyword">if</span> (add &lt; x - add) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            add += add;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不能使用除法</span></span><br><span class="line">        z &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h2 id="方法二：类二分查找"><a href="#方法二：类二分查找" class="headerlink" title="方法二：类二分查找"></a>方法二：类二分查找</h2><p><strong>思路与算法</strong><a href="https://leetcode-cn.com/problems/divide-two-integers/solution/liang-shu-xiang-chu-by-leetcode-solution-5hic/" target="_blank" rel="noopener">^1</a></p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (divisor == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">return</span> dividend == INT_MIN ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一般情况，使用类二分查找</span></span><br><span class="line">        <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        <span class="keyword">bool</span> rev = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candidates = &#123;divisor&#125;;</span><br><span class="line">        <span class="comment">// 注意溢出</span></span><br><span class="line">        <span class="keyword">while</span> (candidates.back() &gt;= dividend - candidates.back()) &#123;</span><br><span class="line">            candidates.push_back(candidates.back() + candidates.back());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = candidates.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidates[i] &gt;= dividend) &#123;</span><br><span class="line">                ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                dividend -= candidates[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rev ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (divisor == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (divisor == Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> dividend == Integer.MIN_VALUE ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一般情况，使用类二分查找</span></span><br><span class="line">        <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        <span class="keyword">boolean</span> rev = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; candidates = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        candidates.add(divisor);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意溢出</span></span><br><span class="line">        <span class="keyword">while</span> (candidates.get(index) &gt;= dividend - candidates.get(index)) &#123;</span><br><span class="line">            candidates.add(candidates.get(index) + candidates.get(index));</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = candidates.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidates.get(i) &gt;= dividend) &#123;</span><br><span class="line">                ans += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                dividend -= candidates.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rev ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Divide(int dividend, int divisor) &#123;</span><br><span class="line">        // 考虑被除数为最小值的情况</span><br><span class="line">        if (dividend == int.MinValue) &#123;</span><br><span class="line">            if (divisor == 1) &#123;</span><br><span class="line">                return int.MinValue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (divisor == -1) &#123;</span><br><span class="line">                return int.MaxValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 考虑除数为最小值的情况</span><br><span class="line">        if (divisor == int.MinValue) &#123;</span><br><span class="line">            return dividend == int.MinValue ? 1 : 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 考虑被除数为 0 的情况</span><br><span class="line">        if (dividend == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 一般情况，使用类二分查找</span><br><span class="line">        // 将所有的正数取相反数，这样就只需要考虑一种情况</span><br><span class="line">        bool rev = false;</span><br><span class="line">        if (dividend &gt; 0) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        if (divisor &gt; 0) &#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IList&lt;int&gt; candidates = new List&lt;int&gt;();</span><br><span class="line">        candidates.Add(divisor);</span><br><span class="line">        int index = 0;</span><br><span class="line">        // 注意溢出</span><br><span class="line">        while (candidates[index] &gt;= dividend - candidates[index]) &#123;</span><br><span class="line">            candidates.Add(candidates[index] + candidates[index]);</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = candidates.Count - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            if (candidates[i] &gt;= dividend) &#123;</span><br><span class="line">                ans += 1 &lt;&lt; i;</span><br><span class="line">                dividend -= candidates[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rev ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class="line">        INT_MIN, INT_MAX = <span class="number">-2</span>**<span class="number">31</span>, <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> dividend == INT_MIN:</span><br><span class="line">            <span class="keyword">if</span> divisor == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> INT_MIN</span><br><span class="line">            <span class="keyword">if</span> divisor == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> INT_MAX</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> divisor == INT_MIN:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> dividend == INT_MIN <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> dividend == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 一般情况，使用类二分查找</span></span><br><span class="line">        <span class="comment"># 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        rev = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> dividend &gt; <span class="number">0</span>:</span><br><span class="line">            dividend = -dividend</span><br><span class="line">            rev = <span class="keyword">not</span> rev</span><br><span class="line">        <span class="keyword">if</span> divisor &gt; <span class="number">0</span>:</span><br><span class="line">            divisor = -divisor</span><br><span class="line">            rev = <span class="keyword">not</span> rev</span><br><span class="line">        </span><br><span class="line">        candidates = [divisor]</span><br><span class="line">        <span class="comment"># 注意溢出</span></span><br><span class="line">        <span class="keyword">while</span> candidates[<span class="number">-1</span>] &gt;= dividend - candidates[<span class="number">-1</span>]:</span><br><span class="line">            candidates.append(candidates[<span class="number">-1</span>] + candidates[<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(candidates) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> candidates[i] &gt;= dividend:</span><br><span class="line">                ans += (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">                dividend -= candidates[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -ans <span class="keyword">if</span> rev <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(dividend, divisor <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dividend == math.MinInt32 &#123; <span class="comment">// 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> divisor == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> math.MinInt32</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> divisor == <span class="number">-1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> math.MaxInt32</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> divisor == math.MinInt32 &#123; <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> dividend == math.MinInt32 &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> dividend == <span class="number">0</span> &#123; <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般情况，使用二分查找</span></span><br><span class="line">    <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">    rev := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> dividend &gt; <span class="number">0</span> &#123;</span><br><span class="line">        dividend = -dividend</span><br><span class="line">        rev = !rev</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> divisor &gt; <span class="number">0</span> &#123;</span><br><span class="line">        divisor = -divisor</span><br><span class="line">        rev = !rev</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    candidates := []<span class="keyword">int</span>&#123;divisor&#125;</span><br><span class="line">    <span class="keyword">for</span> y := divisor; y &gt;= dividend-y; &#123; <span class="comment">// 注意溢出</span></span><br><span class="line">        y += y</span><br><span class="line">        candidates = <span class="built_in">append</span>(candidates, y)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(candidates) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> candidates[i] &gt;= dividend &#123;</span><br><span class="line">            ans |= <span class="number">1</span> &lt;&lt; i</span><br><span class="line">            dividend -= candidates[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> rev &#123;</span><br><span class="line">        <span class="keyword">return</span> -ans</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divide = <span class="function"><span class="keyword">function</span>(<span class="params">dividend, divisor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> MAX_VALUE = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>, MIN_VALUE = -(<span class="number">2</span> ** <span class="number">31</span>);</span><br><span class="line">    <span class="comment">// 考虑被除数为最小值的情况</span></span><br><span class="line">    <span class="keyword">if</span> (dividend === MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (divisor === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor === <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">    <span class="keyword">if</span> (divisor === MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> dividend === MIN_VALUE ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">    <span class="keyword">if</span> (dividend === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一般情况，使用类二分查找</span></span><br><span class="line">    <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">    <span class="keyword">let</span> rev = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dividend = -dividend;</span><br><span class="line">        rev = !rev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        divisor = -divisor;</span><br><span class="line">        rev = !rev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> candidates = [divisor];</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注意溢出</span></span><br><span class="line">    <span class="keyword">while</span> (candidates[index] &gt;= dividend - candidates[index]) &#123;</span><br><span class="line">        candidates.push(candidates[index] + candidates[index]);</span><br><span class="line">        ++index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = candidates.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates[i] &gt;= dividend) &#123;</span><br><span class="line">            ans += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            dividend -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rev ? -ans : ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 ‘*’、除号 ‘/‘ 以及求余符号 ‘%’。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年10月" scheme="http://yoursite.com/categories/2021%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>1071. 字符串的最大公因子</title>
    <link href="http://yoursite.com/2021/09/04/1071.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/"/>
    <id>http://yoursite.com/2021/09/04/1071. 字符串的最大公因子/</id>
    <published>2021-09-04T08:12:12.000Z</published>
    <updated>2021-09-06T02:45:24.264Z</updated>
    
    <content type="html"><![CDATA[<p>对于字符串 S 和 T，只有在 S = T + … + T（T 自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p><p>返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：str1 = &quot;ABCABC&quot;, str2 = &quot;ABC&quot;输出：&quot;ABC&quot;</code></pre><p>示例 2：</p><pre><code>输入：str1 = &quot;ABABAB&quot;, str2 = &quot;ABAB&quot;输出：&quot;AB&quot;</code></pre><p>示例 3：</p><pre><code>输入：str1 = &quot;LEET&quot;, str2 = &quot;CODE&quot;输出：&quot;&quot;</code></pre><p>提示：</p><pre><code>1 &lt;= str1.length &lt;= 10001 &lt;= str2.length &lt;= 1000str1[i] 和 str2[i] 为大写英文字母</code></pre><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><ul><li>约数，最大公约数</li><li>辗转相除法</li></ul><h1 id="方法一：枚举"><a href="#方法一：枚举" class="headerlink" title="方法一：枚举"></a>方法一：枚举</h1><p><strong>思路和算法</strong></p><p>首先答案肯定是字符串的某个前缀，然后简单直观的想法就是枚举所有的前缀来判断，我们设这个前缀串长度为 len ，<code>str1</code> 的长度为 len1，<code>str2</code> 的长度为 len2 ，则我们知道前缀串的长度必然要是两个字符串长度的约数才能满足条件，否则无法经过若干次拼接后得到长度相等的字符串</p><p>所以我们可以枚举符合长度条件的前缀串，再去判断这个前缀串拼接若干次以后是否等于 <code>str1</code> 和 <code>str2</code> 即可。</p><p>由于题目要求最长的符合要求的字符串 <code>X</code>，所以可以按长度从大到小枚举前缀串，这样碰到第一个满足条件的前缀串返回即可。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> t,<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenx = (<span class="keyword">int</span>)s.length() / (<span class="keyword">int</span>)t.length();</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenx; ++i)&#123;</span><br><span class="line">            ans = ans + t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">gcdOfStrings</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = (<span class="keyword">int</span>)str1.length(), len2 = (<span class="keyword">int</span>)str2.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(len1, len2); i &gt;= <span class="number">1</span>; --i)&#123; <span class="comment">// 从长度大的开始枚举</span></span><br><span class="line">            <span class="keyword">if</span> (len1 % i == <span class="number">0</span> &amp;&amp; len2 % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">string</span> X = str1.substr(<span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">if</span> (check(X, str1) &amp;&amp; check(X, str2)) <span class="keyword">return</span> X;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = str1.length(), len2 = str2.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = Math.min(len1, len2); i &gt;= <span class="number">1</span>; --i) &#123; <span class="comment">// 从长度大的开始枚举</span></span><br><span class="line">            <span class="keyword">if</span> (len1 % i == <span class="number">0</span> &amp;&amp; len2 % i == <span class="number">0</span>) &#123;</span><br><span class="line">                String X = str1.substring(<span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">if</span> (check(X, str1) &amp;&amp; check(X, str2)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> X;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String t, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenx = s.length() / t.length();</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenx; ++i) &#123;</span><br><span class="line">            ans.append(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString().equals(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcdOfStrings</span><span class="params">(self, str1: str, str2: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(min(len(str1), len(str2)), <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> (len(str1) % i) == <span class="number">0</span> <span class="keyword">and</span> (len(str2) % i) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> str1[: i] * (len(str1) // i) == str1 <span class="keyword">and</span> str1[: i] * (len(str2) // i) == str2:</span><br><span class="line">                    <span class="keyword">return</span> str1[: i]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><h1 id="方法二：枚举优化"><a href="#方法二：枚举优化" class="headerlink" title="方法二：枚举优化"></a>方法二：枚举优化</h1><p><strong>思路</strong></p><p>注意到一个性质：<strong>如果存在一个符合要求的字符串 <code>X</code>，那么也一定存在一个符合要求的字符串 <code>X&#39;</code>，它的长度为 <code>str1</code> 和 <code>str2</code> 长度的最大公约数</strong>。</p><p>简单来说，方法一中我们已经知道符合条件的长度出现在 gcd(len1,len2) 的所有约数中，我们假设其中一个满足条件的约数为 lenx ，该长度为 lenx 的前缀串 <em>X</em> 能经过若干次拼接后得到 <code>str1</code> 和 <code>str2</code>。拿 <code>str1</code> 举例，<em>X</em> 经过 len1/lenx  次拼接后得到了 <code>str1</code>，而 <em>X</em> 又能经过 gcd(len1,len2)/lenx 次拼接后得到长度为gcd(len1,len2) 的前缀串 <em>X’</em> ，所以我们可以每次取出 gcd(len1,len2)/lenx 个 <em>X</em> 来用 <em>X’</em> 完成替换，最后 <code>str1</code> 会被替换成 len1/gcd(len1,len2)  个 <em>X’</em> ，<code>str2</code> 同理可得。因此如果存在一个符合要求的字符串 <em>X</em>，那么也一定存在一个符合要求的字符串 <em>X’</em>，它的长度为 <code>str1</code> 和 <code>str2</code> 长度的最大公约数。我们只需要判断长度为gcd(len1,len2) 的前缀串是否满足要求即可。</p><p><strong>算法</strong></p><p>由上述性质我们可以先用辗转相除法求得两个字符串长度的最大公约数gcd(len1,len2) ，取出该长度的前缀串，判断一下它是否能经过若干次拼接得到 <code>str1</code> 和 <code>str2</code> 即可。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> t,<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenx = (<span class="keyword">int</span>)s.length() / (<span class="keyword">int</span>)t.length();</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenx; ++i)&#123;</span><br><span class="line">            ans = ans + t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">gcdOfStrings</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = (<span class="keyword">int</span>)str1.length(), len2 = (<span class="keyword">int</span>)str2.length();</span><br><span class="line">        <span class="built_in">string</span> T = str1.substr(<span class="number">0</span>, __gcd(len1,len2)); <span class="comment">// __gcd() 为c++自带的求最大公约数的函数</span></span><br><span class="line">        <span class="keyword">if</span> (check(T, str1) &amp;&amp; check(T, str2)) <span class="keyword">return</span> T;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = str1.length(), len2 = str2.length();</span><br><span class="line">        String T = str1.substring(<span class="number">0</span>, gcd(len1, len2));</span><br><span class="line">        <span class="keyword">if</span> (check(T, str1) &amp;&amp; check(T, str2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> T;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String t, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenx = s.length() / t.length();</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenx; ++i) &#123;</span><br><span class="line">            ans.append(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString().equals(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> remainder = a % b;</span><br><span class="line">        <span class="keyword">while</span> (remainder != <span class="number">0</span>) &#123;</span><br><span class="line">            a = b;</span><br><span class="line">            b = remainder;</span><br><span class="line">            remainder = a % b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcdOfStrings</span><span class="params">(self, str1: str, str2: str)</span> -&gt; str:</span></span><br><span class="line">        candidate_len = math.gcd(len(str1), len(str2))</span><br><span class="line">        candidate = str1[: candidate_len]</span><br><span class="line">        <span class="keyword">if</span> candidate * (len(str1) // candidate_len) == str1 <span class="keyword">and</span> candidate * (len(str2) // candidate_len) == str2:</span><br><span class="line">            <span class="keyword">return</span> candidate</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure></details><h1 id="方法三：数学"><a href="#方法三：数学" class="headerlink" title="方法三：数学"></a>方法三：数学</h1><p><strong>思路</strong></p><p>需要知道一个性质：<strong>如果 <code>str1</code> 和 <code>str2</code> 拼接后等于 <code>str2</code>和 <code>str1</code> 拼接起来的字符串（注意拼接顺序不同），那么一定存在符合条件的字符串 <code>X</code></strong>。</p><p>先证必要性，即如果存在符合条件的字符串 <code>X</code> ，则 <code>str1</code> 和 <code>str2</code> 拼接后等于 <code>str2</code>和 <code>str1</code> 拼接起来的字符串。</p><p>如果字符串 <code>X</code> 符合条件，那么 <code>str1=X+X+...+X+X=n*X</code> ，<code>str2=X+X+..+X+X=m*X</code>，<code>n*X</code> 表示 <code>n</code> 个字符串 <code>X</code> 拼接，<code>m*X</code> 同理，则 <code>str1</code> 与 <code>str2</code> 拼接后的字符串即为 <code>(n+m)*X</code>，而 <code>str2</code> 与 <code>str1</code> 拼接后的字符串即为 <code>(m+n)*X</code>，等于 <code>(n+m)*X</code>，所以必要性得证。</p><p>再看充分性，简单来说，我们可以如下图一样先将两个拼接后的字符串放在一起。不失一般性，我们假定 <code>str1</code> 的长度大于 <code>str2</code>，</p><p>我们等间隔取gcd(len1,len2) 长度的字符串。</p><p>如果该长度等于 <code>str2</code> 的长度，即 <code>str1</code> 的长度可以整除 <code>str2</code> 的长度。我们可以知道，已知图中第一部分等于图中的第二部分（都是字符串 <code>str1</code> 的开头），而图中的第二部分又等于第三部分（两个字符串相等），所以我们知道第三部分也是等于第一部分。同理我们可以推得图中划分的 <code>1,3,5,7</code> 四个部分都相等，所以拼接起来的字符串可以由第一部分的前缀串经过若干次拼接得到。</p><p>那么如果不等于 <code>str2</code> 的长度，我们由上文一样的方法可以推得下图中被染颜色相同的字符串片段是相等的，其中每个颜色片段都是长为 gcd(len1,len2) 的字符串。那么不同颜色代表的字符串是否也相等呢？如果相等就可以推得我们的结论是正确的。</p><p>其实由上图我们可以知道，因为第一个字符串和第二个字符串相等，所以两个字符串开头的部分必然相等。我们将前 len2/gcd(len1,len2) 个被染颜色的部分放在一起比较即可推得不同颜色的部分都是两两相等的，但是这是基于它们开头被染的颜色顺序是不同的，这一定成立吗？</p><p>其实图中可以看出第一个字符串被染的颜色是以 <code>str2</code> 的长度在循环的，由于第二种情况下 <code>str1</code> 的长度不整除 <code>str2</code> 的长度，导致第一个字符串的 <code>str1</code> 部分被染完颜色的时候，<code>str2</code> 被染的颜色的顺序必然不等于开头 <code>str1</code> 被染的颜色顺序，而第二个字符串的开头又是 <code>str2</code>，它被染色的顺序是等于第一个字符串中 <code>str2</code> 被染色的顺序的，所以两个字符串的开头被染的颜色顺序一定不同。最后我们就推出如果 <code>str1</code> 和 <code>str2</code> 拼接后等于 <code>str2</code> 和 <code>str1</code> 拼接起来的字符串，那么一定存在符合条件的字符串 <code>X</code>。</p><p><strong>算法</strong></p><p>有了该性质以及方法二的性质，我们就可以先判断 <code>str1</code> 和 <code>str2</code> 拼接后是否等于 <code>str2</code> 和 <code>str1</code> 拼接起来的字符串，如果等于直接输出长度为gcd(len1,len2) 的前缀串即可，否则返回空串。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">gcdOfStrings</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str1 + str2 != str2 + str1) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> str1.substr(<span class="number">0</span>, __gcd((<span class="keyword">int</span>)str1.length(), (<span class="keyword">int</span>)str2.length())); <span class="comment">// __gcd() 为c++自带的求最大公约数的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!str1.concat(str2).equals(str2.concat(str1))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>, gcd(str1.length(), str2.length()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> remainder = a % b;</span><br><span class="line">        <span class="keyword">while</span> (remainder != <span class="number">0</span>) &#123;</span><br><span class="line">            a = b;</span><br><span class="line">            b = remainder;</span><br><span class="line">            remainder = a % b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcdOfStrings</span><span class="params">(self, str1: str, str2: str)</span> -&gt; str:</span></span><br><span class="line">        candidate_len = math.gcd(len(str1), len(str2))</span><br><span class="line">        candidate = str1[: candidate_len]</span><br><span class="line">        <span class="keyword">if</span> str1 + str2 == str2 + str1:</span><br><span class="line">            <span class="keyword">return</span> candidate</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于字符串 S 和 T，只有在 S = T + … + T（T 自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。&lt;/p&gt;
&lt;p&gt;返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年9月" scheme="http://yoursite.com/categories/2021%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>1206. 设计跳表</title>
    <link href="http://yoursite.com/2021/05/07/1206.%20%E8%AE%BE%E8%AE%A1%E8%B7%B3%E8%A1%A8/"/>
    <id>http://yoursite.com/2021/05/07/1206. 设计跳表/</id>
    <published>2021-05-07T07:12:12.000Z</published>
    <updated>2021-05-19T12:24:53.918Z</updated>
    
    <content type="html"><![CDATA[<p>不使用任何库函数，设计一个跳表。</p><p>跳表是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p><a id="more"></a><p>例如，一个跳表包含 [30, 40, 50, 60, 70, 90]，然后增加 80、45 到跳表中，以下图的方式操作：</p><p>Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons</p><p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。</p><p>在本题中，你的设计应该要包含这些函数：</p><p>bool search(int target) : 返回target是否存在于跳表中。<br>void add(int num): 插入一个元素到跳表。<br>bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回false. 如果存在多个 num ，删除其中任意一个即可。<br>了解更多 : <a href="https://en.wikipedia.org/wiki/Skip_list" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Skip_list</a></p><p>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</p><p>样例:</p><pre><code>Skiplist skiplist = new Skiplist();skiplist.add(1);skiplist.add(2);skiplist.add(3);skiplist.search(0);   // 返回 falseskiplist.add(4);skiplist.search(1);   // 返回 trueskiplist.erase(0);    // 返回 false，0 不在跳表中skiplist.erase(1);    // 返回 trueskiplist.search(1);   // 返回 false，1 已被擦除</code></pre><p>约束条件:</p><p>0 &lt;= num, target &lt;= 20000</p><p>最多调用 50000 次 search, add, 以及 erase操作。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>跳表实现的主要难度在于插入(add)算法。只要把add方法搞明白之后，一切都迎刃而解了。</p><p>关于跳表的插入，一张图即可描述出来，<br><a href="https://pic.leetcode-cn.com/1612247342-QjALhY-skiplist_insertions.png" target="_blank" rel="noopener">skiplist_insertions.png</a></p><blockquote><p>图片来自 <a href="http://zhangtielei.com/posts/blog-redis-skiplist.html" target="_blank" rel="noopener">http://zhangtielei.com/posts/blog-redis-skiplist.html</a></p></blockquote><p>通过这张图，可以先确定跳表中每个节点的数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    Integer value; <span class="comment">//节点值</span></span><br><span class="line">    Node[] next; <span class="comment">// 节点在不同层的下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer value,<span class="keyword">int</span> size)</span> </span>&#123; <span class="comment">// 用size表示当前节点在跳表中索引几层</span></span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">new</span> Node[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就需要考虑：我插入一个节点Node，它到底应该是索引到第几层呢？</p><p>一开始我还想着如何准确的维护上一层是下一层的1/2，发现越想越复杂；然后通过相关资料，发现人家早就给出一个解决方案：随机出来一个层数。</p><p>这里有一个疑惑：就凭随机出来的一个层数，能保证查询与插入性能吗？</p><blockquote><p>在分析之前，我们还需要着重指出的是，执行插入操作时计算随机数的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：<br>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。<br>如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。<br>节点最大的层数不允许超过一个最大值，记为MaxLevel。<br>这个计算随机层数的伪码如下所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> level </span>= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Math.random()&lt;p &amp;&amp; level&lt;MaxLevel)&#123;</span><br><span class="line">        level ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br></pre></td></tr></table></figure><blockquote><p>randomLevel()的伪码中包含两个参数，一个是p，一个是MaxLevel。在Redis的skiplist实现中，这两个参数的取值为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = 1/4</span><br><span class="line">MaxLevel = 32</span><br></pre></td></tr></table></figure><blockquote><p>from : <a href="http://zhangtielei.com/posts/blog-redis-skiplist.html" target="_blank" rel="noopener">http://zhangtielei.com/posts/blog-redis-skiplist.html</a></p></blockquote><p>知道了层数，这下就好办了。思路如下：</p><ol><li><p>先随机出来一个层数，new要插入的节点，先叫做插入节点newNode；</p></li><li><p>根据跳表实际的总层数从上往下分析，要插入一个节点newNode时，先找到节点在该层的位置：因为是链表，所以需要一个节点node，满足插入插入节点newNode的值刚好不大于node的下一个节点值，当然，如果node的下个节点为空，那么也是满足的。</p></li></ol><p>我们先把找节点在某一层位置的方法封装起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 找到level层 value 刚好不小于node 的节点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node 从哪个节点开始找</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> levelIndex 所在层</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> value 要插入的节点值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">findClosest</span><span class="params">(Node node,<span class="keyword">int</span> levelIndex,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((node.next[levelIndex])!=<span class="keyword">null</span> &amp;&amp; value &gt;node.next[levelIndex].value)&#123;</span><br><span class="line">        node = node.next[levelIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>确定插入节点newNode在该层的位置后，先判断下newNode的随机层数是否小于当前跳表的总层数，如果是，则用链表的插入方法将newNode插入即可。</p></li><li><p>如此循环，直到最底层插入newNode完毕。</p></li><li><p>循环完毕后，还需要判断下newNode随机出来的层数是否比跳表的实际层数还要大，如果是，直接将超过实际层数的跳表的头节点指向newNode即可，该跳表的实际层数也就变为newNode的随机层数了。</p></li></ol><p>以上就是插入的算法。</p><p>理解了插入算法后，查找跟删除就简单多了。</p><p>不管是插入、查找还是删除，均是从跳表上层往下层分析，复用上面的findClosest方法，找到要查询的值 在该层closest的节点。比如查询，只需要判断findClosest出来的节点值是否等于该查询值即可，是就返回，不是则继续往下层判断。删除方法思想也是一致的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Skiplist</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最大层数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_MAX_LEVEL = <span class="number">32</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 随机层数概率，也就是随机出的层数，在 第1层以上(不包括第一层)的概率，层数不超过maxLevel，层数的起始号为1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> DEFAULT_P_FACTOR = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="keyword">null</span>,DEFAULT_MAX_LEVEL); <span class="comment">//头节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> currentLevel = <span class="number">1</span>; <span class="comment">//表示当前nodes的实际层数，它从1开始</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Skiplist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">            Node searchNode = head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = currentLevel-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                searchNode = findClosest(searchNode, i, target);</span><br><span class="line">                <span class="keyword">if</span> (searchNode.next[i]!=<span class="keyword">null</span> &amp;&amp; searchNode.next[i].value == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> level = randomLevel();</span><br><span class="line">            Node updateNode = head;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(num,level);</span><br><span class="line">            <span class="comment">// 计算出当前num 索引的实际层数，从该层开始添加索引</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = currentLevel-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">//找到本层最近离num最近的list</span></span><br><span class="line">                updateNode = findClosest(updateNode,i,num);</span><br><span class="line">                <span class="keyword">if</span> (i&lt;level)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (updateNode.next[i]==<span class="keyword">null</span>)&#123;</span><br><span class="line">                        updateNode.next[i] = newNode;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        Node temp = updateNode.next[i];</span><br><span class="line">                        updateNode.next[i] = newNode;</span><br><span class="line">                        newNode.next[i] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (level &gt; currentLevel)&#123; <span class="comment">//如果随机出来的层数比当前的层数还大，那么超过currentLevel的head 直接指向newNode</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = currentLevel; i &lt; level; i++) &#123;</span><br><span class="line">                    head.next[i] = newNode;</span><br><span class="line">                &#125;</span><br><span class="line">                currentLevel = level;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">            Node searchNode = head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = currentLevel-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                searchNode = findClosest(searchNode, i, num);</span><br><span class="line">                <span class="keyword">if</span> (searchNode.next[i]!=<span class="keyword">null</span> &amp;&amp; searchNode.next[i].value == num)&#123;</span><br><span class="line">                    <span class="comment">//找到该层中该节点</span></span><br><span class="line">                    searchNode.next[i] = searchNode.next[i].next[i];</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 找到level层 value 大于node 的节点</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> levelIndex</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">findClosest</span><span class="params">(Node node,<span class="keyword">int</span> levelIndex,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span> ((node.next[levelIndex])!=<span class="keyword">null</span> &amp;&amp; value &gt;node.next[levelIndex].value)&#123;</span><br><span class="line">                node = node.next[levelIndex];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 随机一个层数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (Math.random()&lt;DEFAULT_P_FACTOR &amp;&amp; level&lt;DEFAULT_MAX_LEVEL)&#123;</span><br><span class="line">                level ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> level;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            Integer value;</span><br><span class="line">            Node[] next;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer value,<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="keyword">this</span>.next = <span class="keyword">new</span> Node[size];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> String.valueOf(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不使用任何库函数，设计一个跳表。&lt;/p&gt;
&lt;p&gt;跳表是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年5月" scheme="http://yoursite.com/categories/2021%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>707. 设计链表</title>
    <link href="http://yoursite.com/2021/04/26/707.%20%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2021/04/26/707. 设计链表/</id>
    <published>2021-04-26T03:12:12.000Z</published>
    <updated>2021-05-06T09:49:49.812Z</updated>
    
    <content type="html"><![CDATA[<p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><a id="more"></a><p>在链表类中实现这些功能：</p><pre><code>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</code></pre><p>示例：</p><pre><code>MyLinkedList linkedList = new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3linkedList.get(1);            //返回2linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3linkedList.get(1);            //返回3</code></pre><p>提示：</p><pre><code>所有val值都在 [1, 1000] 之内。操作次数将在  [1, 1000] 之内。请不要使用内置的 LinkedList 库。</code></pre><h1 id="面试要点"><a href="#面试要点" class="headerlink" title="面试要点"></a>面试要点</h1><p>链表时一个包含零个或多个元素的数据结构。每个元素都包含一个值和到另一个元素的链接。根据链接数的不同，可以分为单链表，双链表和多重链表。</p><p>单链表是最简单的一种，它提供了在常数时间内的 <code>addAtHead</code> 操作和在线性时间内的 <code>addAtTail</code> 的操作。双链表是最常用的一种，因为它提供了在常数时间内的 <code>addAtHead</code> 和 <code>addAtTail</code> 操作，并且优化的插入和删除。</p><p>双链表在 Java 中的实现为 LinkedList，在 Python 中为 list。这些结构都比较常用，有两个要点：</p><ul><li>哨兵节点：</li></ul><p>哨兵节点在树和链表中被广泛用作伪头、伪尾等，通常不保存任何数据。</p><p>我们将使用伪头来简化我们简化插入和删除。在接下来的两种方法中应用此方法。</p><ul><li>双链表的双向搜索：我们可以从头部或尾部进行搜索。</li></ul><h1 id="方法一：单链表"><a href="#方法一：单链表" class="headerlink" title="方法一：单链表"></a>方法一：单链表</h1><p>让我们从最简单的链表开始。</p><details>    <summary>单链表</summary><figure class="highlight python"><figcaption><span>[init1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.head = ListNode(<span class="number">0</span>)  <span class="comment"># sentinel node as pseudo-head</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[init1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  ListNode head;  <span class="comment">// sentinel node as pseudo-head</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>哨兵节点被用作伪头始终存在，这样结构中永远不为空，它将至少包含一个伪头。MyLinkedList 中所有节点均包含：值 + 链接到下一个元素的指针。</p><details>    <summary>单链表</summary><figure class="highlight python"><figcaption><span>[ListNode1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[ListNode1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><code>addAtIndex</code>，<code>addAtHead</code> 和 <code>addAtTail</code>：<br>我们首先讨论 <code>addAtIndex</code>，因为伪头的关系 <code>addAtHead</code> 和 <code>addAtTail</code> 可以使用 <code>addAtIndex</code> 来完成。</p><p>这个想法很简单：</p><ul><li>找到要插入位置节点的前驱节点。如果要在头部插入，则它的前驱节点就是伪头。如果要在尾部插入节点，则前驱节点就是尾节点。</li><li>通过改变 <code>next</code> 来插入节点。<details>  <summary>单链表</summary></details></li></ul><figure class="highlight python"><figcaption><span>[add1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">to_add.next = pred.next</span><br><span class="line">pred.next = to_add</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[add1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toAdd.next = pred.next;</span><br><span class="line">pred.next = toAdd;</span><br></pre></td></tr></table></figure><p><code>deleteAtIndex</code>：<br>和插入同样的道理。</p><ul><li>找到要删除节点的前驱节点。</li><li>通过改变 <code>next</code> 来删除节点。</li></ul><details>    <summary>单链表</summary><figure class="highlight python"><figcaption><span>[delete2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delete pred.next </span></span><br><span class="line">pred.next = pred.next.next</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[delete2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delete pred.next </span></span><br><span class="line">pred.next = pred.next.next;</span><br></pre></td></tr></table></figure></details><p><code>get</code>：<br>从伪头节点开始，向前走 <code>index+1</code> 步。</p><details>    <summary>单链表</summary><figure class="highlight python"><figcaption><span>[get1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># index steps needed </span></span><br><span class="line"><span class="comment"># to move from sentinel node to wanted index</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(index + <span class="number">1</span>):</span><br><span class="line">    curr = curr.next</span><br><span class="line"><span class="keyword">return</span> curr.val</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[get1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index steps needed </span></span><br><span class="line"><span class="comment">// to move from sentinel node to wanted index</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; ++i) curr = curr.next;</span><br><span class="line"><span class="keyword">return</span> curr.val;</span><br></pre></td></tr></table></figure></details><p><strong>全部代码：</strong></p><details>    <summary>单链表Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.head = ListNode(<span class="number">0</span>)  <span class="comment"># sentinel node as pseudo-head</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># if index is invalid</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        curr = self.head</span><br><span class="line">        <span class="comment"># index steps needed </span></span><br><span class="line">        <span class="comment"># to move from sentinel node to wanted index</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(index + <span class="number">1</span>):</span><br><span class="line">            curr = curr.next</span><br><span class="line">        <span class="keyword">return</span> curr.val</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.addAtIndex(<span class="number">0</span>, val)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.addAtIndex(self.size, val)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span><span class="params">(self, index: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># If index is greater than the length, </span></span><br><span class="line">        <span class="comment"># the node will not be inserted.</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># [so weird] If index is negative, </span></span><br><span class="line">        <span class="comment"># the node will be inserted at the head of the list.</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        <span class="comment"># find predecessor of the node to be added</span></span><br><span class="line">        pred = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(index):</span><br><span class="line">            pred = pred.next</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># node to be added</span></span><br><span class="line">        to_add = ListNode(val)</span><br><span class="line">        <span class="comment"># insertion itself</span></span><br><span class="line">        to_add.next = pred.next</span><br><span class="line">        pred.next = to_add</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span><span class="params">(self, index: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># if the index is invalid, do nothing</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># find predecessor of the node to be deleted</span></span><br><span class="line">        pred = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(index):</span><br><span class="line">            pred = pred.next</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># delete pred.next </span></span><br><span class="line">        pred.next = pred.next.next</span><br></pre></td></tr></table></figure></details><details>    <summary>单链表Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  ListNode head;  <span class="comment">// sentinel node as pseudo-head</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if index is invalid</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="comment">// index steps needed </span></span><br><span class="line">    <span class="comment">// to move from sentinel node to wanted index</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; ++i) curr = curr.next;</span><br><span class="line">    <span class="keyword">return</span> curr.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    addAtIndex(size, val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If index is greater than the length, </span></span><br><span class="line">    <span class="comment">// the node will not be inserted.</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [so weird] If index is negative, </span></span><br><span class="line">    <span class="comment">// the node will be inserted at the head of the list.</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ++size;</span><br><span class="line">    <span class="comment">// find predecessor of the node to be added</span></span><br><span class="line">    ListNode pred = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) pred = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// node to be added</span></span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    <span class="comment">// insertion itself</span></span><br><span class="line">    toAdd.next = pred.next;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if the index is invalid, do nothing</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// find predecessor of the node to be deleted</span></span><br><span class="line">    ListNode pred = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) pred = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete pred.next </span></span><br><span class="line">    pred.next = pred.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>空间复杂度：所有的操作都是 <em>O(1)</em>。</li></ul><h1 id="方法二：双链表"><a href="#方法二：双链表" class="headerlink" title="方法二：双链表"></a>方法二：双链表</h1><p>双链表比单链表快得多，测试用例花费的时间比单链表快了两倍。但是它更加复杂，它包含了 <code>size</code>，记录链表元素个数，和伪头伪尾。</p><details>    <summary>双链表</summary><figure class="highlight python"><figcaption><span>[init2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        <span class="comment"># sentinel nodes as pseudo-head and pseudo-tail</span></span><br><span class="line">        self.head, self.tail = ListNode(<span class="number">0</span>), ListNode(<span class="number">0</span>) </span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[init2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">// sentinel nodes as pseudo-head and pseudo-tail</span></span><br><span class="line">  ListNode head, tail;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    tail = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>伪头和伪尾总是存在，MyLinkedList 中所有节点都包含：值 + 指向前一个节点的指针 + 指向后一个节点的指针。</p><details>    <summary>双链表</summary><figure class="highlight python"><figcaption><span>[ListNode2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line">        self.prev = <span class="keyword">None</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[ListNode2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;</span><br><span class="line">  ListNode prev;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><code>addAtIndex</code>，<code>addAtHead</code> 和 <code>addAtTail</code>：</p><ul><li>找到要插入节点的前驱节点和后继节点。如果要在头部插入节点，则它的前驱结点是伪头。如果要在尾部插入节点，则它的后继节点是伪尾。</li><li>通过改变前驱结点和后继节点的链接关系添加元素。</li></ul><details>    <summary>双链表</summary><figure class="highlight python"><figcaption><span>[add2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">to_add.prev = pred</span><br><span class="line">to_add.next = succ</span><br><span class="line">pred.next = to_add</span><br><span class="line">succ.prev = to_add</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[add2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">toAdd.prev = pred</span><br><span class="line">toAdd.next = succ</span><br><span class="line">pred.next = toAdd</span><br><span class="line">succ.prev = toAdd</span><br></pre></td></tr></table></figure></details><p><code>deleteAtIndex</code>：<br>和插入同样的道理。</p><ul><li>找到要删除节点的前驱结点和后继节点。</li><li>通过改变前驱结点和后继节点的链接关系删除元素。</li></ul><details>    <summary>双链表</summary><figure class="highlight python"><figcaption><span>[delete2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pred.next = succ</span><br><span class="line">succ.prev = pred</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[delete2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pred.next = succ</span><br><span class="line">succ.prev = pred</span><br></pre></td></tr></table></figure></details><p><code>get</code>：</p><ul><li>通过比较 <code>index</code> 和 <code>size - index</code> 的大小判断从头开始较快还是从尾巴开始较快。</li><li>从较快的方向开始。 </li></ul><details>    <summary>双链表Python</summary><figure class="highlight python"><figcaption><span>[get2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># choose the fastest way: to move from the head</span></span><br><span class="line"><span class="comment"># or to move from the tail</span></span><br><span class="line"><span class="keyword">if</span> index + <span class="number">1</span> &lt; self.size - index:</span><br><span class="line">    curr = self.head</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(index + <span class="number">1</span>):</span><br><span class="line">        curr = curr.next</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    curr = self.tail</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.size - index):</span><br><span class="line">        curr = curr.prev</span><br></pre></td></tr></table></figure></details><details>    <summary>双链表Java</summary><figure class="highlight java"><figcaption><span>[get2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// choose the fastest way: to move from the head</span></span><br><span class="line"><span class="comment">// or to move from the tail</span></span><br><span class="line">ListNode curr = head;</span><br><span class="line"><span class="keyword">if</span> (index + <span class="number">1</span> &lt; size - index)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; ++i) curr = curr.next;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  curr = tail;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; ++i) curr = curr.prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>全部代码：</strong></p><details>    <summary>双链表Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next, self.prev = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        <span class="comment"># sentinel nodes as pseudo-head and pseudo-tail</span></span><br><span class="line">        self.head, self.tail = ListNode(<span class="number">0</span>), ListNode(<span class="number">0</span>) </span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># if index is invalid</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># choose the fastest way: to move from the head</span></span><br><span class="line">        <span class="comment"># or to move from the tail</span></span><br><span class="line">        <span class="keyword">if</span> index + <span class="number">1</span> &lt; self.size - index:</span><br><span class="line">            curr = self.head</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(index + <span class="number">1</span>):</span><br><span class="line">                curr = curr.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            curr = self.tail</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.size - index):</span><br><span class="line">                curr = curr.prev</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> curr.val</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pred, succ = self.head, self.head.next</span><br><span class="line">        </span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        to_add = ListNode(val)</span><br><span class="line">        to_add.prev = pred</span><br><span class="line">        to_add.next = succ</span><br><span class="line">        pred.next = to_add</span><br><span class="line">        succ.prev = to_add</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        succ, pred = self.tail, self.tail.prev</span><br><span class="line">        </span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        to_add = ListNode(val)</span><br><span class="line">        to_add.prev = pred</span><br><span class="line">        to_add.next = succ</span><br><span class="line">        pred.next = to_add</span><br><span class="line">        succ.prev = to_add</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span><span class="params">(self, index: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># If index is greater than the length, </span></span><br><span class="line">        <span class="comment"># the node will not be inserted.</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># [so weird] If index is negative, </span></span><br><span class="line">        <span class="comment"># the node will be inserted at the head of the list.</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># find predecessor and successor of the node to be added</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; self.size - index:</span><br><span class="line">            pred = self.head</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(index):</span><br><span class="line">                pred = pred.next</span><br><span class="line">            succ = pred.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            succ = self.tail</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.size - index):</span><br><span class="line">                succ = succ.prev</span><br><span class="line">            pred = succ.prev</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># insertion itself</span></span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        to_add = ListNode(val)</span><br><span class="line">        to_add.prev = pred</span><br><span class="line">        to_add.next = succ</span><br><span class="line">        pred.next = to_add</span><br><span class="line">        succ.prev = to_add</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span><span class="params">(self, index: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># if the index is invalid, do nothing</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># find predecessor and successor of the node to be deleted</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; self.size - index:</span><br><span class="line">            pred = self.head</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(index):</span><br><span class="line">                pred = pred.next</span><br><span class="line">            succ = pred.next.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            succ = self.tail</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.size - index - <span class="number">1</span>):</span><br><span class="line">                succ = succ.prev</span><br><span class="line">            pred = succ.prev.prev</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># delete pred.next </span></span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        pred.next = succ</span><br><span class="line">        succ.prev = pred</span><br></pre></td></tr></table></figure></details><details>    <summary>双链表Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;</span><br><span class="line">  ListNode prev;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">// sentinel nodes as pseudo-head and pseudo-tail</span></span><br><span class="line">  ListNode head, tail;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    tail = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if index is invalid</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// choose the fastest way: to move from the head</span></span><br><span class="line">    <span class="comment">// or to move from the tail</span></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">if</span> (index + <span class="number">1</span> &lt; size - index)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; ++i) curr = curr.next;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      curr = tail;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; ++i) curr = curr.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curr.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode pred = head, succ = head.next;</span><br><span class="line"></span><br><span class="line">    ++size;</span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    toAdd.prev = pred;</span><br><span class="line">    toAdd.next = succ;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">    succ.prev = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode succ = tail, pred = tail.prev;</span><br><span class="line"></span><br><span class="line">    ++size;</span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    toAdd.prev = pred;</span><br><span class="line">    toAdd.next = succ;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">    succ.prev = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If index is greater than the length, </span></span><br><span class="line">    <span class="comment">// the node will not be inserted.</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [so weird] If index is negative, </span></span><br><span class="line">    <span class="comment">// the node will be inserted at the head of the list.</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find predecessor and successor of the node to be added</span></span><br><span class="line">    ListNode pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; size - index) &#123;</span><br><span class="line">      pred = head;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) pred = pred.next;</span><br><span class="line">      succ = pred.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      succ = tail;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; ++i) succ = succ.prev;</span><br><span class="line">      pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insertion itself</span></span><br><span class="line">    ++size;</span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    toAdd.prev = pred;</span><br><span class="line">    toAdd.next = succ;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">    succ.prev = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if the index is invalid, do nothing</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find predecessor and successor of the node to be deleted</span></span><br><span class="line">    ListNode pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; size - index) &#123;</span><br><span class="line">      pred = head;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) pred = pred.next;</span><br><span class="line">      succ = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      succ = tail;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index - <span class="number">1</span>; ++i) succ = succ.prev;</span><br><span class="line">      pred = succ.prev.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete pred.next </span></span><br><span class="line">    --size;</span><br><span class="line">    pred.next = succ;</span><br><span class="line">    succ.prev = pred;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年4月" scheme="http://yoursite.com/categories/2021%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>706. 设计哈希映射</title>
    <link href="http://yoursite.com/2021/04/09/706.%20%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84/"/>
    <id>http://yoursite.com/2021/04/09/706. 设计哈希映射/</id>
    <published>2021-04-09T10:12:12.000Z</published>
    <updated>2021-04-10T16:53:00.872Z</updated>
    
    <content type="html"><![CDATA[<p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p><a id="more"></a><p>实现 MyHashMap 类：</p><p>MyHashMap() 用空映射初始化对象<br>void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。<br>int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。<br>void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。</p><p>示例：</p><p>输入：</p><pre><code>[&quot;MyHashMap&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;remove&quot;, &quot;get&quot;][[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]</code></pre><p>输出：</p><pre><code>[null, null, null, 1, -1, null, 1, null, -1]</code></pre><p>解释：</p><pre><code>MyHashMap myHashMap = new MyHashMap();myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]myHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]myHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）myHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]myHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]</code></pre><p>提示：</p><pre><code>0 &lt;= key, value &lt;= 106最多调用 104 次 put、get 和 remove 方法</code></pre><p>进阶：你能否不使用内置的 HashMap 库解决此问题？</p><h1 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h1><p>我们假定读者已经完成了「<a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a>」这一题目。</p><p>「设计哈希映射」与「设计哈希集合」解法接近，唯一的区别在于我们存储的不是 key本身，而是 key,value 对。除此之外，代码基本是类似的。</p><details>    <summary>链地址法C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; data;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">769</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % base;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashMap(): data(base) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** value will always be non-negative. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                (*it).second = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].push_back(make_pair(key, value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> (*it).second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                data[h].erase(it);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>链地址法Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE = <span class="number">769</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList[] data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> LinkedList[BASE];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; ++i) &#123;</span><br><span class="line">            data[i] = <span class="keyword">new</span> LinkedList&lt;Pair&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** value will always be non-negative. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Pair&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Pair pair = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (pair.getKey() == key) &#123;</span><br><span class="line">                pair.setValue(value);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].offerLast(<span class="keyword">new</span> Pair(key, value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Pair&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Pair pair = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (pair.getKey() == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> pair.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Pair&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Pair pair = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (pair.key == key) &#123;</span><br><span class="line">                data[h].remove(pair);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % BASE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>链地址法Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base = <span class="number">769</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    key, value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyHashMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    data []list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyHashMap</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MyHashMap&#123;<span class="built_in">make</span>([]list.List, base)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyHashMap)</span> <span class="title">hash</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyHashMap)</span> <span class="title">Put</span><span class="params">(key, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    h := m.hash(key)</span><br><span class="line">    <span class="keyword">for</span> e := m.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> et := e.Value.(entry); et.key == key &#123;</span><br><span class="line">            e.Value = entry&#123;key, value&#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m.data[h].PushBack(entry&#123;key, value&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyHashMap)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    h := m.hash(key)</span><br><span class="line">    <span class="keyword">for</span> e := m.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> et := e.Value.(entry); et.key == key &#123;</span><br><span class="line">            <span class="keyword">return</span> et.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyHashMap)</span> <span class="title">Remove</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    h := m.hash(key)</span><br><span class="line">    <span class="keyword">for</span> e := m.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> e.Value.(entry).key == key &#123;</span><br><span class="line">            m.data[h].Remove(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>链地址法JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyHashMap = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.BASE = <span class="number">769</span>;</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.BASE).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHashMap.prototype.put = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> it <span class="keyword">of</span> <span class="keyword">this</span>.data[h]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it[<span class="number">0</span>] === key) &#123;</span><br><span class="line">            it[<span class="number">1</span>] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.data[h].push([key, value]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHashMap.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> it <span class="keyword">of</span> <span class="keyword">this</span>.data[h]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it[<span class="number">0</span>] === key) &#123;</span><br><span class="line">            <span class="keyword">return</span> it[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHashMap.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> it <span class="keyword">of</span> <span class="keyword">this</span>.data[h]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it[<span class="number">0</span>] === key) &#123;</span><br><span class="line">            <span class="keyword">const</span> idx = <span class="keyword">this</span>.data[h].indexOf(it);</span><br><span class="line">            <span class="keyword">this</span>.data[h].splice(idx, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHashMap.prototype.hash = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % <span class="keyword">this</span>.BASE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>链地址法C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listPush</span><span class="params">(struct List* head, <span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">List</span>));</span></span><br><span class="line">    tmp-&gt;key = key;</span><br><span class="line">    tmp-&gt;val = val;</span><br><span class="line">    tmp-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelete</span><span class="params">(struct List* head, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (struct List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;key == key) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> = <span class="title">it</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">            it-&gt;next = tmp-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct List* <span class="title">listFind</span><span class="params">(struct List* head, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (struct List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listFree</span><span class="params">(struct List* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        head-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">769</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">data</span>;</span></span><br><span class="line">&#125; MyHashMap;</span><br><span class="line"></span><br><span class="line"><span class="function">MyHashMap* <span class="title">myHashMapCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyHashMap* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyHashMap));</span><br><span class="line">    ret-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct List) * base);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        ret-&gt;data[i].key = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].val = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myHashMapPut</span><span class="params">(MyHashMap* obj, <span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">rec</span> = <span class="title">listFind</span>(&amp;(<span class="title">obj</span>-&gt;<span class="title">data</span>[<span class="title">h</span>]), <span class="title">key</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (rec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        listPush(&amp;(obj-&gt;data[h]), key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rec-&gt;val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myHashMapGet</span><span class="params">(MyHashMap* obj, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">rec</span> = <span class="title">listFind</span>(&amp;(<span class="title">obj</span>-&gt;<span class="title">data</span>[<span class="title">h</span>]), <span class="title">key</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (rec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rec-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myHashMapRemove</span><span class="params">(MyHashMap* obj, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    listDelete(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myHashMapFree</span><span class="params">(MyHashMap* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        listFree(&amp;(obj-&gt;data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li>空间复杂度：<em>O(n+b)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不使用任何内建的哈希表库设计一个哈希映射（HashMap）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年4月" scheme="http://yoursite.com/categories/2021%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>705. 设计哈希集合</title>
    <link href="http://yoursite.com/2021/04/09/705.%20%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2021/04/09/705. 设计哈希集合/</id>
    <published>2021-04-09T10:10:12.000Z</published>
    <updated>2021-04-10T16:53:07.037Z</updated>
    
    <content type="html"><![CDATA[<p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p><a id="more"></a><p>实现 MyHashSet 类：</p><p>void add(key) 向哈希集合中插入值 key 。<br>bool contains(key) 返回哈希集合中是否存在这个值 key 。<br>void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</p><p>示例：</p><p>输入：</p><pre><code>[&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;][[], [1], [2], [1], [3], [2], [2], [2], [2]]</code></pre><p>输出：</p><pre><code>[null, null, null, true, false, null, true, null, false]</code></pre><p>解释：</p><pre><code>MyHashSet myHashSet = new MyHashSet();myHashSet.add(1);      // set = [1]myHashSet.add(2);      // set = [1, 2]myHashSet.contains(1); // 返回 TruemyHashSet.contains(3); // 返回 False ，（未找到）myHashSet.add(2);      // set = [1, 2]myHashSet.contains(2); // 返回 TruemyHashSet.remove(2);   // set = [1]myHashSet.contains(2); // 返回 False ，（已移除）</code></pre><p>提示：</p><pre><code>0 &lt;= key &lt;= 106最多调用 104 次 add、remove 和 contains 。</code></pre><p>进阶：你可以不使用内建的哈希集合库解决此问题吗？</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>为了实现哈希集合这一数据结构，有以下几个关键问题需要解决：</p><ul><li>哈希函数：能够将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上。</li><li>冲突处理：由于不同元素可能映射到相同的整数值，因此需要在整数值出现「冲突」时，需要进行冲突处理。总的来说，有以下几种策略解决冲突：<ul><li>链地址法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。</li><li>开放地址法：当发现哈希值 <em>h</em> 处产生冲突时，根据某种策略，从 <em>h</em> 出发找到下一个不冲突的位置。例如，一种最简单的策略是，不断地检查 h+1,h+2,h+3… 这些整数对应的位置。</li><li>再哈希法：当发现哈希冲突后，使用另一个哈希函数产生一个新的地址。</li></ul></li><li>扩容：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。</li></ul><p>以上内容读者可以自行翻阅数据结构的教材，本题解不再阐述，而是直接给出一个最简单的哈希表实现。</p><h1 id="方法一：链地址法"><a href="#方法一：链地址法" class="headerlink" title="方法一：链地址法"></a>方法一：链地址法</h1><p>设哈希表的大小为 base ，则可以设计一个简单的哈希函数：hash(x)=x%base。</p><p>我们开辟一个大小为 base 的数组，数组的每个位置是一个链表。当计算出哈希值之后，就插入到对应位置的链表当中。</p><p>由于我们使用整数除法作为哈希函数，为了尽可能避免冲突，应当将 base  取为一个质数。在这里，我们取 base=769。</p><p><strong>代码</strong></p><details>    <summary>链地址法C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; data;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">769</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % base;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashSet(): data(base) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].push_back(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                data[h].erase(it);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>链地址法Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE = <span class="number">769</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList[] data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> LinkedList[BASE];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; ++i) &#123;</span><br><span class="line">            data[i] = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer element = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (element == key) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].offerLast(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer element = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (element == key) &#123;</span><br><span class="line">                data[h].remove(element);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer element = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (element == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % BASE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>链地址法JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyHashSet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.BASE = <span class="number">769</span>;</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.BASE).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHashSet.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> <span class="keyword">this</span>.data[h]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element === key) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.data[h].push(key);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHashSet.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">const</span> it = <span class="keyword">this</span>.data[h];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; it.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it[i] === key) &#123;</span><br><span class="line">            it.splice(i, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHashSet.prototype.contains = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> <span class="keyword">this</span>.data[h]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element === key) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHashSet.prototype.hash = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % <span class="keyword">this</span>.BASE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>链地址法Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base = <span class="number">769</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyHashSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    data []list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyHashSet</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MyHashSet&#123;<span class="built_in">make</span>([]list.List, base)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyHashSet)</span> <span class="title">hash</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyHashSet)</span> <span class="title">Add</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !s.Contains(key) &#123;</span><br><span class="line">        h := s.hash(key)</span><br><span class="line">        s.data[h].PushBack(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyHashSet)</span> <span class="title">Remove</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    h := s.hash(key)</span><br><span class="line">    <span class="keyword">for</span> e := s.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> e.Value.(<span class="keyword">int</span>) == key &#123;</span><br><span class="line">            s.data[h].Remove(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyHashSet)</span> <span class="title">Contains</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    h := s.hash(key)</span><br><span class="line">    <span class="keyword">for</span> e := s.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> e.Value.(<span class="keyword">int</span>) == key &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>链地址法C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listPush</span><span class="params">(struct List* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">List</span>));</span></span><br><span class="line">    tmp-&gt;val = x;</span><br><span class="line">    tmp-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelete</span><span class="params">(struct List* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (struct List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;val == x) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> = <span class="title">it</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">            it-&gt;next = tmp-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">listContains</span><span class="params">(struct List* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (struct List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;val == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listFree</span><span class="params">(struct List* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        head-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">769</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">data</span>;</span></span><br><span class="line">&#125; MyHashSet;</span><br><span class="line"></span><br><span class="line"><span class="function">MyHashSet* <span class="title">myHashSetCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyHashSet* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyHashSet));</span><br><span class="line">    ret-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct List) * base);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        ret-&gt;data[i].val = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myHashSetAdd</span><span class="params">(MyHashSet* obj, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">if</span> (!listContains(&amp;(obj-&gt;data[h]), key)) &#123;</span><br><span class="line">        listPush(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myHashSetRemove</span><span class="params">(MyHashSet* obj, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    listDelete(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myHashSetContains</span><span class="params">(MyHashSet* obj, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">return</span> listContains(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myHashSetFree</span><span class="params">(MyHashSet* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        listFree(&amp;(obj-&gt;data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不使用任何内建的哈希表库设计一个哈希集合（HashSet）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年4月" scheme="http://yoursite.com/categories/2021%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>LCP 29. 乐团站位</title>
    <link href="http://yoursite.com/2021/04/07/LCP%2029.%20%E4%B9%90%E5%9B%A2%E7%AB%99%E4%BD%8D/"/>
    <id>http://yoursite.com/2021/04/07/LCP 29. 乐团站位/</id>
    <published>2021-04-07T02:00:12.000Z</published>
    <updated>2021-04-10T16:53:13.832Z</updated>
    
    <content type="html"><![CDATA[<p>某乐团的演出场地可视作 num * num 的二维矩阵 grid（左上角坐标为 [0,0])，每个位置站有一位成员。乐团共有 9 种乐器，乐器编号为 1~9，每位成员持有 1 个乐器。</p><p>为保证声乐混合效果，成员站位规则为：自 grid 左上角开始顺时针螺旋形向内循环以 1，2，…，9 循环重复排列。</p><a id="more"></a><p>请返回位于场地坐标 [Xpos,Ypos] 的成员所持乐器编号。</p><p>示例 1：</p><p>输入：num = 3, Xpos = 0, Ypos = 2</p><p>输出：3</p><p>解释：</p><pre><code>1 2 38 9 47 6 5</code></pre><p>示例 2：</p><p>输入：num = 4, Xpos = 1, Ypos = 2</p><p>输出：5</p><p>解释：</p><pre><code>1 2 3 43 4 5 52 7 6 61 9 8 7</code></pre><p>提示：</p><p>1 &lt;= num &lt;= 10^9</p><p>0 &lt;= Xpos, Ypos &lt; num</p><h1 id="题解-1"><a href="#题解-1" class="headerlink" title="题解^1"></a>题解<a href="https://leetcode-cn.com/problems/SNJvJP/solution/shu-xue-yi-ge-gong-shi-ji-ke-by-ivon_shi-mo6a/" target="_blank" rel="noopener">^1</a></h1><p>1.获取所求点在第几层（此处根据所求点的位置，层数k可能会多算一层）</p><p>2.第<code>0，1...k</code>层的数量 与 所求点相对第k层左上角元素的位置做<code>+</code>或<code>-</code>运算，求得所求点的绝对次序（从起始点到所求点经过的长度）</p><p>记：<code>k(0,1,2...n/2</code>(往上取整))<br><code>C(K)</code>=第k层的方块数目,如图<code>C(0)=16,C(1)=8,C(2)=1</code>;<br><code>T(K)</code>=第k层及以外的方块 数目，如图<code>T(0)=16,T(1)=16+8=24,T(2)=16+8+1=25;</code><br>但是具体怎么计算呢 可以用补集的思想<br><code>T(K)=n*n-(n-2k)*(n-2k)=4*k*(n-k)</code></p><p>但是怎么求<code>(i,j)</code>点所在层 已经遍历过的数目呢 。<br>1.求所在的层数<code>k</code><br><code>k=min(x,n-1-x,y,n-1-y)</code>(后续由于要分类讨论，k的求取可以直接通过其中某两个值求最小值即可); 即看该点距离哪个边界更近，所求的最小值就是第几层，如图 <code>k=min(2,2,3,1)</code>,即处于第一层。那么我们也就知道了该层以外的橙色数目<code>T(k)</code>。<br>2.求所求点<code>(x,y)</code>相对该层左上角点的相对路径长度</p><p>2.1 对于<code>x&lt;=y</code>，我们可以知道<code>dl=(x-k)+(y-k)+1</code><br>故 绝对路径长度为 <code>T(k)+dl</code></p><p>2.2 但是对于<code>x&gt;y</code>呢，如果我们采用相同的方法，就会导致对称的两个<code>(i,j)</code>与<code>(j,i)</code>相对路径相同。故才用另外一种方法</p><p>在计算层数k的时候 多计算一层，再从下一层的入口处回退dl个路径<br>此时绝对路径长度为 <code>T(k+1)-dl</code> ,注意dl计算时，仍用其真正所处的层数k-1来计算。即：<code>dl=(x-(k-1))+(y-(k-1))+1</code></p><p>(至于为何此处可直接-dl，可以看下图，下一层的入口点与上一层的入口点是右下和左上关系，按照螺旋顺序到<code>(i,j)</code>点的路径长度是相同的。)</p><p>最后， 就是把相应的路径长度<code>len</code>转化为<code>1-9</code>的数字即可，<code>index=(len-1)%9+1</code>。</p><details>    <summary>C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int orchestraLayout(int num, int xPos, int yPos) &#123;</span><br><span class="line">        long long x=xPos,y=yPos,n=num;</span><br><span class="line">        if  (x &lt;= y) &#123;</span><br><span class="line">            long long  k= min(x, n-1-y);</span><br><span class="line">            return  (4*k*(n-k)+1+(x+y-k*2)-1)%9+1;</span><br><span class="line">        &#125;</span><br><span class="line">        long long  k =min(y, n-1-x)+1 ; </span><br><span class="line">        return   (4*k*(n-k)+ 1-(x+y-(k-1)*2 )-1)%9+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>Java这里就是直接定成k是从1开始计数的。x和y是从0开始计数的。</p><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int orchestraLayout(int num, int xPos, int yPos) &#123;</span><br><span class="line">        //根据x，y计算k</span><br><span class="line">        int k = Math.min(Math.min(xPos,yPos),Math.min(num-xPos-1,num-yPos-1)) + 1; //1,2,3</span><br><span class="line">        long total_distance = 0;</span><br><span class="line">        long distance = 0;</span><br><span class="line">        if(xPos&lt;=yPos)&#123;</span><br><span class="line">            distance = (xPos-(k-1))+(yPos-(k-1))+1; //1,2...</span><br><span class="line">            total_distance  = T(num,k-1)+distance;</span><br><span class="line">            return total_distance%9==0?9:(int)(total_distance%9);</span><br><span class="line">        &#125;</span><br><span class="line">        //当前层的个数减去0，1，2等</span><br><span class="line">        distance = T(num,k) - T(num,k-1) - (Math.abs(xPos-k)+Math.abs(yPos-(k-1))) ;</span><br><span class="line">        total_distance = T(num,k-1)+distance;</span><br><span class="line">        return total_distance%9==0?9:(int)(total_distance%9);</span><br><span class="line">    &#125;</span><br><span class="line">    public long T(long n,long k)&#123; //k=1,2,3</span><br><span class="line">        if(k&lt;=0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return 4*k*(n-k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某乐团的演出场地可视作 num * num 的二维矩阵 grid（左上角坐标为 [0,0])，每个位置站有一位成员。乐团共有 9 种乐器，乐器编号为 1~9，每位成员持有 1 个乐器。&lt;/p&gt;
&lt;p&gt;为保证声乐混合效果，成员站位规则为：自 grid 左上角开始顺时针螺旋形向内循环以 1，2，…，9 循环重复排列。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年4月" scheme="http://yoursite.com/categories/2021%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LCP 28. 采购方案</title>
    <link href="http://yoursite.com/2021/04/05/LCP%2028.%20%E9%87%87%E8%B4%AD%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2021/04/05/LCP 28. 采购方案/</id>
    <published>2021-04-05T07:00:12.000Z</published>
    <updated>2021-04-10T16:52:53.992Z</updated>
    
    <content type="html"><![CDATA[<p>小力将 N 个零件的报价存于数组 nums。小力预算为 target，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。</p><p>注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1</p><a id="more"></a><p>示例 1：</p><pre><code>输入：nums = [2,5,3,5], target = 6输出：1解释：预算内仅能购买 nums[0] 与 nums[2]。</code></pre><p>示例 2：</p><pre><code>输入：nums = [2,2,1,9], target = 10输出：4解释：符合预算的采购方案如下：nums[0] + nums[1] = 4nums[0] + nums[2] = 3nums[1] + nums[2] = 3nums[2] + nums[3] = 10</code></pre><p>提示：</p><pre><code>2 &lt;= nums.length &lt;= 10^51 &lt;= nums[i], target &lt;= 10^5</code></pre><p>这道题是leetcode周赛的题目，一开始用双循环或TreeMap存储的办法来做都是超时。<br>先，为了便于计算，我们先对 numsnums 做升序排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums：[<span class="number">2</span>，<span class="number">2</span>，<span class="number">1</span>，<span class="number">9</span>]     target: <span class="number">10</span></span><br></pre></td></tr></table></figure><p>首先，获取两个数，求和之后再和某个数做比较，这个题其实和 <a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/solution/shuang-zhi-zhen-he-wei-sde-liang-ge-shu-wy7r4/" target="_blank" rel="noopener">剑指 Offer 57. 和为s的两个数字</a> 极为相似，不知道的小伙伴可以先行看看这道题熟悉一下思路。</p><p>首先，为了便于计算，我们先对 <em>nums</em> 做升序排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums：[<span class="number">1</span>，<span class="number">2</span>，<span class="number">2</span>，<span class="number">9</span>]     target: <span class="number">10</span></span><br></pre></td></tr></table></figure><p>然后，创建一个指针 <em>i</em> 指针指向 <em>nums</em> 首位，再创建一个指针 <em>j</em> 指向 <em>nums</em> 末位，然后通过遍历，找到符合 <em>nums[i] + nums[j] &lt;= target</em> 条件的 <em>i</em>，<em>j</em> 区间范围。</p><p>既然该范围的边界值之和都满足了条件，那么代表该区间内的所有数字和 <em>nums[i]</em> 相加都满足条件，所以，我们可以通过 <em>j - i</em> 来获取到当前有多少个数，可以和 <em>nums[i]</em> 相加后满足条件！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">i：<span class="number">0</span>    j：<span class="number">3</span>    nums[<span class="number">0</span>] + nums[<span class="number">3</span>] = <span class="number">10</span>，满足条件 &lt;= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">所以，当 i = <span class="number">0</span> 时，存在 j - i = <span class="number">3</span> 种方案，即：[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">然后 i 指针右移一位，如下所示：</span><br><span class="line"></span><br><span class="line">i：<span class="number">1</span>    j：<span class="number">3</span>    nums[<span class="number">1</span>] + nums[<span class="number">3</span>] = <span class="number">11</span>，不满足条件 &lt;= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">所以 j 指针左移一位，如下所示：</span><br><span class="line"></span><br><span class="line">i：<span class="number">1</span>    j：<span class="number">2</span>    nums[<span class="number">1</span>] + nums[<span class="number">2</span>] = <span class="number">4</span>，满足条件 &lt;= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">所以，当 i = <span class="number">1</span> 时，存在 j - i = <span class="number">1</span> 种方案，即：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">最后，满足条件的方案总共就是 [<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>] 这 <span class="number">4</span> 种方案！</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><details>    <summary>Javascript</summary><figure class="highlight javascript"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> purchasePlans = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] + nums[j] &gt; target) j--;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += j - i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % <span class="number">1000000007</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">purchasePlans</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1_000_000_007</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] + nums[right] &gt; target) right--;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += right - left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">purchasePlans</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;j;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;i&amp;&amp;nums[i]+nums[j]&gt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            res += j-i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a,<span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">purchasePlans</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    qsort(nums,numsSize,<span class="keyword">sizeof</span>(<span class="keyword">int</span>),comp);</span><br><span class="line">    <span class="keyword">unsigned</span> left = <span class="number">0</span>,right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">if</span>((nums[left] + nums[right]) &gt; target)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum += right - left;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum%(<span class="number">1000000007</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">purchasePlans</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line">j := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> ; j &gt; i; j-- &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i]+nums[j] &lt;= target &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j &gt; i &#123;</span><br><span class="line">ans = ans + (j - i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans % <span class="number">1000000007</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight plain"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def purchasePlans(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = 0</span><br><span class="line">        i = 0</span><br><span class="line">        j = len(nums)-1</span><br><span class="line">        while i &lt; j:</span><br><span class="line">            if nums[i] + nums[j] &gt; target:</span><br><span class="line">                j -= 1</span><br><span class="line">            else:</span><br><span class="line">                ans += (j-i)</span><br><span class="line">                i += 1</span><br><span class="line">        if ans&lt;=1000000007:</span><br><span class="line">            return ans</span><br><span class="line">        else:</span><br><span class="line">            return ans%1000000007</span><br></pre></td></tr></table></figure></details><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小力将 N 个零件的报价存于数组 nums。小力预算为 target，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。&lt;/p&gt;
&lt;p&gt;注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1&lt;/p&gt;
    
    </summary>
    
      <category term="2021年4月" scheme="http://yoursite.com/categories/2021%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Simulation" scheme="http://yoursite.com/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>294 · 简化链表</title>
    <link href="http://yoursite.com/2021/03/31/294%20%C2%B7%20%E7%AE%80%E5%8C%96%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2021/03/31/294 · 简化链表/</id>
    <published>2021-03-31T13:31:12.000Z</published>
    <updated>2021-04-01T00:00:20.757Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个字符链表，对其进行简化。<br>简化的过程为，保留链表的头尾节点，用数字代替掉中间的部分。数字也要用字符链表表示。</p><a id="more"></a><p>输入的字符链表用一个整型链表表示，链表的每个节点的值都是其对应的ASCII码。<br>输入的字符链表的节点数为 n，3≤n≤10^4</p><p>说明</p><pre><code>原链表是 &apos;h&apos;-&gt;&apos;e&apos;-&gt;&apos;l&apos;-&gt;&apos;l&apos;-&gt;&apos;o&apos;-&gt;null。简化后变为 &apos;h&apos;-&gt;&apos;3&apos;-&gt;&apos;o&apos;-&gt;null。第二组样例中：原链表是 &apos;a&apos;-&gt;&apos;b&apos;-&gt;...-&gt;&apos;z&apos;-&gt;null。简化后变为 &apos;a&apos;-&gt;&apos;2&apos;-&gt;&apos;4&apos;-&gt;&apos;z&apos;-&gt;null。</code></pre><p>样例</p><pre><code>输入1：    104-&gt;101-&gt;108-&gt;108-&gt;111-&gt;null输出1：    104-&gt;51-&gt;111-&gt;null输入2：    97-&gt;98-&gt;...-&gt;122-&gt;null输出2：    97-&gt;50-&gt;52-&gt;122-&gt;null</code></pre><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for ListNode</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param head: the linked list to be simplify.</span><br><span class="line">     * @return: return the linked list after simplifiction.</span><br><span class="line">     */</span><br><span class="line">    public ListNode simplify(ListNode head) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        ListNode cur=head.next;</span><br><span class="line">        if(head == null || cur == null || cur.next == null)&#123;</span><br><span class="line">          return head;</span><br><span class="line">        &#125;</span><br><span class="line">        int cnt=0;</span><br><span class="line">        while(cur.next!=null)&#123;</span><br><span class="line">          cur=cur.next;</span><br><span class="line">          cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">        if(cnt!=0)&#123;</span><br><span class="line">            ListNode p = new ListNode(Integer.valueOf(&apos;0&apos;)+cnt%10);</span><br><span class="line">            cnt/=10;</span><br><span class="line">            p.next = cur;</span><br><span class="line">            while(cnt != 0)&#123;</span><br><span class="line">              ListNode temp=p;</span><br><span class="line">              p = new ListNode(Integer.valueOf(&apos;0&apos;)+cnt%10);</span><br><span class="line">              p.next=temp;</span><br><span class="line">              cnt/=10;</span><br><span class="line">          &#125;</span><br><span class="line">          head.next=p;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出一个字符链表，对其进行简化。&lt;br&gt;简化的过程为，保留链表的头尾节点，用数字代替掉中间的部分。数字也要用字符链表表示。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Simulation" scheme="http://yoursite.com/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>711. 不同岛屿的数量II</title>
    <link href="http://yoursite.com/2021/03/31/711.%20%E4%B8%8D%E5%90%8C%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8FII/"/>
    <id>http://yoursite.com/2021/03/31/711. 不同岛屿的数量II/</id>
    <published>2021-03-31T09:31:12.000Z</published>
    <updated>2021-03-31T10:24:31.270Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个0和1的非空的二维数组网格，一个岛是一个1(表示陆地)的组，4个方向(水平或垂直)连接。你可以假设网格的所有四条边都被水包围。</p><p>计算不同岛屿的数量。当一个岛被认为与另一个岛相同时，它们有相同的形状，或在旋转后的形状相同(90,180，或270度)或翻转(左/右方向或向上/向下方向)。</p><a id="more"></a><p>样例</p><p>Example 1:</p><pre><code>11000100000000100011</code></pre><p>给定上述网格，返回1。<br>注意:</p><pre><code>111</code></pre><p>和</p><pre><code> 111</code></pre><p>被认为是相同的岛屿形状。因为如果我们在第一个岛上顺时针旋转180度，那么两个岛就会有相同的形状。</p><p>Example 2:</p><pre><code>11100100010100101110</code></pre><p>给定上述网格，返回2。<br>以下是两个不同的岛屿:</p><pre><code>1111</code></pre><p>和</p><pre><code>11</code></pre><p>注意：</p><pre><code>1111</code></pre><p>和</p><pre><code>1111</code></pre><p>被认为是相同的岛屿形状。因为如果我们在向上/向下的方向上翻转第一个数组，那么它们的形状是相同的<br>参见Lintcode<a href="https://www.lintcode.com/problem/804/?utm_source=sc-qingbaozhan-sy" target="_blank" rel="noopener">^1</a></p><h2 id="题解BFS"><a href="#题解BFS" class="headerlink" title="题解BFS"></a>题解BFS</h2><p>先用dfs或者bfs把每个岛屿都找出来，然后进行旋转比较。1·</p><details>    <summary>BFS</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param grid: the 2D grid</span><br><span class="line">     * @return: the number of distinct islands</span><br><span class="line">     */</span><br><span class="line">    private final int[] dir = &#123;-1, 0, 1, 0, -1&#125;;</span><br><span class="line">    private final int[][] ref1 = &#123;&#123;1, 1&#125;, &#123;1, -1&#125;, &#123;-1, 1&#125;, &#123;-1, -1&#125;&#125;;</span><br><span class="line">    public int numDistinctIslands2(int[][] grid) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        if (grid == null || grid.length == 0 || grid[0].length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        List&lt;Point&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; grid[0].length; j++) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    bfs(grid, i, j, list);</span><br><span class="line">                &#125;</span><br><span class="line">                if (list.size() &gt; 0) &#123;</span><br><span class="line">                    set.add(norm(list));</span><br><span class="line">                    list.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return set.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void bfs(int[][] grid, int row, int col, List&lt;Point&gt; list) &#123;</span><br><span class="line">        Queue&lt;Point&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">        Point start = new Point(row, col);</span><br><span class="line">        queue.add(start);</span><br><span class="line">        list.add(start);</span><br><span class="line">        grid[row][col] = 2;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            Point p = queue.poll();</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                int r = p.x + dir[i], c = p.y + dir[i + 1];</span><br><span class="line">                if (r &lt; 0 || r &gt;= grid.length || c &lt; 0 || c &gt;= grid[0].length || grid[r][c] != 1) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                grid[r][c] = 2;</span><br><span class="line">                Point next = new Point(r, c);</span><br><span class="line">                list.add(next);</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String norm(List&lt;Point&gt; list) &#123;</span><br><span class="line">        List&lt;Point&gt;[] comb = new List[8];</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            comb[i] = new ArrayList&lt;Point&gt;();</span><br><span class="line">            comb[i + 4] = new ArrayList&lt;Point&gt;();</span><br><span class="line">            for (Point p : list) &#123;</span><br><span class="line">                comb[i].add(new Point(p.x * ref1[i][0], p.y * ref1[i][1]));</span><br><span class="line">                comb[i + 4].add(new Point(p.y * ref1[i][1], p.x * ref1[i][0]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            Collections.sort(comb[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] s = new String[8];</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            int x0 = comb[i].get(0).x, y0 = comb[i].get(0).y;</span><br><span class="line">            for (Point p : comb[i]) &#123;</span><br><span class="line">                sb.append(p.x - x0).append(&apos;,&apos;).append(p.y - y0).append(&apos;!&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">            s[i] = sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        return s[0];</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Point implements Comparable&lt;Point&gt; &#123;</span><br><span class="line">        int x;</span><br><span class="line">        int y;</span><br><span class="line"></span><br><span class="line">        public Point(int x, int y) &#123;</span><br><span class="line">            this.x = x;</span><br><span class="line">            this.y = y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int compareTo(Point p) &#123;</span><br><span class="line">            return this.x - p.x == 0 ? this.y - p.y : this.x - p.x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="题解DFS"><a href="#题解DFS" class="headerlink" title="题解DFS"></a>题解DFS</h2><details>    <summary>DFS</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Point &#123;</span><br><span class="line">    public int x, y;</span><br><span class="line">    public Point(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param grid: the 2D grid</span><br><span class="line">     * @return: the number of distinct islands</span><br><span class="line">     */</span><br><span class="line">    public int numDistinctIslands2(int[][] grid) &#123;</span><br><span class="line">        if (grid == null || grid.length == 0 || grid[0].length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int m = grid.length, n = grid[0].length;</span><br><span class="line">        Set&lt;String&gt;  res = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    List&lt;Point&gt; island = new ArrayList&lt;&gt;();</span><br><span class="line">                    dfs(grid, i, j, island);</span><br><span class="line">                    res.add(getUnique(island));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(int[][]grid, int x, int y, List&lt;Point&gt; island) &#123;</span><br><span class="line">        int m = grid.length, n = grid[0].length;</span><br><span class="line"></span><br><span class="line">        island.add(new Point(x, y));</span><br><span class="line">        grid[x][y] = 0;</span><br><span class="line"></span><br><span class="line">        int[] dirs = &#123;-1, 0, 1, 0, -1&#125;;</span><br><span class="line">        for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">            int _x = x + dirs[i], _y = y + dirs[i + 1];</span><br><span class="line">            if (_x &gt;= 0  &amp;&amp; _x &lt; m  &amp;&amp; _y &gt;= 0  &amp;&amp; _y &lt; n  &amp;&amp; grid[_x][_y] == 1) &#123;</span><br><span class="line">                dfs(grid, _x, _y, island);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getUnique(List&lt;Point&gt; island) &#123;</span><br><span class="line">        List&lt;String&gt; sameIslands = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        int[][] trans=&#123;&#123;1, 1&#125;, &#123;1, -1&#125;, &#123;-1, 1&#125;, &#123;-1, -1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">            List&lt;Point&gt; l1 = new ArrayList&lt;&gt;(), l2 = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            for (Point point : island) &#123;</span><br><span class="line">                int x = point.x, y = point.y;</span><br><span class="line">                l1.add(new Point(x * trans[i][0], y * trans[i][1]));</span><br><span class="line">                l2.add(new Point(y * trans[i][0], x * trans[i][1]));</span><br><span class="line">            &#125;</span><br><span class="line">            sameIslands.add(getStr(l1));</span><br><span class="line">            sameIslands.add(getStr(l2));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(sameIslands);</span><br><span class="line">        return sameIslands.get(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getStr(List&lt;Point&gt; island) &#123;</span><br><span class="line"></span><br><span class="line">        Collections.sort(island, new Comparator&lt;Point&gt;() &#123;</span><br><span class="line">            public int compare(Point a, Point b) &#123;</span><br><span class="line">                if (a.x != b.x) &#123;</span><br><span class="line">                    return a.x - b.x;</span><br><span class="line">                &#125;</span><br><span class="line">                return a.y - b.y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        int x = island.get(0).x, y = island.get(0).y;</span><br><span class="line"></span><br><span class="line">        for (Point point : island) &#123;</span><br><span class="line">            sb.append((point.x - x) + &quot; &quot; + (point.y - y) + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个0和1的非空的二维数组网格，一个岛是一个1(表示陆地)的组，4个方向(水平或垂直)连接。你可以假设网格的所有四条边都被水包围。&lt;/p&gt;
&lt;p&gt;计算不同岛屿的数量。当一个岛被认为与另一个岛相同时，它们有相同的形状，或在旋转后的形状相同(90,180，或270度)或翻转(左/右方向或向上/向下方向)。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Bread-first Search" scheme="http://yoursite.com/tags/Bread-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>694. 不同岛屿的数量</title>
    <link href="http://yoursite.com/2021/03/31/694.%20%E4%B8%8D%E5%90%8C%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F/"/>
    <id>http://yoursite.com/2021/03/31/694. 不同岛屿的数量/</id>
    <published>2021-03-31T03:31:12.000Z</published>
    <updated>2021-03-31T09:12:36.395Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空01二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的 1 组成，你可以认为网格的四周被海水包围。</p><p>请你计算这个网格中共有多少个形状不同的岛屿。<br>两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。</p><a id="more"></a><p>样例 1:</p><pre><code>11000110000001100011</code></pre><p>给定上图，返回结果 1。</p><p>样例 2:</p><pre><code>11011100000000111011</code></pre><p>给定上图，返回结果 3。</p><p>注意:</p><pre><code>111</code></pre><p>和</p><pre><code> 111</code></pre><p>是不同的岛屿，因为我们不考虑旋转、翻转操作。</p><p>注释 :  二维数组每维的大小都不会超过50。</p><p>参见Lintcode<a href="https://www.lintcode.com/problem/860/" target="_blank" rel="noopener">^1</a></p><h2 id="题解BFS"><a href="#题解BFS" class="headerlink" title="题解BFS"></a>题解BFS</h2><p>我们可以通过BFS/DFS得到每一个岛屿，然后把每个岛屿的形状放到set里，最后set的大小就是答案。</p><p>那么问题的关键在于如何描述一个岛屿的形状。</p><p>有以下两个基本思路：</p><ol><li>记录一个岛屿所有点相对于左上角的点的相对位置。</li><li>记录一个岛屿的bfs/dfs轨迹</li></ol><p>方法1涉及细节较少，但是可能复杂度相对较高，不过50*50的数据范围不会超时。</p><p>方法1也有多种实现方法，比如一个岛屿形状可以用set记录，也可以将所有点的相对坐标排序后转换成字符串。</p><p>方法2需要注意一个细节：不能仅仅存储下来dfs/bfs移动的方向，因为涉及到回溯等问题，可以加上一定的间隔符，或者除方向之外额外记录一个位置信息。</p><details>    <summary>BFS</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDistinctIslands(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        if(grid.empty() || grid[0].empty()) return 0;</span><br><span class="line">        int m = grid.size(), n = grid[0].size(), i, j, k, x, y, x0, y0, nx, ny;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">        set&lt;vector&lt;vector&lt;int&gt;&gt;&gt; s;</span><br><span class="line">        for(i = 0; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">        for(j = 0; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">        if(grid[i][j] == 0)</span><br><span class="line">        continue;</span><br><span class="line">        x0 = i, y0 = j;</span><br><span class="line">        queue&lt;vector&lt;int&gt;&gt; q;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; path;</span><br><span class="line">        q.push(&#123;x0, y0&#125;);</span><br><span class="line">        grid[x0][y0] = 0;//访问过</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">        x = q.front()[0];</span><br><span class="line">        y = q.front()[1];</span><br><span class="line">        path.push_back(&#123;x-x0, y-y0&#125;);//路径记录相对坐标</span><br><span class="line">        q.pop();</span><br><span class="line">        for(k = 0; k &lt; 4; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">        nx = x + dir[k][0];</span><br><span class="line">        ny = y + dir[k][1];</span><br><span class="line">        if(nx&gt;=0 &amp;&amp; nx&lt;m &amp;&amp; ny&gt;=0 &amp;&amp; ny&lt;n &amp;&amp; grid[nx][ny])</span><br><span class="line">        &#123;</span><br><span class="line">        q.push(&#123;nx, ny&#125;);</span><br><span class="line">        grid[nx][ny] = 0;//访问过</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.insert(path);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h2 id="题解DFS"><a href="#题解DFS" class="headerlink" title="题解DFS"></a>题解DFS</h2><details>    <summary>DFS</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">    int m, n;</span><br><span class="line">    set&lt;vector&lt;vector&lt;int&gt;&gt;&gt; s;</span><br><span class="line">public:</span><br><span class="line">    int numDistinctIslands(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        if(grid.empty() || grid[0].empty()) return 0;</span><br><span class="line">        m = grid.size(), n = grid[0].size();</span><br><span class="line">        for(int i = 0, j; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(j = 0; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[i][j] == 0)</span><br><span class="line">                    continue;</span><br><span class="line">                vector&lt;vector&lt;int&gt;&gt; path;</span><br><span class="line">                grid[i][j] = 0;//访问过</span><br><span class="line">                DFS(grid,i,j,i,j,path);</span><br><span class="line">                s.insert(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x0, int y0, int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; path)</span><br><span class="line">    &#123;</span><br><span class="line">        path.push_back(&#123;x-x0, y-y0&#125;);//路径记录相对坐标</span><br><span class="line">        int k, nx, ny;</span><br><span class="line">        for(k = 0; k &lt; 4; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            nx = x + dir[k][0];</span><br><span class="line">            ny = y + dir[k][1];</span><br><span class="line">            if(nx&gt;=0 &amp;&amp; nx&lt;m &amp;&amp; ny&gt;=0 &amp;&amp; ny&lt;n &amp;&amp; grid[nx][ny])</span><br><span class="line">            &#123;</span><br><span class="line">                grid[nx][ny] = 0;//访问过</span><br><span class="line">                DFS(grid, x0, y0, nx, ny, path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>DFS II</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    /**</span><br><span class="line">     * @param grid: a list of lists of integers</span><br><span class="line">     * @return: return an integer, denote the number of distinct islands</span><br><span class="line">     */</span><br><span class="line">    int n, m, ix, iy;</span><br><span class="line">    set&lt;string&gt; S;</span><br><span class="line">    string temp;</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; vis;</span><br><span class="line">    int fx[4]=&#123;</span><br><span class="line">        1, -1, 0, 0</span><br><span class="line">    &#125;;</span><br><span class="line">    int fy[4]=&#123;</span><br><span class="line">        0, 0, 1, -1</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int numberofDistinctIslands(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        n = grid.size();</span><br><span class="line">        m = grid[0].size();</span><br><span class="line">        vector&lt;bool&gt; p;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            p.push_back(false);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            vis.push_back(p);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (grid[i][j] == 1 &amp;&amp; !vis[i][j]) &#123;</span><br><span class="line">                    ix = i;</span><br><span class="line">                    iy = j;</span><br><span class="line">                    temp = &quot;&quot;;</span><br><span class="line">                    dfs(i, j, grid);</span><br><span class="line">                    S.insert(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return S.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123;</span><br><span class="line">        vis[x][y] = true;</span><br><span class="line">        temp += to_string(x - ix) + &quot;&quot; + to_string(y - iy);</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            int nx = x + fx[i], ny = y + fy[i];</span><br><span class="line">            if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || vis[nx][ny] || grid[nx][ny] == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(nx, ny, grid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空01二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的 1 组成，你可以认为网格的四周被海水包围。&lt;/p&gt;
&lt;p&gt;请你计算这个网格中共有多少个形状不同的岛屿。&lt;br&gt;两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Bread-first Search" scheme="http://yoursite.com/tags/Bread-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>305. 岛屿数量 II</title>
    <link href="http://yoursite.com/2021/03/30/305.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%20II/"/>
    <id>http://yoursite.com/2021/03/30/305. 岛屿数量 II/</id>
    <published>2021-03-30T09:47:12.000Z</published>
    <updated>2021-03-31T03:29:02.064Z</updated>
    
    <content type="html"><![CDATA[<p>假设你设计一个游戏，用一个 m 行 n 列的 2D 网格来存储你的游戏地图。</p><p>起始的时候，每个格子的地形都被默认标记为「水」。<br>我们可以通过使用 addLand 进行操作，将位置 (row, col) 的「水」变成「陆地」。</p><p>你将会被给定一个列表，来记录所有需要被操作的位置，然后你需要返回计算出来 每次 addLand 操作后岛屿的数量。</p><a id="more"></a><p>注意：一个岛的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。<br>你可以假设地图网格的四边均被无边无际的「水」所包围。</p><p>请仔细阅读下方示例与解析，更加深入了解岛屿的判定。</p><p>示例:</p><pre><code>输入: m = 3, n = 3,     positions = [[0,0], [0,1], [1,2], [2,1]]输出: [1,1,2,3]解析:起初，二维网格 grid 被全部注入「水」。（0 代表「水」，1 代表「陆地」）0 0 00 0 00 0 0操作 #1：addLand(0, 0) 将 grid[0][0] 的水变为陆地。1 0 00 0 0   Number of islands = 10 0 0操作 #2：addLand(0, 1) 将 grid[0][1] 的水变为陆地。1 1 00 0 0   岛屿的数量为 10 0 0操作 #3：addLand(1, 2) 将 grid[1][2] 的水变为陆地。1 1 00 0 1   岛屿的数量为 20 0 0操作 #4：addLand(2, 1) 将 grid[2][1] 的水变为陆地。1 1 00 0 1   岛屿的数量为 30 1 0拓展：你是否能在 O(k log mn) 的时间复杂度程度内完成每次的计算？（k 表示 positions 的长度）</code></pre><details>    <summary>岛屿数量 II</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; numIslands2(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; positions) &#123;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>题目在Lintcode上也有，参见<a href="https://www.lintcode.com/problem/434/" target="_blank" rel="noopener">^1</a></p><h1 id="题解（超时）"><a href="#题解（超时）" class="headerlink" title="题解（超时）"></a>题解（超时）</h1><p>将矩阵的每个位置看成并查集中的一个点，每次加入一个岛屿，把四周是1的点合并掉</p><p>计算集团个数</p><details>    <summary>题解（超时）</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">class dsu</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; f;</span><br><span class="line"></span><br><span class="line">    dsu(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        f.resize(n);</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)</span><br><span class="line">            f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    void merge(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        int fa = find(a);</span><br><span class="line">        int fb = find(b);</span><br><span class="line">        f[fa] = fb;</span><br><span class="line">    &#125;</span><br><span class="line">    int find(int a)</span><br><span class="line">    &#123;</span><br><span class="line">        int origin = a;</span><br><span class="line">        while(a != f[a])</span><br><span class="line">            a = f[a];</span><br><span class="line">        return f[origin] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    int countUni(vector&lt;vector&lt;int&gt;&gt; &amp;grid)</span><br><span class="line">    &#123;</span><br><span class="line">        int count = 0, x, y, n = grid[0].size();</span><br><span class="line">        for(int i = 0; i &lt; f.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x = i/n, y = i-x*n;</span><br><span class="line">            if(i == find(i) &amp;&amp; grid[x][y]==1)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; numIslands2(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; positions) &#123;</span><br><span class="line">    int N = m*n, pos, x, y;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(m,vector&lt;int&gt;(n,0));</span><br><span class="line">    dsu u(N);</span><br><span class="line">    vector&lt;int&gt; ans(positions.size());</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">    for(int i = 0, k; i &lt; positions.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">            grid[positions[i][0]][positions[i][1]] = 1;//标记为岛屿</span><br><span class="line">            pos = positions[i][0]*n+positions[i][1];//对应并查集中的位置</span><br><span class="line">    for(k = 0; k &lt; 4; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">    x = positions[i][0] + dir[k][0];</span><br><span class="line">                y = positions[i][1] + dir[k][1];//周围坐标x,y</span><br><span class="line">    if(x&gt;=0 &amp;&amp; x&lt;m &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n &amp;&amp; grid[x][y]==1)</span><br><span class="line">    u.merge(pos, x*n+y);//合并</span><br><span class="line">    &#125;</span><br><span class="line">    ans[i] = u.countUni(grid);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h1 id="题解（改进仍不能通过）"><a href="#题解（改进仍不能通过）" class="headerlink" title="题解（改进仍不能通过）"></a>题解（改进仍不能通过）</h1><p>并查集merge 函数返回是否被合并了，合并了数量就减1</p><p>注意有重复岛屿，不能算</p><p>这种算法改进后在lintcode上运行了一次还是超时，只能通过30%的样例</p><details>    <summary>岛屿数量 II</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class dsu</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; f;</span><br><span class="line">    dsu(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        f.resize(n);</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)</span><br><span class="line">            f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    bool merge(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        int fa = find(a);</span><br><span class="line">        int fb = find(b);</span><br><span class="line">        if(fa != fb)</span><br><span class="line">        &#123;</span><br><span class="line">            f[fa] = fb;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;//返回是否被合并了</span><br><span class="line">    &#125;</span><br><span class="line">    int find(int a)</span><br><span class="line">    &#123;</span><br><span class="line">        int origin = a;</span><br><span class="line">        while(a != f[a])</span><br><span class="line">            a = f[a];</span><br><span class="line">        return f[origin] = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; numIslands2(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; positions) &#123;</span><br><span class="line">    int N = m*n, pos, x, y;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(m,vector&lt;int&gt;(n,0));</span><br><span class="line">    dsu u(N);</span><br><span class="line">    vector&lt;int&gt; ans(positions.size());</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">        unordered_set&lt;int&gt; s;//有重复的岛屿！！！</span><br><span class="line">    for(int i = 0, k; i &lt; positions.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">            ans[i] = (i&gt;0 ? ans[i-1] : 0 )+1;//先把这个岛屿算作孤立+1</span><br><span class="line">            grid[positions[i][0]][positions[i][1]] = 1;//标记为岛屿</span><br><span class="line">            pos = positions[i][0]*n+positions[i][1];//对应并查集中的位置</span><br><span class="line">            if(s.count(pos))//有该岛屿了，重复添加</span><br><span class="line">            &#123;</span><br><span class="line">                ans[i]--;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            s.insert(pos);</span><br><span class="line">    for(k = 0; k &lt; 4; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">    x = positions[i][0] + dir[k][0];</span><br><span class="line">                y = positions[i][1] + dir[k][1];//周围坐标x,y</span><br><span class="line">    if(x&gt;=0 &amp;&amp; x&lt;m &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n &amp;&amp; grid[x][y]==1)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(u.merge(pos, x*n+y))//合并了</span><br><span class="line">                        ans[i]--;//减1</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h1 id="题解（通过）"><a href="#题解（通过）" class="headerlink" title="题解（通过）"></a>题解（通过）</h1><p>构建数组nums表示所有位置对应岛屿的数字，初始化为0。遍历数组并将岛屿的值初始化为位置的值，此时岛屿数目+1，之后遍历此位置的邻接位置，若已经编号的岛屿，则将改岛屿的编号改为邻接岛屿编号，由于岛屿融合，岛屿的总数目-1。</p><details>    <summary>岛屿数量 II</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#ifndef C434_H</span><br><span class="line">#define C434_H</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">* 岛屿的个数II</span><br><span class="line">*</span><br><span class="line">* 给定 n，m，分别代表一个2D矩阵的行数和列数，同时，给定一个大小为 k 的二元数组A。起初，2D矩阵的行数和列数均为 0，即该矩阵中只有海洋。二元数组有 k 个运算符，每个运算符有 2 个整数 A[i].x, A[i].y，你可通过改变矩阵网格中的A[i].x]，[A[i].y] 来将其由海洋改为岛屿。请在每次运算后，返回矩阵中岛屿的数量。</span><br><span class="line">* 注意事项</span><br><span class="line">* 0 代表海，1 代表岛。如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。</span><br><span class="line">* 样例</span><br><span class="line">* 给定 n = 3, m = 3， 二元数组 A = [(0,0),(0,1),(2,2),(2,1)].</span><br><span class="line">* 返回 [1,1,2,2].</span><br><span class="line">*/</span><br><span class="line">struct Point&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    Point() :x(0), y(0)&#123;&#125;</span><br><span class="line">    Point(int a, int b) :x(a), y(b)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">    * @param n: An integer</span><br><span class="line">    * @param m: An integer</span><br><span class="line">    * @param operators: an array of point</span><br><span class="line">    * @return: an integer array</span><br><span class="line">    */</span><br><span class="line">    vector&lt;int&gt; numIslands2(int n, int m, vector&lt;Point&gt; &amp;operators) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (n &lt;= 0 || m &lt;= 0 || operators.empty())</span><br><span class="line">            return res;</span><br><span class="line">        vector&lt;int&gt; nums(n*m + 1, 0);//下标表示岛屿位置</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dic&#123; &#123; 1, 0 &#125;, &#123; -1, 0 &#125;, &#123; 0, 1 &#125;, &#123; 0, -1 &#125; &#125;;//方便遍历上下左右四个位置</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (auto c : operators)</span><br><span class="line">        &#123;</span><br><span class="line">            int pos = c.x*m + c.y + 1;</span><br><span class="line">            //若nums[pos]不为0,则岛屿已经出现过,直接返回现有的岛屿数目</span><br><span class="line">            if (nums[pos] &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(count);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //初始化nums[pos]为pos,表示pos最高层的岛屿是本身,此时岛屿数+1</span><br><span class="line">            nums[pos] = pos;</span><br><span class="line">            count++;</span><br><span class="line">            for (auto t : dic)</span><br><span class="line">            &#123;</span><br><span class="line">                int a = c.x + t[0];</span><br><span class="line">                int b = c.y + t[1];</span><br><span class="line">                int tmp = a*m + b + 1;</span><br><span class="line">                if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || nums[tmp] == 0)</span><br><span class="line">                    continue;</span><br><span class="line">                //tmp表示pos的相邻位置,root为tmp的最高层岛屿</span><br><span class="line">                //root!=pos表示pos与root并不属于同一个大岛屿,把pos并入root所在的大岛,</span><br><span class="line">                //nums[pos]=root,并将pos置为root避免重复计算,此时岛屿数目-1</span><br><span class="line">                int root = unionSearch(tmp, nums);</span><br><span class="line">                if (root != pos)</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[pos] = root;</span><br><span class="line">                    pos = root;</span><br><span class="line">                    --count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(count);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    //寻找root的最高层岛屿</span><br><span class="line">    int unionSearch(int root, vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        while (root != nums[root])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[root] = nums[nums[root]];</span><br><span class="line">            root = nums[root];</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设你设计一个游戏，用一个 m 行 n 列的 2D 网格来存储你的游戏地图。&lt;/p&gt;
&lt;p&gt;起始的时候，每个格子的地形都被默认标记为「水」。&lt;br&gt;我们可以通过使用 addLand 进行操作，将位置 (row, col) 的「水」变成「陆地」。&lt;/p&gt;
&lt;p&gt;你将会被给定一个列表，来记录所有需要被操作的位置，然后你需要返回计算出来 每次 addLand 操作后岛屿的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>572. 另一个树的子树</title>
    <link href="http://yoursite.com/2021/03/29/572.%20%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/"/>
    <id>http://yoursite.com/2021/03/29/572. 另一个树的子树/</id>
    <published>2021-03-29T12:55:12.000Z</published>
    <updated>2021-03-29T13:17:08.112Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p><a id="more"></a><p>示例 1:</p><p>给定的树 s:</p><pre><code>    3   / \  4   5 / \1   2</code></pre><p>给定的树 t：</p><pre><code>   4   / \ 1   2返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</code></pre><p>示例 2:</p><p>给定的树 s：</p><pre><code>    3   / \  4   5 / \1   2   /  0</code></pre><p>给定的树 t：</p><pre><code>   4  / \ 1   2返回 false。</code></pre><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：深度优先搜索暴力匹配"><a href="#方法一：深度优先搜索暴力匹配" class="headerlink" title="方法一：深度优先搜索暴力匹配"></a>方法一：深度优先搜索暴力匹配</h2><p><strong>思路和算法</strong></p><p>这是一种最朴素的方法——深度优先搜索枚举 <em>s</em> 中的每一个节点，判断这个点的子树是否和 <em>t</em> 相等。如何判断一个节点的子树是否和 <em>t</em> 相等呢，我们又需要做一次深度优先搜索来检查，即让两个指针一开始先指向该节点和 <em>t</em> 的根，然后「同步移动」两根指针来「同步遍历」这两棵树，判断对应位置是否相等。</p><details>    <summary>深度优先搜索暴力匹配C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *o, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o &amp;&amp; !t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((o &amp;&amp; !t) || (!o &amp;&amp; t) || (o-&gt;val != t-&gt;val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(o-&gt;left, t-&gt;left) &amp;&amp; check(o-&gt;right, t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *o, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(o, t) || dfs(o-&gt;left, t) || dfs(o-&gt;right, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode *s, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索暴力匹配Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(s, t) || dfs(s.left, t) || dfs(s.right, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span> || s.val != t.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(s.left, t.left) &amp;&amp; check(s.right, t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索暴力匹配Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(s *TreeNode, t *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(s, t) || isSubtree(s.Left, t) || isSubtree(s.Right, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(a, b *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a == <span class="literal">nil</span> &amp;&amp; b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> a == <span class="literal">nil</span> || b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> a.Val == b.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> check(a.Left, b.Left) &amp;&amp; check(a.Right, b.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="方法二：深度优先搜索序列上做串匹配"><a href="#方法二：深度优先搜索序列上做串匹配" class="headerlink" title="方法二：深度优先搜索序列上做串匹配"></a>方法二：深度优先搜索序列上做串匹配</h2><p><strong>思路和算法</strong></p><p>这个方法需要我们先了解一个「小套路」：一棵子树上的点在深度优先搜索序列（即先序遍历）中是连续的。了解了这个「小套路」之后，我们可以确定解决这个问题的方向就是：把 <em>s</em> 和 <em>t</em> 先转换成深度优先搜索序列，然后看 <em>t</em> 的深度优先搜索序列是否是 <em>s</em> 的深度优先搜索序列的「子串」。</p><p><strong>这样做正确吗？</strong> 假设 <em>s</em> 由两个点组成，<em>1</em> 是根，<em>2</em> 是 <em>1</em> 的左孩子；<em>t</em> 也由两个点组成，<em>1</em> 是根，<em>2</em> 是 <em>1</em> 的右孩子。这样一来 <em>s</em> 和 <em>t</em> 的深度优先搜索序列相同，可是 <em>t</em> 并不是 <em>s</em> 的某一棵子树。由此可见「<em>s</em> 的深度优先搜索序列包含 <em>t</em> 的深度优先搜索序列」是「<em>t</em> 是 <em>s</em> 子树」的<strong>必要不充分条件</strong>，所以单纯这样做是不正确的。</p><p>为了解决这个问题，我们可以引入两个空值 <code>lNull</code> 和 <code>rNull</code>，当一个节点的左孩子或者右孩子为空的时候，就插入这两个空值，这样深度优先搜索序列就唯一对应一棵树。处理完之后，就可以通过判断「<em>s</em> 的深度优先搜索序列包含 <em>t</em> 的深度优先搜索序列」来判断答案。</p><p><a href="https://assets.leetcode-cn.com/solution-static/572/572_fig1.png" target="_blank" rel="noopener">fig1</a></p><p>在判断「<em>s</em> 的深度优先搜索序列包含 <em>t</em> 的深度优先搜索序列」的时候，可以暴力匹配，也可以使用 KMP 或者 Rabin-Karp 算法，在使用Rabin-Karp算法的时候，要注意串中可能有负值。</p><p>这里给出用KMP判断的代码实现。</p><details><summary>深度优先搜索序列上做串匹配C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; sOrder, tOrder;</span><br><span class="line">    <span class="keyword">int</span> maxElement, lNull, rNull;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getMaxElement</span><span class="params">(TreeNode *o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxElement = max(maxElement, o-&gt;val);</span><br><span class="line">        getMaxElement(o-&gt;left);</span><br><span class="line">        getMaxElement(o-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getDfsOrder</span><span class="params">(TreeNode *o, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &amp;tar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tar.push_back(o-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;left) &#123;</span><br><span class="line">            getDfsOrder(o-&gt;left, tar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tar.push_back(lNull);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;right) &#123;</span><br><span class="line">            getDfsOrder(o-&gt;right, tar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tar.push_back(rNull);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = sOrder.size(), tLen = tOrder.size();</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; fail(tOrder.size(), <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i &lt; tLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; tOrder[i] != tOrder[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tOrder[i] == tOrder[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            fail[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; i &lt; sLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; sOrder[i] != tOrder[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sOrder[i] == tOrder[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == tLen - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        maxElement = INT_MIN;</span><br><span class="line">        getMaxElement(s);</span><br><span class="line">        getMaxElement(t);</span><br><span class="line">        lNull = maxElement + <span class="number">1</span>;</span><br><span class="line">        rNull = maxElement + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        getDfsOrder(s, sOrder);</span><br><span class="line">        getDfsOrder(t, tOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> kmp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>深度优先搜索序列上做串匹配Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sOrder = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;Integer&gt; tOrder = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> maxElement, lNull, rNull;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        maxElement = Integer.MIN_VALUE;</span><br><span class="line">        getMaxElement(s);</span><br><span class="line">        getMaxElement(t);</span><br><span class="line">        lNull = maxElement + <span class="number">1</span>;</span><br><span class="line">        rNull = maxElement + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        getDfsOrder(s, sOrder);</span><br><span class="line">        getDfsOrder(t, tOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> kmp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMaxElement</span><span class="params">(TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxElement = Math.max(maxElement, t.val);</span><br><span class="line">        getMaxElement(t.left);</span><br><span class="line">        getMaxElement(t.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDfsOrder</span><span class="params">(TreeNode t, List&lt;Integer&gt; tar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tar.add(t.val);</span><br><span class="line">        <span class="keyword">if</span> (t.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getDfsOrder(t.left, tar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tar.add(lNull);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getDfsOrder(t.right, tar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tar.add(rNull);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = sOrder.size(), tLen = tOrder.size();</span><br><span class="line">        <span class="keyword">int</span>[] fail = <span class="keyword">new</span> <span class="keyword">int</span>[tOrder.size()];</span><br><span class="line">        Arrays.fill(fail, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = -<span class="number">1</span>; i &lt; tLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; !(tOrder.get(i).equals(tOrder.get(j + <span class="number">1</span>)))) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tOrder.get(i).equals(tOrder.get(j + <span class="number">1</span>))) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            fail[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>; i &lt; sLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; !(sOrder.get(i).equals(tOrder.get(j + <span class="number">1</span>)))) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sOrder.get(i).equals(tOrder.get(j + <span class="number">1</span>))) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == tLen - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>深度优先搜索序列上做串匹配Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(s *TreeNode, t *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    maxEle := math.MinInt32</span><br><span class="line">    getMaxElement(s, &amp;maxEle)</span><br><span class="line">    getMaxElement(t, &amp;maxEle)</span><br><span class="line">    lNull := maxEle + <span class="number">1</span>;</span><br><span class="line">    rNull := maxEle + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    sl, tl := getDfsOrder(s, []<span class="keyword">int</span>&#123;&#125;, lNull, rNull), getDfsOrder(t, []<span class="keyword">int</span>&#123;&#125;, lNull, rNull)</span><br><span class="line">    <span class="keyword">return</span> kmp(sl, tl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kmp</span><span class="params">(s, t []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    sLen, tLen := <span class="built_in">len</span>(s), <span class="built_in">len</span>(t)</span><br><span class="line">    fail := <span class="built_in">make</span>([]<span class="keyword">int</span>, sLen)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; sLen; i++ &#123;</span><br><span class="line">        fail[i] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">1</span>, <span class="number">-1</span>; i &lt; tLen; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j != <span class="number">-1</span> &amp;&amp; t[i] != t[j+<span class="number">1</span>] &#123;</span><br><span class="line">            j = fail[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> t[i] == t[j+<span class="number">1</span>] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        fail[i] = j</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">-1</span>; i &lt; sLen; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j != <span class="number">-1</span> &amp;&amp; s[i] != t[j+<span class="number">1</span>] &#123;</span><br><span class="line">            j = fail[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s[i] == t[j+<span class="number">1</span>] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j == tLen - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDfsOrder</span><span class="params">(t *TreeNode, list []<span class="keyword">int</span>, lNull, rNull <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    &#125;</span><br><span class="line">    list = <span class="built_in">append</span>(list, t.Val)</span><br><span class="line">    <span class="keyword">if</span> t.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        list = getDfsOrder(t.Left, list, lNull, rNull)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = <span class="built_in">append</span>(list, lNull)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> t.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        list = getDfsOrder(t.Right, list, lNull, rNull)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = <span class="built_in">append</span>(list, rNull)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxElement</span><span class="params">(t *TreeNode, maxEle *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.Val &gt; *maxEle &#123;</span><br><span class="line">        *maxEle = t.Val</span><br><span class="line">    &#125;</span><br><span class="line">    getMaxElement(t.Left, maxEle)</span><br><span class="line">    getMaxElement(t.Right, maxEle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="方法三：树哈希"><a href="#方法三：树哈希" class="headerlink" title="方法三：树哈希"></a>方法三：树哈希</h2><p><strong>思路和算法</strong></p><p>考虑把每个子树都映射成一个唯一的数，如果 <em>t</em> 对应的数字和 <em>s</em> 中任意一个子树映射的数字相等，则 <em>t</em> 是 <em>s</em> 的某一棵子树。如何映射呢？我们可以定义这样的哈希函数：</p><details><summary>树哈希C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MOD = <span class="keyword">int</span>(<span class="number">1E9</span>) + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> vis[MAX_N];</span><br><span class="line">    <span class="keyword">int</span> p[MAX_N], tot;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="number">1</span>; tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX_N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) p[++tot] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * p[j] &lt; MAX_N; ++j) &#123;</span><br><span class="line">                vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> f, s; <span class="comment">// f 为哈希值 | s 为子树大小</span></span><br><span class="line">        Status(<span class="keyword">int</span> f_ = <span class="number">0</span>, <span class="keyword">int</span> s_ = <span class="number">0</span>) </span><br><span class="line">            : f(f_), s(s_) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;TreeNode *, Status&gt; hS, hT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *o, <span class="built_in">unordered_map</span> &lt;TreeNode *, Status&gt; &amp;h)</span> </span>&#123;</span><br><span class="line">        h[o] = Status(o-&gt;val, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!o-&gt;left &amp;&amp; !o-&gt;right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;left) &#123;</span><br><span class="line">            dfs(o-&gt;left, h);</span><br><span class="line">            h[o].s += h[o-&gt;left].s;</span><br><span class="line">            h[o].f = (h[o].f + (<span class="number">31L</span>L * h[o-&gt;left].f * p[h[o-&gt;left].s]) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;right) &#123;</span><br><span class="line">            dfs(o-&gt;right, h);</span><br><span class="line">            h[o].s += h[o-&gt;right].s;</span><br><span class="line">            h[o].f = (h[o].f + (<span class="number">179L</span>L * h[o-&gt;right].f * p[h[o-&gt;right].s]) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        getPrime();</span><br><span class="line">        dfs(s, hS);</span><br><span class="line">        dfs(t, hT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tHash = hT[t].f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[k, v]: hS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v.f == tHash) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>树哈希Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_N = <span class="number">1005</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_N];</span><br><span class="line">    <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    Map&lt;TreeNode, <span class="keyword">int</span>[]&gt; hS = <span class="keyword">new</span> HashMap&lt;TreeNode, <span class="keyword">int</span>[]&gt;();</span><br><span class="line">    Map&lt;TreeNode, <span class="keyword">int</span>[]&gt; hT = <span class="keyword">new</span> HashMap&lt;TreeNode, <span class="keyword">int</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        getPrime();</span><br><span class="line">        dfs(s, hS);</span><br><span class="line">        dfs(t, hT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tHash = hT.get(t)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;TreeNode, <span class="keyword">int</span>[]&gt; entry : hS.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue()[<span class="number">0</span>] == tHash) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX_N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">                p[++tot] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * p[j] &lt; MAX_N; ++j) &#123;</span><br><span class="line">                vis[i * p[j]] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode o, Map&lt;TreeNode, <span class="keyword">int</span>[]&gt; h)</span> </span>&#123;</span><br><span class="line">        h.put(o, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;o.val, <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">if</span> (o.left == <span class="keyword">null</span> &amp;&amp; o.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dfs(o.left, h);</span><br><span class="line">            <span class="keyword">int</span>[] val = h.get(o);</span><br><span class="line">            val[<span class="number">1</span>] += h.get(o.left)[<span class="number">1</span>];</span><br><span class="line">            val[<span class="number">0</span>] = (<span class="keyword">int</span>) ((val[<span class="number">0</span>] + (<span class="number">31L</span> * h.get(o.left)[<span class="number">0</span>] * p[h.get(o.left)[<span class="number">1</span>]]) % MOD) % MOD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dfs(o.right, h);</span><br><span class="line">            <span class="keyword">int</span>[] val = h.get(o);</span><br><span class="line">            val[<span class="number">1</span>] += h.get(o.right)[<span class="number">1</span>];</span><br><span class="line">            val[<span class="number">0</span>] = (<span class="keyword">int</span>) ((val[<span class="number">0</span>] + (<span class="number">179L</span> * h.get(o.right)[<span class="number">0</span>] * p[h.get(o.right)[<span class="number">1</span>]]) % MOD) % MOD);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>304. 二维区域和检索 - 矩阵不可变</title>
    <link href="http://yoursite.com/2021/03/27/491.%20%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2021/03/27/491. 递增子序列/</id>
    <published>2021-03-27T13:17:12.000Z</published>
    <updated>2021-03-28T01:00:59.596Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2 。</p><a id="more"></a><p>示例：</p><pre><code>输入：[4, 6, 7, 7]输出：[[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</code></pre><p>提示：</p><pre><code>给定数组的长度不会超过15。数组中的整数范围是 [-100,100]。给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</code></pre><h1 id="方法一：二进制枚举-哈希"><a href="#方法一：二进制枚举-哈希" class="headerlink" title="方法一：二进制枚举 + 哈希"></a>方法一：二进制枚举 + 哈希</h1><p>这个方法比较难理解，可以参见<a href="https://leetcode-cn.com/problems/increasing-subsequences/solution/di-zeng-zi-xu-lie-by-leetcode-solution/" target="_blank" rel="noopener">^1</a>，</p><h1 id="方法二：递归枚举-减枝"><a href="#方法二：递归枚举-减枝" class="headerlink" title="方法二：递归枚举 + 减枝"></a>方法二：递归枚举 + 减枝</h1><p><strong>思路与算法</strong></p><p>我们也可以用递归的方法实现二进制枚举，像「方法一」那样枚举出所有的子序列，然后判断是否合法。直接把方法一变成递归形式，我们可以得到这样的代码：</p><details>    <summary>C++</summary><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == nums.size()) &#123;</span><br><span class="line">        <span class="comment">// 判断是否合法，如果合法判断是否重复，将满足条件的加入答案</span></span><br><span class="line">        <span class="keyword">if</span> (isValid() &amp;&amp; notVisited()) &#123;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果选择当前元素</span></span><br><span class="line">    temp.push_back(nums[cur]);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">    temp.pop_back();</span><br><span class="line">    <span class="comment">// 如果不选择当前元素</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == nums.length) &#123;</span><br><span class="line">        <span class="comment">// 判断是否合法，如果合法判断是否重复，将满足条件的加入答案</span></span><br><span class="line">        <span class="keyword">if</span> (isValid() &amp;&amp; notVisited()) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果选择当前元素</span></span><br><span class="line">    temp.add(nums[cur]);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">    temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果不选择当前元素</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这是一个递归枚举子序列的通用模板.</p><p>当然，如果我们简单地这样枚举，对于每一个子序列，我们还需要做一次 <em>O(n)</em> 的合法性检查和哈希判重复，在执行整个程序的过程中，我们还需要使用一个空间代价 <em>O(2^n)</em> 的哈希表来维护已经出现的子序列的哈希值。我们可以对选择和不选择做一些简单的限定，就可以让枚举出来的都是合法的并且不重复：</p><ul><li><p>使序列合法的办法非常简单，即给「选择」做一个限定条件，只有当前的元素大于等于上一个选择的元素的时候才能选择这个元素，这样枚举出来的所有元素都是合法的</p></li><li><p>那如何保证没有重复呢？我们需要给「不选择」做一个限定条件，只有当当前的元素不等于上一个选择的元素的时候，才考虑不选择当前元素，直接递归后面的元素。因为如果有两个相同的元素，我们会考虑这样四种情况：</p><ol><li><p>前者被选择，后者被选择</p></li><li><p>前者被选择，后者不被选择</p></li><li><p>前者不被选择，后者被选择</p></li><li><p>前者不被选择，后者不被选择</p><p>其中第二种情况和第三种情况其实是等价的，我们这样限制之后，舍弃了第二种，保留了第三种，于是达到了去重的目的。</p></li></ol></li></ul><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp; </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> last, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                ans.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] &gt;= last) &#123;</span><br><span class="line">            temp.push_back(nums[cur]);</span><br><span class="line">            dfs(cur + <span class="number">1</span>, nums[cur], nums);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] != last) &#123;</span><br><span class="line">            dfs(cur + <span class="number">1</span>, last, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findSubsequences(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, INT_MIN, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, Integer.MIN_VALUE, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> last, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] &gt;= last) &#123;</span><br><span class="line">            temp.add(nums[cur]);</span><br><span class="line">            dfs(cur + <span class="number">1</span>, nums[cur], nums);</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] != last) &#123;</span><br><span class="line">            dfs(cur + <span class="number">1</span>, last, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>** ans;</span><br><span class="line"><span class="keyword">int</span> ansSize;</span><br><span class="line"><span class="keyword">int</span>* temp;</span><br><span class="line"><span class="keyword">int</span> tempSize;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> last, <span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == numsSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempSize &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            ans[ansSize] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * tempSize);</span><br><span class="line">            <span class="built_in">memcpy</span>(ans[ansSize], temp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * tempSize);</span><br><span class="line">            (*returnColumnSizes)[ansSize++] = tempSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[cur] &gt;= last) &#123;</span><br><span class="line">        temp[tempSize++] = nums[cur];</span><br><span class="line">        dfs(cur + <span class="number">1</span>, nums[cur], nums, numsSize, returnColumnSizes);</span><br><span class="line">        tempSize--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[cur] != last) &#123;</span><br><span class="line">        dfs(cur + <span class="number">1</span>, last, nums, numsSize, returnColumnSizes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">findSubsequences</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span>&#123;</span><br><span class="line">    ans = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * <span class="number">32768</span>);</span><br><span class="line">    *returnColumnSizes = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * <span class="number">32768</span>);</span><br><span class="line">    temp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);</span><br><span class="line">    ansSize = tempSize = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">0</span>, INT_MIN, nums, numsSize, returnColumnSizes);</span><br><span class="line">    *returnSize = ansSize;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    temp []<span class="keyword">int</span></span><br><span class="line">    ans [][]<span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSubsequences</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    ans = [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    dfs(<span class="number">0</span>, math.MinInt32, nums)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(cur, last <span class="keyword">int</span>, nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> cur == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">            t := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(temp))</span><br><span class="line">            <span class="built_in">copy</span>(t, temp)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, t)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nums[cur] &gt;= last &#123;</span><br><span class="line">        temp = <span class="built_in">append</span>(temp, nums[cur])</span><br><span class="line">        dfs(cur + <span class="number">1</span>, nums[cur], nums)</span><br><span class="line">        temp = temp[:<span class="built_in">len</span>(temp)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nums[cur] != last &#123;</span><br><span class="line">        dfs(cur + <span class="number">1</span>, last, nums)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(2^n * n)  。仍然需要对子序列做二进制枚举，枚举出的序列虽然省去了判断合法性和哈希的过程，但是仍然需要 <em>O(n)</em> 的时间添加到答案中。</li><li>空间复杂度：<em>O(n)</em>。这里临时数组的空间代价是 <em>O(n)</em>，递归使用的栈空间的空间代价也是 <em>O(n)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
</feed>
