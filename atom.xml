<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-12T07:18:34.336Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>415. 字符串相加</title>
    <link href="http://yoursite.com/2020/10/12/415.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2020/10/12/415. 字符串相加/</id>
    <published>2020-10-12T07:00:12.000Z</published>
    <updated>2020-10-12T07:18:34.336Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p><a id="more"></a><p>提示：</p><pre><code>num1 和num2 的长度都小于 5100num1 和num2 都只包含数字 0-9num1 和num2 都不包含任何前导零你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式</code></pre><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><p><strong>思路与算法</strong></p><p>本题我们只需要对两个大整数模拟「竖式加法」的过程。竖式加法就是我们平常学习生活中常用的对两个整数相加的方法，回想一下我们在纸上对两个整数相加的操作，是不是如下图将相同数位对齐，从低到高逐位相加，如果当前位和超过 <em>10</em>，则向高位进一位？因此我们只要将这个过程用代码写出来即可。</p><p><a href="https://assets.leetcode-cn.com/solution-static/415/1.png" target="_blank" rel="noopener">fig1</a></p><p>具体实现也不复杂，我们定义两个指针 <em>i</em> 和 <em>j</em> 分别指向 num1 和num2  的末尾，即最低位，同时定义一个变量add 维护当前是否有进位，然后从末尾到开头逐位相加即可。你可能会想两个数字位数不同怎么处理，这里我们统一在指针当前下标处于负数的时候返回 <em>0</em>，等价于<strong>对位数较短的数字进行了补零操作</strong>，这样就可以除去两个数字位数不同情况的处理，具体可以看下面的代码。</p><details>    <summary>模拟C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1[i] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2[j] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">            ans.push_back(<span class="string">'0'</span> + result % <span class="number">10</span>);</span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i -= <span class="number">1</span>;</span><br><span class="line">            j -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算完以后的答案需要翻转过来</span></span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">            ans.append(result % <span class="number">10</span>);</span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算完以后的答案需要翻转过来</span></span><br><span class="line">        ans.reverse();</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1 <span class="keyword">string</span>, num2 <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    add := <span class="number">0</span></span><br><span class="line">    ans := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="built_in">len</span>(num1) - <span class="number">1</span>, <span class="built_in">len</span>(num2) - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>; i, j = i - <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            x = <span class="keyword">int</span>(num1[i] - <span class="string">'0'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            y = <span class="keyword">int</span>(num2[j] - <span class="string">'0'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        result := x + y + add</span><br><span class="line">        ans = strconv.Itoa(result%<span class="number">10</span>) + ans</span><br><span class="line">        add = result / <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addStrings = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = num1.length - <span class="number">1</span>, j = num2.length - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> ans = [];</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> y = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> result = x + y + add;</span><br><span class="line">        ans.push(result % <span class="number">10</span>);</span><br><span class="line">        add = <span class="built_in">Math</span>.floor(result / <span class="number">10</span>);</span><br><span class="line">        i -= <span class="number">1</span>;</span><br><span class="line">        j -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.reverse().join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">addStrings</span><span class="params">(<span class="keyword">char</span>* num1, <span class="keyword">char</span>* num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">strlen</span>(num1) - <span class="number">1</span>, j = <span class="built_in">strlen</span>(num2) - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* ans = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (fmax(i, j) + <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1[i] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2[j] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">        ans[len++] = <span class="string">'0'</span> + result % <span class="number">10</span>;</span><br><span class="line">        add = result / <span class="number">10</span>;</span><br><span class="line">        i--, j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算完以后的答案需要翻转过来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="number">2</span> * i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = ans[i];</span><br><span class="line">        ans[i] = ans[len - i - <span class="number">1</span>], ans[len - i - <span class="number">1</span>] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[len++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(max(len1,len2)，其中len1=num1.length ，len2=num2.length 。竖式加法的次数取决于较大数的位数。</li><li>空间复杂度：<em>O(1)</em>。除答案外我们只需要常数空间存放若干变量。在 Java 解法中使用到了 StringBuffer，故 Java 解法的空间复杂度为 <em>O(n)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>43. 字符串相乘</title>
    <link href="http://yoursite.com/2020/10/12/43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <id>http://yoursite.com/2020/10/12/43. 字符串相乘/</id>
    <published>2020-10-12T02:12:12.000Z</published>
    <updated>2020-10-12T07:25:57.066Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot;</code></pre><p>示例 2:</p><pre><code>输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot;</code></pre><p>说明：</p><pre><code>num1 和 num2 的长度小于110。num1 和 num2 只包含数字 0-9。num1 和 num2 均不以零开头，除非是数字 0 本身。不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</code></pre><h2 id="方法一：普通竖式"><a href="#方法一：普通竖式" class="headerlink" title="方法一：普通竖式"></a>方法一：普通竖式</h2><p><strong>思路</strong></p><p>竖式运算思想，以 <code>num1</code> 为 <code>123</code>，<code>num2</code> 为 <code>456</code> 为例分析：</p><p><a href="https://pic.leetcode-cn.com/d24bf3174a878890e1273fbe35426ecdfa932c33efb464ed3602f4d149ed343a" target="_blank" rel="noopener">分析</a></p><p>遍历 <code>num2</code> 每一位与 <code>num1</code> 进行相乘，将每一步的结果进行累加。</p><p><strong>注意：</strong></p><ul><li><code>num2</code> 除了第一位的其他位与 <code>num1</code> 运算的结果需要 <strong>补0</strong></li><li>计算字符串数字累加其实就是 <a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加</a></li></ul><p><strong>实现</strong></p><details>    <summary>普通竖式Java</summary><figure class="highlight java"><figcaption><span>[-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计算形式</span></span><br><span class="line"><span class="comment">    *    num1</span></span><br><span class="line"><span class="comment">    *  x num2</span></span><br><span class="line"><span class="comment">    *  ------</span></span><br><span class="line"><span class="comment">    *  result</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存计算结果</span></span><br><span class="line">        String res = <span class="string">"0"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// num2 逐位与 num1 相乘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num2.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 保存 num2 第i位数字与 num1 相乘的结果</span></span><br><span class="line">            StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="comment">// 补 0 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num2.length() - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                temp.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> n2 = num2.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// num2 的第 i 位数字 n2 与 num1 相乘</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = num1.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> n1 = j &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> product = (n1 * n2 + carry) % <span class="number">10</span>;</span><br><span class="line">                temp.append(product);</span><br><span class="line">                carry = (n1 * n2 + carry) / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前结果与新计算的结果求和作为新的结果</span></span><br><span class="line">            res = addStrings(res, temp.reverse().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对两个字符串数字进行相加，返回字符串形式的和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">             i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>;</span><br><span class="line">             i--, j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &lt; <span class="number">0</span> ? <span class="number">0</span> : num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = (x + y + carry) % <span class="number">10</span>;</span><br><span class="line">            builder.append(sum);</span><br><span class="line">            carry = (x + y + carry) / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O</em>(<em>M N</em>)。<em>M,N</em> 分别为 <code>num1</code> 和 <code>num2</code> 的长度。</li><li>空间复杂度：<em>O</em>(M+N)。用于存储计算结果。</li></ul><h2 id="方法二：优化竖式"><a href="#方法二：优化竖式" class="headerlink" title="方法二：优化竖式"></a>方法二：优化竖式</h2><p>该算法是通过两数相乘时，乘数某位与被乘数某位相乘，与产生结果的位置的规律来完成。具体规律如下：</p><ul><li>乘数 <code>num1</code> 位数为 <em>M</em>，被乘数 <code>num2</code> 位数为 <em>N</em>， <code>num1 x num2</code> 结果 <code>res</code> 最大总位数为 <strong>M+N</strong></li><li><code>num1[i] x num2[j]</code> 的结果为 <code>tmp</code>(位数为两位，”0x”,”xy”的形式)，其第一位位于 <code>res[i+j]</code>，第二位位于 <code>res[i+j+1]</code>。</li></ul><p>结合下图更容易理解</p><p><a href="https://pic.leetcode-cn.com/171cad48cd0c14f565f2a0e5aa5ccb130e4562906ee10a84289f12e4460fe164-image.png" target="_blank" rel="noopener">图</a></p><details>    <summary>优化竖式Java</summary><figure class="highlight java"><figcaption><span>[-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num1.length() + num2.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = num2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> n2 = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> sum = (res[i + j + <span class="number">1</span>] + n1 * n2);</span><br><span class="line">                res[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">                res[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; res[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            result.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O</em>(<em>M N</em>)<em>。</em>M,N* 分别为 <code>num1</code> 和 <code>num2</code> 的长度。</li><li>空间复杂度：<em>O</em>(M+N)*。用于存储计算结果。</li></ul><h2 id="算法比较"><a href="#算法比较" class="headerlink" title="算法比较"></a>算法比较</h2><table><thead><tr><th align="left">算法</th><th align="left">提交结果</th><th align="left">执行用时</th><th align="left">内存消耗</th><th align="left">语言</th></tr></thead><tbody><tr><td align="left">普通竖式</td><td align="left">通过</td><td align="left">48 ms</td><td align="left">43.8 MB</td><td align="left">Java</td></tr><tr><td align="left">优化竖式</td><td align="left">通过</td><td align="left">4 ms</td><td align="left">36.6 MB</td><td align="left">Java</td></tr></tbody></table><p><strong>虽然两者时间复杂度和空间复杂度相同，但优化竖式执行速度提高很明显，普通竖式耗时主要还是对每步计算的字符串相加这个过程。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>程序员面试金典.面试题08.08.有重复字符串的排列组合</title>
    <link href="http://yoursite.com/2020/10/10/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8.%E9%9D%A2%E8%AF%95%E9%A2%9808.08.%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2020/10/10/程序员面试金典.面试题08.08.有重复字符串的排列组合/</id>
    <published>2020-10-10T09:17:12.000Z</published>
    <updated>2020-10-10T09:37:37.606Z</updated>
    
    <content type="html"><![CDATA[<p>有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。</p><a id="more"></a><p>示例1:</p><pre><code>输入：S = &quot;qqe&quot;输出：[&quot;eqq&quot;,&quot;qeq&quot;,&quot;qqe&quot;]</code></pre><p>示例2:</p><pre><code>输入：S = &quot;ab&quot;输出：[&quot;ab&quot;, &quot;ba&quot;]</code></pre><p>提示:</p><pre><code>字符都是英文字母。字符串长度在[1, 9]之间。</code></pre><p>这道题和<strong>剑指 offer38.字符串的排列</strong>完全一致，但我在重写的过程中还是出错了，有几个小细节需要注意一下。</p><p>首先是返回字符串数组的定义方法一开始没有写对<code>return res.toArray(new String[res.size()]);</code></p><p>然后在近乎于默写的写完了答案后发现咦？居然出错了</p><details>    <summary>第一版错误代码</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">    char[] c;</span><br><span class="line">    public String[] permutation(String S) &#123;</span><br><span class="line">        c = S.toCharArray();</span><br><span class="line">        dfs(0);</span><br><span class="line">        return res.toArray(new String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(int x) &#123;</span><br><span class="line">        if (x == c.length - 1) &#123;</span><br><span class="line">            res.add(String.valueOf(c));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = x; i &lt; c.length; i++) &#123;</span><br><span class="line">            HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">            if (set.contains(c[x])) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(c[x]);</span><br><span class="line">            swap(i, x);</span><br><span class="line">            dfs(x+1);</span><br><span class="line">            swap(i, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(int i, int j) &#123;</span><br><span class="line">        char tmp = c[i];</span><br><span class="line">        c[i] = c[j];</span><br><span class="line">        c[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><pre><code>测试用例:&quot;qqe&quot;测试结果:[&quot;qqe&quot;,&quot;qeq&quot;,&quot;qqe&quot;,&quot;qeq&quot;,&quot;eqq&quot;,&quot;eqq&quot;]期望结果:[&quot;eqq&quot;,&quot;qeq&quot;,&quot;qqe&quot;]</code></pre><p>这个一看就是HashSet出了问题，发现是HashSet定义在了循环内。所以没有起到剪枝的作用<br>挪到了循环外再执行</p><pre><code>测试用例:&quot;qqe&quot;测试结果:[&quot;qqe&quot;]期望结果:[&quot;eqq&quot;,&quot;qeq&quot;,&quot;qqe&quot;]</code></pre><p>检查了半天才发现是这句出错了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (set.contains(c[x])) &#123;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次塞进HashSet的应该是c[i]而非c[x]</p><p>改了下又报错了：</p><pre><code>测试用例:&quot;OSS&quot;测试结果:[&quot;OSS&quot;,&quot;SOS&quot;,&quot;SSO&quot;,&quot;SSO&quot;,&quot;SOS&quot;]期望结果:[&quot;OSS&quot;,&quot;SOS&quot;,&quot;SSO&quot;]</code></pre><p>嗨呀，原来是光改了判断的逻辑，没改<code>set.add(c[x]);</code>这句，都改了下就ok了</p><details>    <summary>正确代码</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">    char[] c;</span><br><span class="line">    public String[] permutation(String S) &#123;</span><br><span class="line">        c = S.toCharArray();</span><br><span class="line">        dfs(0);</span><br><span class="line">        return res.toArray(new String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(int x) &#123;</span><br><span class="line">        if (x == c.length - 1) &#123;</span><br><span class="line">            res.add(String.valueOf(c));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        for (int i = x; i &lt; c.length; i++) &#123;</span><br><span class="line">            if (set.contains(c[i])) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            swap(i, x);</span><br><span class="line">            dfs(x+1);</span><br><span class="line">            swap(i, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(int i, int j) &#123;</span><br><span class="line">        char tmp = c[i];</span><br><span class="line">        c[i] = c[j];</span><br><span class="line">        c[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>所以即使刚刚做过一遍，如果没有充分理解如何使用HashSet剪枝和如何利用回溯的方法来全排列还是很难一次性解决的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Cracking the Coding Interview" scheme="http://yoursite.com/tags/Cracking-the-Coding-Interview/"/>
    
  </entry>
  
  <entry>
    <title>程序员面试金典.面试题08.07.无重复字符串的排列组合</title>
    <link href="http://yoursite.com/2020/10/10/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8.%E9%9D%A2%E8%AF%95%E9%A2%9808.07.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2020/10/10/程序员面试金典.面试题08.07.无重复字符串的排列组合/</id>
    <published>2020-10-10T08:40:12.000Z</published>
    <updated>2020-10-10T09:19:43.587Z</updated>
    
    <content type="html"><![CDATA[<p>无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。</p><a id="more"></a><p>示例1:</p><pre><code>输入：S = &quot;qwe&quot;输出：[&quot;qwe&quot;, &quot;qew&quot;, &quot;wqe&quot;, &quot;weq&quot;, &quot;ewq&quot;, &quot;eqw&quot;]</code></pre><p>示例2:</p><pre><code>输入：S = &quot;ab&quot;输出：[&quot;ab&quot;, &quot;ba&quot;]</code></pre><p>提示:</p><pre><code>字符都是英文字母。字符串长度在[1, 9]之间。</code></pre><p><strong>此题是剑指 offer38.字符串的排列的简单版，因为字符串每个字符均不相同，所以可以去掉原来算法中的剪枝部分。</strong></p><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p><strong>排列方案数量：</strong> 对于一个长度为 <em>n</em> 的字符串（假设字符互不重复），其排列共有 n<em>(n-1)</em>(n-2)<em>…</em>2*1种方案。</p><p><strong>排列方案的生成方法：</strong> 根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 <em>1</em> 位字符（ <em>n</em> 种情况）、再固定第 <em>2</em> 位字符（ <em>n-1</em> 种情况）、… 、最后固定第 <em>n</em> 位字符（ <em>1</em> 种情况）。</p><p><a href="https://pic.leetcode-cn.com/dc4659dbda6d54f50a8c897647fb7c52e2b8200e741c4d6e25306dfe51f93bb6-Picture1.png" target="_blank" rel="noopener">Picture1.png</a></p><p><strong>重复方案与剪枝：</strong> 当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。</p><p><a href="https://pic.leetcode-cn.com/edbbe4db611791ca63e582e8b0c754261e8d7464edace38420ce3087eb96d9a5-Picture2.png" target="_blank" rel="noopener">Picture2.png</a></p><h2 id="递归解析："><a href="#递归解析：" class="headerlink" title="递归解析："></a>递归解析：</h2><ol><li><strong>终止条件：</strong> 当 <em>x = len(c) - 1</em>  时，代表所有位已固定（最后一位只有 <em>1</em> 种情况），则将当前组合 <code>c</code> 转化为字符串并加入 <code>res</code>，并返回；</li><li><strong>递推参数：</strong> 当前固定位 <em>x</em> ；</li><li><strong>递推工作：</strong> 初始化一个 Set ，用于排除重复的字符；将第 <em>x</em> 位字符与 i∈[x,len(c)]  字符分别交换，并进入下层递归；<ol><li><strong>剪枝：</strong> 若 <em>c[i]</em> 在 Set​ 中，代表其是重复字符，因此“剪枝”；</li><li>将 <em>c[i]</em> 加入 Set​ ，以便之后遇到重复字符时剪枝；</li><li><strong>固定字符：</strong> 将字符 <em>c[i]</em> 和 <em>c[x]</em> 交换，即固定 <em>c[i]</em> 为当前位字符；</li><li><strong>开启下层递归：</strong> 调用 <em>dfs(x + 1)</em> ，即开始固定第 <em>x + 1</em> 个字符；</li><li><strong>还原交换：</strong> 将字符 <em>c[i]</em> 和 <em>c[x]</em> 交换（还原之前的交换）；</li></ol></li></ol><blockquote><p>下图中 <code>list</code> 对应文中的列表 <em>c</em> 。</p></blockquote><p> <a href="https://pic.leetcode-cn.com/03ef0cdb9aa977a26d66bac91c5aa4b8bcaf612c7a90d47afd5b2774d2e7c63f-Picture3.png" target="_blank" rel="noopener">Picture3.png</a> <a href="https://pic.leetcode-cn.com/23190801938902294ce223fdec6e2b14b57c0050341dd2cd9909e5388d4fa4b6-Picture4.png" target="_blank" rel="noopener">Picture4.png</a> <a href="https://pic.leetcode-cn.com/5c71c17efa89114eee4d31678af45cefac82b0fad2a78c3887662463d10cfc83-Picture5.png" target="_blank" rel="noopener">Picture5.png</a> <a href="https://pic.leetcode-cn.com/a9d78bf7bdd7356d5c87392b731a98dc7012bb07c8a2bcde983abe7957bfde0a-Picture6.png" target="_blank" rel="noopener">Picture6.png</a> <a href="https://pic.leetcode-cn.com/546998a83a0832f3eed25ee69d1186ebcc23d238d0f45892feb02afd02bcaae9-Picture7.png" target="_blank" rel="noopener">Picture7.png</a> <a href="https://pic.leetcode-cn.com/405326ab9eccefe10fa18255704d0820ade5dd9b328a73b061634cfde8d059bd-Picture8.png" target="_blank" rel="noopener">Picture8.png</a> <a href="https://pic.leetcode-cn.com/59159c4b72187e1a4a52bebcd2b225a602badba483ef563114c9b1a7d694b0bf-Picture9.png" target="_blank" rel="noopener">Picture9.png</a> <a href="https://pic.leetcode-cn.com/d0e959953dcf93557e14cc037a0a1b62e60b3c0e3e38ca6b01f8acd06d4e5ea4-Picture10.png" target="_blank" rel="noopener">Picture10.png</a> <a href="https://pic.leetcode-cn.com/f34d4f405b2fb355fcad12d2c7818716b02ff78504e82be2343a1f7e75424eb3-Picture11.png" target="_blank" rel="noopener">Picture11.png</a> <a href="https://pic.leetcode-cn.com/58700b824790d48fe907fa6740f53d747e01cdd6d9c4b01cd60cad0135278d99-Picture12.png" target="_blank" rel="noopener">Picture12.png</a> <a href="https://pic.leetcode-cn.com/83dabfa3d9c04601ee53989ba410069153e841403584739140a499e8c4f3d8e1-Picture13.png" target="_blank" rel="noopener">Picture13.png</a> <a href="https://pic.leetcode-cn.com/337e2cdad2bcf4fd801ae2d4e5ab8a1c3ef8f30008d2b0fadde6aad7c87fd640-Picture14.png" target="_blank" rel="noopener">Picture14.png</a> <a href="https://pic.leetcode-cn.com/ba18b921c78d58e1f1c6fa55a939cbd4a2a9652c31f6c3088219565b70dc3b19-Picture15.png" target="_blank" rel="noopener">Picture15.png</a> <a href="https://pic.leetcode-cn.com/25d13a660956672f9d3b3a1fa87ddac8194fda6e58d7c354799d6421c61fab61-Picture16.png" target="_blank" rel="noopener">Picture16.png</a> <a href="https://pic.leetcode-cn.com/3efd2969a04b993303229c7e58a635fe3d018a84086b36e486f458d8f87d54cf-Picture17.png" target="_blank" rel="noopener">Picture17.png</a> </p><h2 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><ul><li><strong>时间复杂度 <em>O(N!)</em> ：</strong> <em>N</em> 为字符串 <code>s</code> 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为n<em>(n-1)</em>(n-2)<em>…<em>2</em>1 ，因此复杂度为 *O(N!)</em> 。</li><li><strong>空间复杂度 <em>O(N^2)</em> ：</strong> 全排列的递归深度为 <em>N</em> ，系统累计使用栈空间大小为 <em>O(N)</em> ；递归中辅助 Set 累计存储的字符数量最多为 <em>N + (N-1) + … + 2 + 1 = (N+1)N/2</em> ，即占用 <em>O(N^2)</em> 的额外空间。</li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        c, res = list(s), []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == len(c) - <span class="number">1</span>:</span><br><span class="line">                res.append(<span class="string">''</span>.join(c)) <span class="comment"># 添加排列方案</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dic = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(x, len(c)):</span><br><span class="line">                <span class="keyword">if</span> c[i] <span class="keyword">in</span> dic: <span class="keyword">continue</span> <span class="comment"># 重复，因此剪枝</span></span><br><span class="line">                dic.add(c[i])</span><br><span class="line">                c[i], c[x] = c[x], c[i] <span class="comment"># 交换，将 c[i] 固定在第 x 位</span></span><br><span class="line">                dfs(x + <span class="number">1</span>) <span class="comment"># 开启固定第 x + 1 位字符</span></span><br><span class="line">                c[i], c[x] = c[x], c[i] <span class="comment"># 恢复交换</span></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] c;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        c = s.toCharArray();</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == c.length - <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(String.valueOf(c)); <span class="comment">// 添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(c[i])) <span class="keyword">continue</span>; <span class="comment">// 重复，因此剪枝</span></span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            swap(i, x); <span class="comment">// 交换，将 c[i] 固定在第 x 位 </span></span><br><span class="line">            dfs(x + <span class="number">1</span>); <span class="comment">// 开启固定第 x + 1 位字符</span></span><br><span class="line">            swap(i, x); <span class="comment">// 恢复交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = c[a];</span><br><span class="line">        c[a] = c[b];</span><br><span class="line">        c[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Cracking the Coding Interview" scheme="http://yoursite.com/tags/Cracking-the-Coding-Interview/"/>
    
  </entry>
  
  <entry>
    <title>剑指 offer38.字符串的排列</title>
    <link href="http://yoursite.com/2020/10/10/%E5%89%91%E6%8C%87%20offer38.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2020/10/10/剑指 offer38.字符串的排列/</id>
    <published>2020-10-10T08:20:12.000Z</published>
    <updated>2020-10-10T08:45:01.402Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个字符串，打印出该字符串中字符的所有排列。</p><a id="more"></a><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例:</p><pre><code>输入：s = &quot;abc&quot;输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</code></pre><p>限制：</p><pre><code>1 &lt;= s 的长度 &lt;= 8</code></pre><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p><strong>排列方案数量：</strong> 对于一个长度为 <em>n</em> 的字符串（假设字符互不重复），其排列共有 n<em>(n-1)</em>(n-2)<em>…</em>2*1种方案。</p><p><strong>排列方案的生成方法：</strong> 根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 <em>1</em> 位字符（ <em>n</em> 种情况）、再固定第 <em>2</em> 位字符（ <em>n-1</em> 种情况）、… 、最后固定第 <em>n</em> 位字符（ <em>1</em> 种情况）。</p><p><a href="https://pic.leetcode-cn.com/dc4659dbda6d54f50a8c897647fb7c52e2b8200e741c4d6e25306dfe51f93bb6-Picture1.png" target="_blank" rel="noopener">Picture1.png</a></p><p><strong>重复方案与剪枝：</strong> 当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。</p><p><a href="https://pic.leetcode-cn.com/edbbe4db611791ca63e582e8b0c754261e8d7464edace38420ce3087eb96d9a5-Picture2.png" target="_blank" rel="noopener">Picture2.png</a></p><h2 id="递归解析："><a href="#递归解析：" class="headerlink" title="递归解析："></a>递归解析：</h2><ol><li><strong>终止条件：</strong> 当 <em>x = len(c) - 1</em>  时，代表所有位已固定（最后一位只有 <em>1</em> 种情况），则将当前组合 <code>c</code> 转化为字符串并加入 <code>res</code>，并返回；</li><li><strong>递推参数：</strong> 当前固定位 <em>x</em> ；</li><li><strong>递推工作：</strong> 初始化一个 Set ，用于排除重复的字符；将第 <em>x</em> 位字符与 i∈[x,len(c)]  字符分别交换，并进入下层递归；<ol><li><strong>剪枝：</strong> 若 <em>c[i]</em> 在 Set​ 中，代表其是重复字符，因此“剪枝”；</li><li>将 <em>c[i]</em> 加入 Set​ ，以便之后遇到重复字符时剪枝；</li><li><strong>固定字符：</strong> 将字符 <em>c[i]</em> 和 <em>c[x]</em> 交换，即固定 <em>c[i]</em> 为当前位字符；</li><li><strong>开启下层递归：</strong> 调用 <em>dfs(x + 1)</em> ，即开始固定第 <em>x + 1</em> 个字符；</li><li><strong>还原交换：</strong> 将字符 <em>c[i]</em> 和 <em>c[x]</em> 交换（还原之前的交换）；</li></ol></li></ol><blockquote><p>下图中 <code>list</code> 对应文中的列表 <em>c</em> 。</p></blockquote><p> <a href="https://pic.leetcode-cn.com/03ef0cdb9aa977a26d66bac91c5aa4b8bcaf612c7a90d47afd5b2774d2e7c63f-Picture3.png" target="_blank" rel="noopener">Picture3.png</a> <a href="https://pic.leetcode-cn.com/23190801938902294ce223fdec6e2b14b57c0050341dd2cd9909e5388d4fa4b6-Picture4.png" target="_blank" rel="noopener">Picture4.png</a> <a href="https://pic.leetcode-cn.com/5c71c17efa89114eee4d31678af45cefac82b0fad2a78c3887662463d10cfc83-Picture5.png" target="_blank" rel="noopener">Picture5.png</a> <a href="https://pic.leetcode-cn.com/a9d78bf7bdd7356d5c87392b731a98dc7012bb07c8a2bcde983abe7957bfde0a-Picture6.png" target="_blank" rel="noopener">Picture6.png</a> <a href="https://pic.leetcode-cn.com/546998a83a0832f3eed25ee69d1186ebcc23d238d0f45892feb02afd02bcaae9-Picture7.png" target="_blank" rel="noopener">Picture7.png</a> <a href="https://pic.leetcode-cn.com/405326ab9eccefe10fa18255704d0820ade5dd9b328a73b061634cfde8d059bd-Picture8.png" target="_blank" rel="noopener">Picture8.png</a> <a href="https://pic.leetcode-cn.com/59159c4b72187e1a4a52bebcd2b225a602badba483ef563114c9b1a7d694b0bf-Picture9.png" target="_blank" rel="noopener">Picture9.png</a> <a href="https://pic.leetcode-cn.com/d0e959953dcf93557e14cc037a0a1b62e60b3c0e3e38ca6b01f8acd06d4e5ea4-Picture10.png" target="_blank" rel="noopener">Picture10.png</a> <a href="https://pic.leetcode-cn.com/f34d4f405b2fb355fcad12d2c7818716b02ff78504e82be2343a1f7e75424eb3-Picture11.png" target="_blank" rel="noopener">Picture11.png</a> <a href="https://pic.leetcode-cn.com/58700b824790d48fe907fa6740f53d747e01cdd6d9c4b01cd60cad0135278d99-Picture12.png" target="_blank" rel="noopener">Picture12.png</a> <a href="https://pic.leetcode-cn.com/83dabfa3d9c04601ee53989ba410069153e841403584739140a499e8c4f3d8e1-Picture13.png" target="_blank" rel="noopener">Picture13.png</a> <a href="https://pic.leetcode-cn.com/337e2cdad2bcf4fd801ae2d4e5ab8a1c3ef8f30008d2b0fadde6aad7c87fd640-Picture14.png" target="_blank" rel="noopener">Picture14.png</a> <a href="https://pic.leetcode-cn.com/ba18b921c78d58e1f1c6fa55a939cbd4a2a9652c31f6c3088219565b70dc3b19-Picture15.png" target="_blank" rel="noopener">Picture15.png</a> <a href="https://pic.leetcode-cn.com/25d13a660956672f9d3b3a1fa87ddac8194fda6e58d7c354799d6421c61fab61-Picture16.png" target="_blank" rel="noopener">Picture16.png</a> <a href="https://pic.leetcode-cn.com/3efd2969a04b993303229c7e58a635fe3d018a84086b36e486f458d8f87d54cf-Picture17.png" target="_blank" rel="noopener">Picture17.png</a> </p><h2 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><ul><li><strong>时间复杂度 <em>O(N!)</em> ：</strong> <em>N</em> 为字符串 <code>s</code> 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为n<em>(n-1)</em>(n-2)<em>…<em>2</em>1 ，因此复杂度为 *O(N!)</em> 。</li><li><strong>空间复杂度 <em>O(N^2)</em> ：</strong> 全排列的递归深度为 <em>N</em> ，系统累计使用栈空间大小为 <em>O(N)</em> ；递归中辅助 Set 累计存储的字符数量最多为 <em>N + (N-1) + … + 2 + 1 = (N+1)N/2</em> ，即占用 <em>O(N^2)</em> 的额外空间。</li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        c, res = list(s), []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == len(c) - <span class="number">1</span>:</span><br><span class="line">                res.append(<span class="string">''</span>.join(c)) <span class="comment"># 添加排列方案</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dic = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(x, len(c)):</span><br><span class="line">                <span class="keyword">if</span> c[i] <span class="keyword">in</span> dic: <span class="keyword">continue</span> <span class="comment"># 重复，因此剪枝</span></span><br><span class="line">                dic.add(c[i])</span><br><span class="line">                c[i], c[x] = c[x], c[i] <span class="comment"># 交换，将 c[i] 固定在第 x 位</span></span><br><span class="line">                dfs(x + <span class="number">1</span>) <span class="comment"># 开启固定第 x + 1 位字符</span></span><br><span class="line">                c[i], c[x] = c[x], c[i] <span class="comment"># 恢复交换</span></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] c;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        c = s.toCharArray();</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == c.length - <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(String.valueOf(c)); <span class="comment">// 添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(c[i])) <span class="keyword">continue</span>; <span class="comment">// 重复，因此剪枝</span></span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            swap(i, x); <span class="comment">// 交换，将 c[i] 固定在第 x 位 </span></span><br><span class="line">            dfs(x + <span class="number">1</span>); <span class="comment">// 开启固定第 x + 1 位字符</span></span><br><span class="line">            swap(i, x); <span class="comment">// 恢复交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = c[a];</span><br><span class="line">        c[a] = c[b];</span><br><span class="line">        c[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入一个字符串，打印出该字符串中字符的所有排列。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Coding Interviews" scheme="http://yoursite.com/tags/Coding-Interviews/"/>
    
  </entry>
  
  <entry>
    <title>14. 最长公共前缀</title>
    <link href="http://yoursite.com/2020/10/09/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>http://yoursite.com/2020/10/09/14. 最长公共前缀/</id>
    <published>2020-10-09T07:52:12.000Z</published>
    <updated>2020-10-09T09:20:41.843Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串””。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;</code></pre><p>示例 2:</p><pre><code>输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。</code></pre><p>说明:</p><pre><code>所有输入只包含小写字母 a-z 。</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="8edae0a8-6480-4128-8244-9f10b83e7cf6">14 最长公共前缀.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：横向扫描"><a href="#方法一：横向扫描" class="headerlink" title="方法一：横向扫描"></a>方法一：横向扫描</h2><p>用 LCP(S1,…,Sn) 表示字符串S1,…,Sn 的最长公共前缀。</p><p>可以得到以下结论：</p><pre><code>LCP(S1,...,Sn)=LCP(LCP(LCP(S1,S2),S3),...Sn)</code></pre><p>基于该结论，可以得到一种查找字符串数组中的最长公共前缀的简单方法。依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。</p><p><a href="https://assets.leetcode-cn.com/solution-static/14/14_fig1.png" target="_blank" rel="noopener">fig1</a></p><p>如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。</p><details>    <summary>横向扫描Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">            prefix = longestCommonPrefix(prefix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = Math.min(str1.length(), str2.length());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>横向扫描C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = strs.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            prefix = longestCommonPrefix(prefix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (!prefix.size()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = min(str1.size(), str2.size());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; str1[index] == str2[index]) &#123;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substr(<span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>横向扫描Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        prefix, count = strs[<span class="number">0</span>], len(strs)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, count):</span><br><span class="line">            prefix = self.lcp(prefix, strs[i])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> prefix:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> prefix</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lcp</span><span class="params">(self, str1, str2)</span>:</span></span><br><span class="line">        length, index = min(len(str1), len(str2)), <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; length <span class="keyword">and</span> str1[index] == str2[index]:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> str1[:index]</span><br></pre></td></tr></table></figure></details><details>    <summary>横向扫描Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    prefix := strs[<span class="number">0</span>]</span><br><span class="line">    count := <span class="built_in">len</span>(strs)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; count; i++ &#123;</span><br><span class="line">        prefix = lcp(prefix, strs[i])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prefix) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lcp</span><span class="params">(str1, str2 <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    length := min(<span class="built_in">len</span>(str1), <span class="built_in">len</span>(str2))</span><br><span class="line">    index := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index &lt; length &amp;&amp; str1[index] == str2[index] &#123;</span><br><span class="line">        index++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str1[:index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(mn)*，其中 *m</em> 是字符串数组中的字符串的平均长度，<em>n</em> 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。</p></li><li><p>空间复杂度：<em>O(1)</em>。使用的额外空间复杂度为常数。</p></li></ul><h2 id="方法二：纵向扫描"><a href="#方法二：纵向扫描" class="headerlink" title="方法二：纵向扫描"></a>方法二：纵向扫描</h2><p>方法一是横向扫描，依次遍历每个字符串，更新最长公共前缀。另一种方法是纵向扫描。纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。</p><p><a href="https://assets.leetcode-cn.com/solution-static/14/14_fig2.png" target="_blank" rel="noopener">fig2</a></p><details>    <summary>纵向扫描Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; count; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>纵向扫描C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = strs[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> count = strs.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; count; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].size() || strs[j][i] != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>纵向扫描Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        length, count = len(strs[<span class="number">0</span>]), len(strs)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            c = strs[<span class="number">0</span>][i]</span><br><span class="line">            <span class="keyword">if</span> any(i == len(strs[j]) <span class="keyword">or</span> strs[j][i] != c <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, count)):</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></details><details>    <summary>纵向扫描Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(strs[<span class="number">0</span>]); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="built_in">len</span>(strs); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(strs[j]) || strs[j][i] != strs[<span class="number">0</span>][i] &#123;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(mn)*，其中 *m</em> 是字符串数组中的字符串的平均长度，<em>n</em> 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。</p></li><li><p>空间复杂度：<em>O(1)</em>。使用的额外空间复杂度为常数。</p></li></ul><h2 id="方法三：分治"><a href="#方法三：分治" class="headerlink" title="方法三：分治"></a>方法三：分治</h2><p>注意到 LCP 的计算满足结合律，有以下结论：</p><pre><code>LCP(S1,...,Sn)=LCP(LCP(S1...SK) , LCP(SK+1...Sn))</code></pre><p>其中 LCP(S1,…,Sn) 是字符串 S1,…,Sn 的最长公共前缀，<em>1 &lt; k &lt; n</em>。</p><p>基于上述结论，可以使用分治法得到字符串数组中的最长公共前缀。对于问题LCP(Si…Sj) ，可以分解成两个子问题 LCP(si…Smid)与LCP(Smid+1…Sj)，其中 mid=(i+j)/2 。对两个子问题分别求解，然后对两个子问题的解计算最长公共前缀，即为原问题的解。</p><p><a href="https://assets.leetcode-cn.com/solution-static/14/14_fig3.png" target="_blank" rel="noopener">fig3</a></p><details>    <summary>分治Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span>, strs.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[start];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">            String lcpLeft = longestCommonPrefix(strs, start, mid);</span><br><span class="line">            String lcpRight = longestCommonPrefix(strs, mid + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">commonPrefix</span><span class="params">(String lcpLeft, String lcpRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minLength = Math.min(lcpLeft.length(), lcpRight.length());       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minLength; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lcpLeft.charAt(i) != lcpRight.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> lcpLeft.substring(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcpLeft.substring(<span class="number">0</span>, minLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>分治C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span>, strs.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">string</span> lcpLeft = longestCommonPrefix(strs, start, mid);</span><br><span class="line">            <span class="built_in">string</span> lcpRight = longestCommonPrefix(strs, mid + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">commonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; lcpLeft, <span class="keyword">const</span> <span class="built_in">string</span>&amp; lcpRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minLength = min(lcpLeft.size(), lcpRight.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minLength; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lcpLeft[i] != lcpRight[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> lcpLeft.substr(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcpLeft.substr(<span class="number">0</span>, minLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>分治Python3</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">lcp</span><span class="params">(start, end)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start == end:</span><br><span class="line">                <span class="keyword">return</span> strs[start]</span><br><span class="line"></span><br><span class="line">            mid = (start + end) // <span class="number">2</span></span><br><span class="line">            lcpLeft, lcpRight = lcp(start, mid), lcp(mid + <span class="number">1</span>, end)</span><br><span class="line">            minLength = min(len(lcpLeft), len(lcpRight))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(minLength):</span><br><span class="line">                <span class="keyword">if</span> lcpLeft[i] != lcpRight[i]:</span><br><span class="line">                    <span class="keyword">return</span> lcpLeft[:i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> lcpLeft[:minLength]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span> <span class="keyword">if</span> <span class="keyword">not</span> strs <span class="keyword">else</span> lcp(<span class="number">0</span>, len(strs) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></details><details>    <summary>分治Golang</summary><figure class="highlight golang"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> lcp <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function">    <span class="title">lcp</span> = <span class="title">func</span><span class="params">(start, end <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start == end &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[start]</span><br><span class="line">        &#125;</span><br><span class="line">        mid := (start + end) / <span class="number">2</span></span><br><span class="line">        lcpLeft, lcpRight := lcp(start, mid), lcp(mid + <span class="number">1</span>, end)</span><br><span class="line">        minLength := min(<span class="built_in">len</span>(lcpLeft), <span class="built_in">len</span>(lcpRight))</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; minLength; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> lcpLeft[i] != lcpRight[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> lcpLeft[:i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcpLeft[:minLength]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lcp(<span class="number">0</span>, <span class="built_in">len</span>(strs)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：<em>O(mn)*，其中 *m</em> 是字符串数组中的字符串的平均长度，<em>n</em> 是字符串的数量。时间复杂度的递推式是 T(n)=2T(n/2)+O(m)，通过计算可得 <em>T(n)=O(mn)</em>。</p></li><li><p>空间复杂度：O(mlogn) ，其中 <em>m</em> 是字符串数组中的字符串的平均长度，<em>n</em> 是字符串的数量。空间复杂度主要取决于递归调用的层数，层数最大为 logn，每层需要 <em>m</em> 的空间存储返回结果。</p></li></ul><h2 id="方法四：二分查找"><a href="#方法四：二分查找" class="headerlink" title="方法四：二分查找"></a>方法四：二分查找</h2><p>显然，最长公共前缀的长度不会超过字符串数组中的最短字符串的长度。用 minLength表示字符串数组中的最短字符串的长度，则可以在 [0,minLength] 的范围内通过二分查找得到最长公共前缀的长度。每次取查找范围的中间值mid，判断每个字符串的长度为 mid 的前缀是否相同，如果相同则最长公共前缀的长度一定大于或等于 mid，如果不相同则最长公共前缀的长度一定小于 mid ，通过上述方式将查找范围缩小一半，直到得到最长公共前缀的长度。</p><p><a href="https://assets.leetcode-cn.com/solution-static/14/14_fig4.png" target="_blank" rel="noopener">fig4</a></p><details>    <summary>二分查找Java</summary><figure class="highlight java"><figcaption><span>[sol4-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minLength = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            minLength = Math.min(minLength, str.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = minLength;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (isCommonPrefix(strs, mid)) &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, low);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        String str0 = strs[<span class="number">0</span>].substring(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">            String str = strs[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str0.charAt(j) != str.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找C++</summary><figure class="highlight c++"><figcaption><span>[sol4-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minLength = min_element(strs.begin(), strs.end(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">const</span> <span class="built_in">string</span>&amp; t) &#123;<span class="keyword">return</span> s.size() &lt; t.size();&#125;)-&gt;size();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = minLength;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (isCommonPrefix(strs, mid)) &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, low);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCommonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str0 = strs[<span class="number">0</span>].substr(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">int</span> count = strs.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> str = strs[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str0[j] != str[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Python3</summary><figure class="highlight python"><figcaption><span>[sol4-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isCommonPrefix</span><span class="params">(length)</span>:</span></span><br><span class="line">            str0, count = strs[<span class="number">0</span>][:length], len(strs)</span><br><span class="line">            <span class="keyword">return</span> all(strs[i][:length] == str0 <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, count))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        minLength = min(len(s) <span class="keyword">for</span> s <span class="keyword">in</span> strs)</span><br><span class="line">        low, high = <span class="number">0</span>, minLength</span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = (high - low + <span class="number">1</span>) // <span class="number">2</span> + low</span><br><span class="line">            <span class="keyword">if</span> isCommonPrefix(mid):</span><br><span class="line">                low = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>][:low]</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Golang</summary><figure class="highlight golang"><figcaption><span>[sol4-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isCommonPrefix := <span class="function"><span class="keyword">func</span><span class="params">(length <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        str0, count := strs[<span class="number">0</span>][:length], <span class="built_in">len</span>(strs)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; count; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> strs[i][:length] != str0 &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    minLength := <span class="built_in">len</span>(strs[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> strs &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; minLength &#123;</span><br><span class="line">            minLength = <span class="built_in">len</span>(s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    low, high := <span class="number">0</span>, minLength</span><br><span class="line">    <span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">        mid := (high - low + <span class="number">1</span>) / <span class="number">2</span> + low</span><br><span class="line">        <span class="keyword">if</span> isCommonPrefix(mid) &#123;</span><br><span class="line">            low = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>][:low]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：O(mnlogm)，其中 <em>m</em> 是字符串数组中的字符串的最小长度，<em>n</em> 是字符串的数量。二分查找的迭代执行次数是 O(logm)  ，每次迭代最多需要比较 <em>mn</em> 个字符，因此总时间复杂度是O(mnlogm) 。</p></li><li><p>空间复杂度：<em>O(1)</em>。使用的额外空间复杂度为常数。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串””。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>567. 字符串的排列</title>
    <link href="http://yoursite.com/2020/10/09/567.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2020/10/09/567. 字符串的排列/</id>
    <published>2020-10-09T07:52:12.000Z</published>
    <updated>2020-10-10T07:12:25.325Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p><a id="more"></a><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><p>示例1:</p><pre><code>输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;输出: True解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</code></pre><p>示例2:</p><pre><code>输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;输出: False</code></pre><p>注意：</p><pre><code>输入的字符串只包含小写字母两个字符串的长度都在 [1, 10,000] 之间</code></pre><h1 id="方法一-暴力-超过时间限制"><a href="#方法一-暴力-超过时间限制" class="headerlink" title="方法一 暴力 [超过时间限制]"></a>方法一 暴力 [超过时间限制]</h1><p><strong>算法</strong></p><p>最简单的方法是生成短字符串的所有排列，并检查生成的排列是否是较长字符串的子字符串。</p><p>为了生成所有可能的配对，我们使用函数<code>permute（string_1，string_2，current_index）</code>。此函数创建短字符串 <em>s1</em> 的所有可能排列。</p><p>为此，permute将当前元素 <em>current_index</em> 的索引作为参数之一。然后，它将当前元素与数组中的每个其他元素交换，向右移动，以便生成数组元素的新排序。完成交换后，它会再次调用置换，但这次使用数组中下一个元素的索引。返回时，我们反转当前函数调用中的交换。</p><p>因此，当我们到达数组的末尾时，会生成数组元素的新排序。以下动画描述了生成排列的过程。</p><p> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide1.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide2.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide3.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide4.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide5.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide6.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide7.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide8.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide9.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide10.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide11.PNG" target="_blank" rel="noopener">1200</a> </p><details>    <summary>暴力</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        permute(s1, s2, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">swap</span><span class="params">(String s, <span class="keyword">int</span> i0, <span class="keyword">int</span> i1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i0 == i1)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        String s1 = s.substring(<span class="number">0</span>, i0);</span><br><span class="line">        String s2 = s.substring(i0 + <span class="number">1</span>, i1);</span><br><span class="line">        String s3 = s.substring(i1 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> s1 + s.charAt(i1) + s2 + s.charAt(i0) + s3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(String s1, String s2, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == s1.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2.indexOf(s1) &gt;= <span class="number">0</span>)</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; s1.length(); i++) &#123;</span><br><span class="line">                s1 = swap(s1, l, i);</span><br><span class="line">                permute(s1, s2, l + <span class="number">1</span>);</span><br><span class="line">                s1 = swap(s1, l, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n!)*。我们将 *s1</em> 的短字符串 <em>s1</em> 的所有排列与 <em>s2</em> 匹配。这里，<em>n</em> 指的是 <em>s1</em> 的长度。</p></li><li><p>空间复杂度：<em>O(n^2)<em>。递归树的深度是 *n</em>（*n</em> 是指短字符串 <em>s1</em> 的长度）。递归树的每个节点都包含一个 max 的字符串。长度 <em>n</em>。</p></li></ul><hr><h2 id="方法二-排序-超过时间限制"><a href="#方法二-排序-超过时间限制" class="headerlink" title="方法二 排序 [超过时间限制]:"></a>方法二 排序 [超过时间限制]:</h2><p><strong>算法</strong></p><p>这种方法背后的想法是，只有当两个字符串包含相同次数的相同字符时，一个字符串才是另一个字符串的排列。只有<em>sorted(x)= sorted(y)<em>时，一个字符串</em>x*才​​是其他字符串 *y</em> 的排列。</p><p>为了检查这一点，我们可以对两个字符串进行排序并进行比较。我们对短字符串 <em>s1</em> 和 <em>s2</em> 的所有子字符串进行排序，对它们进行排序并将它们与排序的 <em>s1</em> 字符串进行比较。如果两者完全匹配，<em>s1</em> 的排列是 <em>s2</em> 的子字符串，否则不是。</p><details>    <summary>排序</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        s1 = sort(s1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.equals(sort(s2.substring(i, i + s1.length()))))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] t = s.toCharArray();</span><br><span class="line">        Arrays.sort(t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(l1log(l1)+(l2-l1)l1log(l1))。其中 <em>l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：<em>O(l_1)*。使用了 *t</em> 数组。</p></li></ul><hr><h2 id="方法三-使用哈希表-超过时间限制"><a href="#方法三-使用哈希表-超过时间限制" class="headerlink" title="方法三 使用哈希表 [超过时间限制]"></a>方法三 使用哈希表 [超过时间限制]</h2><p><strong>算法</strong></p><p>如上所述，只有当两个字符串包含具有相同频率的相同字符时，一个字符串才是另一个字符串的排列。我们可以考虑与 <em>s1</em> 长度相同的长字符串 <em>s2</em> 中的每个可能的子字符串，并检查出现在两者中的字符出现的频率。如果每个字母的频率完全匹配，则只有 <em>s1</em> 的排列可以是 <em>s2</em> 的子字符串。</p><p>为了实现这种方法，我们不使用排序然后比较元素的相等性，而是使用一个哈希表 <em>s1map*来存储短字符串 *s1</em> 中所有字符的出现频率。我们考虑 <em>s2</em> 的每个可能的子串，其长度与 <em>s1</em> 的长度相同，也可以找到相应的哈希表，即 <em>s2map*。因此，所考虑的子字符串可以被视为一个长度窗口，如 *s1</em> 迭代超过 <em>s2*。如果获得的两个哈希表对于任何这样的窗口是相同的，我们可以得出结论 *s1</em> 的排列是 <em>s2</em> 的子字符串，否则不是。</p><details>    <summary>使用哈希表</summary><figure class="highlight java"><figcaption><span>[solution3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        s1 = sort(s1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.equals(sort(s2.substring(i, i + s1.length()))))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] t = s.toCharArray();</span><br><span class="line">        Arrays.sort(t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(l_1+26*l_1</em>(l_2-l_1))<em>。这个哈希表包含最多26个键。其中 *l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</li><li>空间复杂度：<em>O(1)</em>。表包含最多 26 个键值对。</li></ul><hr><h2 id="方法四-使用数组-通过"><a href="#方法四-使用数组-通过" class="headerlink" title="方法四 使用数组 [通过]"></a>方法四 使用数组 [通过]</h2><p><strong>算法</strong></p><p>我们可以使用更简单的数组数据结构来存储频率，而不是仅使用特殊的哈希表数据结构来存储字符出现的频率。给定字符串仅包含小写字母（’a’到’z’）。因此我们需要采用大小为 26 的数组。其余过程与最后一种方法保持一致。</p><details>    <summary>使用数组</summary><figure class="highlight java"><figcaption><span>[solution-4]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++)</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s1.length(); j++) &#123;</span><br><span class="line">                s2map[s2.charAt(i + j) - <span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matches(s1map, s2map))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(<span class="keyword">int</span>[] s1map, <span class="keyword">int</span>[] s2map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] != s2map[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li><p>时间复杂度：<em>O(l_1+26*l_1</em>(l_2-l_1))<em>。其中 *l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：<em>O(1)*。使用 *s1map</em> 和 <em>s2map</em>，大小为 26。</p></li></ul><hr><h2 id="方法五-滑动窗口-通过"><a href="#方法五-滑动窗口-通过" class="headerlink" title="方法五 滑动窗口  [通过]:"></a>方法五 滑动窗口  [通过]:</h2><p><strong>算法</strong></p><p>我们可以为 <em>s2</em> 中的第一个窗口创建一次哈希表，而不是为 <em>s2</em> 中考虑的每个窗口重新生成哈希表。然后，稍后当我们滑动窗口时，我们知道我们添加了一个前面的字符并将新的后续字符添加到所考虑的新窗口中。因此，我们可以通过仅更新与这两个字符相关联的索引来更新哈希表。同样，对于每个更新的哈希表，我们将哈希表的所有元素进行比较以获得所需的结果。</p><details>    <summary>使用数组</summary><figure class="highlight java"><figcaption><span>[solution5-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matches(s1map, s2map))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            s2map[s2.charAt(i + s1.length()) - <span class="string">'a'</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matches(s1map, s2map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(<span class="keyword">int</span>[] s1map, <span class="keyword">int</span>[] s2map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] != s2map[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度分析：<em>O(l_1+26</em>(l_2-l_1))<em>。其中 *l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：<em>O(1)</em>。常数级空间。</p></li></ul><hr><h2 id="方法六-优化的滑动窗口-通过"><a href="#方法六-优化的滑动窗口-通过" class="headerlink" title="方法六 优化的滑动窗口 [通过]:"></a>方法六 优化的滑动窗口 [通过]:</h2><p><strong>算法</strong></p><p>上一种方法可以优化，如果不是比较每个更新的 <em>s2map</em> 的哈希表的所有元素，而是对应于 <em>s2</em> 考虑的每个窗口，我们会跟踪先前哈希表中已经匹配的元素数量当我们向右移动窗口时，只更新匹配元素的数量。</p><p>为此，我们维护一个 <em>count</em> 变量，该变量存储字符数（26个字母表中的数字），这些字符在 <em>s1</em> 中具有相同的出现频率，当前窗口在 <em>s2</em> 中。当我们滑动窗口时，如果扣除最后一个元素并添加新元素导致任何字符的新频率匹配，我们将 <em>count</em> 递增1.如果不是，我们保持 <em>count</em> 完整。但是，如果添加频率相同的字符（添加和删除之前）相同的字符，现在会导致频率不匹配，这会通过递减相同的 <em>count</em> 变量来考虑。如果在移动窗口后，<em>count</em> 的计算结果为26，则表示所有字符的频率完全匹配。所以，我们立即返回一个True。</p><details>    <summary>使用数组</summary><figure class="highlight java"><figcaption><span>[solution6-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] == s2map[i])</span><br><span class="line">                count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = s2.charAt(i + s1.length()) - <span class="string">'a'</span>, l = s2.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">26</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            s2map[r]++;</span><br><span class="line">            <span class="keyword">if</span> (s2map[r] == s1map[r])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s2map[r] == s1map[r] + <span class="number">1</span>)</span><br><span class="line">                count--;</span><br><span class="line">            s2map[l]--;</span><br><span class="line">            <span class="keyword">if</span> (s2map[l] == s1map[l])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s2map[l] == s1map[l] - <span class="number">1</span>)</span><br><span class="line">                count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(l_1+(l_2-l_1))*。其中 *l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：<em>O(1)</em>。常数级的空间。</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>784. 字母大小写全排列</title>
    <link href="http://yoursite.com/2020/10/09/784.%20%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2020/10/09/784. 字母大小写全排列/</id>
    <published>2020-10-09T07:52:12.000Z</published>
    <updated>2020-10-12T02:55:37.143Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。</p><a id="more"></a><p>示例：<br>    输入：S = “a1b2”<br>    输出：[“a1b2”, “a1B2”, “A1b2”, “A1B2”]</p><pre><code>输入：S = &quot;3z4&quot;输出：[&quot;3z4&quot;, &quot;3Z4&quot;]输入：S = &quot;12345&quot;输出：[&quot;12345&quot;]</code></pre><p>提示：</p><pre><code>S 的长度不超过12。S 仅由数字和字母组成。</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="回溯【超时】"><a href="#回溯【超时】" class="headerlink" title="回溯【超时】"></a>回溯【超时】</h2><p>我首先想到参考全排列的回溯方法来做，但是超时了，因为没有很好的剪枝。</p><details>    <summary>回溯Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">    HashSet&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">    char[] c;</span><br><span class="line">    public List&lt;String&gt; letterCasePermutation(String S) &#123;</span><br><span class="line">        c = S.toCharArray();</span><br><span class="line">        dfs(0);</span><br><span class="line">        for (String s : set) &#123;</span><br><span class="line">            res.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(int x) &#123;</span><br><span class="line">        for (int i = x; i &lt; c.length; i++) &#123;</span><br><span class="line">            if (i == c.length - 1) &#123;</span><br><span class="line">                set.add(String.valueOf(c));</span><br><span class="line">                letterCase(i);</span><br><span class="line">                set.add(String.valueOf(c));</span><br><span class="line">            &#125;</span><br><span class="line">            letterCase(i);</span><br><span class="line">            dfs(x + 1);</span><br><span class="line">            letterCase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void letterCase(int i) &#123;</span><br><span class="line">        if (Character.isDigit(c[i])) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (Character.isLowerCase(c[i])) &#123;</span><br><span class="line">            c[i] = Character.toUpperCase(c[i]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            c[i] = Character.toLowerCase(c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="递归【通过】"><a href="#递归【通过】" class="headerlink" title="递归【通过】"></a>递归【通过】</h2><p><strong>思路</strong></p><p>从左往右依次遍历字符，过程中保持 <code>ans</code> 为已遍历过字符的字母大小全排列。</p><p>例如，当 <code>S = &quot;abc&quot;</code> 时，考虑字母 <code>&quot;a&quot;, &quot;b&quot;, &quot;c&quot;</code>，初始令 <code>ans = [&quot;&quot;]</code>，依次更新 <code>ans = [&quot;a&quot;, &quot;A&quot;]</code>， <code>ans = [&quot;ab&quot;, &quot;Ab&quot;, &quot;aB&quot;, &quot;AB&quot;]</code>， <code>ans = [&quot;abc&quot;, &quot;Abc&quot;, &quot;aBc&quot;, &quot;ABc&quot;, &quot;abC&quot;, &quot;AbC&quot;, &quot;aBC&quot;, &quot;ABC&quot;]</code>。</p><p><strong>算法</strong></p><p>如果下一个字符 <code>c</code> 是字母，将当前已遍历过的字符串全排列复制两份，在第一份的每个字符串末尾添加 <code>lowercase(c)</code>，在第二份的每个字符串末尾添加 <code>uppercase(c)</code>。</p><p>如果下一个字符 <code>c</code> 是数字，将 <code>c</code> 直接添加到每个字符串的末尾。</p><details>    <summary>递归Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;StringBuilder&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ans.add(<span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : S.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = ans.size();</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetter(c)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="comment">//将当前已遍历过的字符串全排列复制两份</span></span><br><span class="line">                    ans.add(<span class="keyword">new</span> StringBuilder(ans.get(i)));</span><br><span class="line">                    <span class="comment">//在第一份的每个字符串末尾添加 lowercase(c)</span></span><br><span class="line">                    ans.get(i).append(Character.toLowerCase(c));</span><br><span class="line">                    <span class="comment">//在第二份的每个字符串末尾添加 uppercase(c)</span></span><br><span class="line">                    ans.get(n + i).append(Character.toUpperCase(c));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    ans.get(i).append(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; finalans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (StringBuilder sb : ans) &#123;</span><br><span class="line">            finalans.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>递归Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCasePermutation</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        ans = [[]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> S:</span><br><span class="line">            n = len(ans)</span><br><span class="line">            <span class="keyword">if</span> char.isalpha():</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">                    ans.append(ans[i][:])</span><br><span class="line">                    ans[i].append(char.lower())</span><br><span class="line">                    ans[n+i].append(char.upper())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">                    ans[i].append(char)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map(<span class="string">""</span>.join, ans)</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(2^{N} * N)*，其中 *N</em> 是 <code>S</code> 的长度。</p></li><li><p>空间复杂度：<em>O(2^N * N)</em>。</p></li></ul><h2 id="二分掩码【通过】"><a href="#二分掩码【通过】" class="headerlink" title="二分掩码【通过】"></a>二分掩码【通过】</h2><p><strong>思路</strong></p><p>假设字符串 <code>S</code> 有 <em>B</em> 个字母，那么全排列就有 <em>2^B</em> 个字符串，且可以用位掩码 <code>bits</code> 唯一地表示。</p><p>例如，可以用 <code>00</code> 表示 <code>a7b</code>， <code>01</code> 表示 <code>a7B</code>， <code>10</code> 表示 <code>A7b</code>， <code>11</code> 表示 <code>A7B</code>。注意数字不是掩码的一部分。</p><p><strong>算法</strong></p><p>根据位掩码，构造正确的全排列结果。如果下一个字符是字母，则根据位掩码添加小写或大写字母。 否则添加对应的数字。</p><details>    <summary>二分掩码Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> B = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: S.toCharArray())</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetter(c))</span><br><span class="line">                B++;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> bits = <span class="number">0</span>; bits &lt; <span class="number">1</span>&lt;&lt;B; bits++) &#123;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            StringBuilder word = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> letter: S.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Character.isLetter(letter)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((bits &gt;&gt; b++) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                        word.append(Character.toLowerCase(letter));</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        word.append(Character.toUpperCase(letter));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    word.append(letter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans.add(word.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分掩码Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCasePermutation</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        B = sum(letter.isalpha() <span class="keyword">for</span> letter <span class="keyword">in</span> S)</span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> bits <span class="keyword">in</span> xrange(<span class="number">1</span> &lt;&lt; B):</span><br><span class="line">            b = <span class="number">0</span></span><br><span class="line">            word = []</span><br><span class="line">            <span class="keyword">for</span> letter <span class="keyword">in</span> S:</span><br><span class="line">                <span class="keyword">if</span> letter.isalpha():</span><br><span class="line">                    <span class="keyword">if</span> (bits &gt;&gt; b) &amp; <span class="number">1</span>:</span><br><span class="line">                        word.append(letter.lower())</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        word.append(letter.upper())</span><br><span class="line"></span><br><span class="line">                    b += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    word.append(letter)</span><br><span class="line"></span><br><span class="line">            ans.append(<span class="string">""</span>.join(word))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间和空间复杂度：<em>O(2^{N} * N)</em>，与方法一分析相同。</li></ul><h2 id="内置函数库【通过】"><a href="#内置函数库【通过】" class="headerlink" title="内置函数库【通过】"></a>内置函数库【通过】</h2><p><strong>思路和算法</strong></p><p>集合的笛卡尔乘积是从所有集合中选择每种可能的组合。例如 <code>{1, 2} x {a, b, c} = {1a, 1b, 1c, 2a, 2b, 2c}</code>。</p><p>对于具有内置函数来计算笛卡尔积的语言，可以直接调用内置函数减少工作量。</p><figure class="highlight python"><figcaption><span>[solution3-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCasePermutation</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        f = <span class="keyword">lambda</span> x: (x.lower(), x.upper()) <span class="keyword">if</span> x.isalpha() <span class="keyword">else</span> x</span><br><span class="line">        <span class="keyword">return</span> map(<span class="string">""</span>.join, itertools.product(*map(f, S)))</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间和空间复杂度：<em>O(2^{N} * N)</em>，与方法一分析相同。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <link href="http://yoursite.com/2020/10/09/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/10/09/3. 无重复字符的最长子串/</id>
    <published>2020-10-09T04:03:12.000Z</published>
    <updated>2020-10-09T07:51:33.609Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p>示例 2:</p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p>示例 3:</p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="fc6033f3-e9c6-41d7-b660-328fc288d2e2">3. 无重复字符的最长子串_2.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h2><p>我一开始想到的是一个比较粗暴的方法，遍历字符串中的每一个位置，然后在该位置向两边扩展，直到遇到重复的字符，最后统计长度，但这种方法效率较低</p><details>    <summary>暴力解法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int maxlen = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            int j = i ;</span><br><span class="line">            int k = i ;</span><br><span class="line">            while (j &gt; 0) &#123;</span><br><span class="line">                if (s.substring(j, k + 1).contains(s.substring(j-1,j))) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            while (k &lt; s.length()-1) &#123;</span><br><span class="line">                if (s.substring(j, k+1).contains(s.substring(k + 1,k+2))) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxlen = Math.max(maxlen, k - j + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="方法二：滑动窗口"><a href="#方法二：滑动窗口" class="headerlink" title="方法二：滑动窗口"></a>方法二：滑动窗口</h2><p><strong>思路和算法</strong></p><p>我们先用一个例子来想一想如何在较优的时间复杂度内通过本题。</p><p>我们不妨以示例一中的字符串 abcabcbb  为例，找出 <strong>从每一个字符开始的，不包含重复字符的最长子串</strong>，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p><ul><li>以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；</li><li>以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb ；</li><li>以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb ；</li><li>以 abc(a)bcbb  开始的最长字符串为 abc(abc)bb ；</li><li>以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；</li><li>以 abcab(c)bb  开始的最长字符串为abcab(cb)b ；</li><li>以 abcabc(b)b  开始的最长字符串为 abcabc(b)b ；</li><li>以 abcabcb(b) 开始的最长字符串为 abcabcb(b) 。</li></ul><p>发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 <em>k</em> 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 <em>r_k*。那么当我们选择第 *k+1</em> 个字符作为起始位置时，首先从 <em>k+1</em> 到 <em>r_k</em> 的字符显然是不重复的，并且由于少了原本的第 <em>k</em> 个字符，我们可以尝试继续增大 <em>r_k</em>，直到右侧出现了重复字符为止。</p><p>这样以来，我们就可以使用「滑动窗口」来解决这个问题了：</p><ul><li><p>我们使用两个指针表示字符串中的某个子串（的左右边界）。其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 <em>r_k</em>；</p></li><li><p>在每一步的操作中，我们会将左指针向右移动一格，表示 <strong>我们开始枚举下一个字符作为起始位置</strong>，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 <strong>以左指针开始的，不包含重复字符的最长子串</strong>。我们记录下这个子串的长度；</p></li><li><p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p></li></ul><p><strong>判断重复字符</strong></p><p>在上面的流程中，我们还需要使用一种数据结构来判断 <strong>是否有重复的字符</strong>，常用的数据结构为哈希集合（即 <code>C++</code> 中的 <code>std::unordered_set</code>，<code>Java</code> 中的 <code>HashSet</code>，<code>Python</code> 中的 <code>set</code>, <code>JavaScript</code> 中的 <code>Set</code>）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。</p><p>至此，我们就完美解决了本题。</p><details>    <summary>滑动窗口C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; occ;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="keyword">int</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.erase(s[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.count(s[rk + <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.insert(s[rk + <span class="number">1</span>]);</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        Set&lt;Character&gt; occ = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="keyword">int</span> rk = -<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.contains(s.charAt(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.add(s.charAt(rk + <span class="number">1</span>));</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = Math.max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        occ = set()</span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="comment"># 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        rk, ans = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> rk + <span class="number">1</span> &lt; n <span class="keyword">and</span> s[rk + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> occ:</span><br><span class="line">                <span class="comment"># 不断地移动右指针</span></span><br><span class="line">                occ.add(s[rk + <span class="number">1</span>])</span><br><span class="line">                rk += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = max(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">    <span class="keyword">const</span> occ = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">const</span> n = s.length;</span><br><span class="line">    <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    <span class="keyword">let</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">            occ.delete(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.has(s.charAt(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="comment">// 不断地移动右指针</span></span><br><span class="line">            occ.add(s.charAt(rk + <span class="number">1</span>));</span><br><span class="line">            ++rk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = <span class="built_in">Math</span>.max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    rk, ans := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">            <span class="built_in">delete</span>(m, s[i<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> rk + <span class="number">1</span> &lt; n &amp;&amp; m[s[rk+<span class="number">1</span>]] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 不断地移动右指针</span></span><br><span class="line">            m[s[rk+<span class="number">1</span>]]++</span><br><span class="line">            rk++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = max(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)*，其中 *N</em> 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p></li><li><p>空间复杂度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(|\Sigma|)</span><br></pre></td></tr></table></figure></li></ul><p>，其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Sigma</span><br></pre></td></tr></table></figure><p> 表示字符集（即字符串中可以出现的字符），</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|\Sigma|</span><br></pre></td></tr></table></figure><p> 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 <em>[0, 128)</em> 内的字符，即<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|\Sigma|=128</span><br><span class="line">``` </span><br><span class="line">。我们需要用到哈希集合来存储出现过的字符，而字符最多有 </span><br><span class="line">```math</span><br><span class="line">|\Sigma|</span><br></pre></td></tr></table></figure></p><p>个，因此空间复杂度为 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(|\Sigma|)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>146. LRU缓存机制</title>
    <link href="http://yoursite.com/2020/10/06/146.%20LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/10/06/146. LRU缓存机制/</id>
    <published>2020-10-06T02:03:12.000Z</published>
    <updated>2020-10-06T11:23:41.870Z</updated>
    
    <content type="html"><![CDATA[<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。</p><a id="more"></a><p>它应该支持以下操作： </p><pre><code>获取数据 get 和 写入数据 put 。获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</code></pre><p>进阶:</p><pre><code>你是否可以在 O(1) 时间复杂度内完成这两种操作？</code></pre><p>示例:</p><pre><code>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1);       // 返回  1cache.put(3, 3);    // 该操作会使得关键字 2 作废cache.get(2);       // 返回 -1 (未找到)cache.put(4, 4);    // 该操作会使得关键字 1 作废cache.get(1);       // 返回 -1 (未找到)cache.get(3);       // 返回  3cache.get(4);       // 返回  4</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="42b5ca6a-4d69-4f7d-bf63-5c196aa23b44">146. LRU缓存机制.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实现本题的两种操作，需要用到一个哈希表和一个双向链表。在面试中，面试官一般会期望读者能够自己实现一个简单的双向链表，而不是使用语言自带的、封装好的数据结构。在 <code>Python</code> 语言中，有一种结合了哈希表与双向链表的数据结构 <code>OrderedDict</code>，只需要短短的几行代码就可以完成本题。在 <code>Java</code> 语言中，同样有类似的数据结构 <code>LinkedHashMap</code>。这些做法都不会符合面试官的要求，因此下面只给出使用封装好的数据结构实现的代码，而不多做任何阐述。</p><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol0-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(collections.OrderedDict)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.capacity = capacity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        self.move_to_end(key)</span><br><span class="line">        <span class="keyword">return</span> self[key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            self.move_to_end(key)</span><br><span class="line">        self[key] = value</span><br><span class="line">        <span class="keyword">if</span> len(self) &gt; self.capacity:</span><br><span class="line">            self.popitem(last=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol0-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="方法一：哈希表-双向链表"><a href="#方法一：哈希表-双向链表" class="headerlink" title="方法一：哈希表 + 双向链表"></a>方法一：哈希表 + 双向链表</h2><p><strong>算法</strong></p><p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p><ul><li><p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p></li><li><p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p></li></ul><p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 <em>O(1)</em> 的时间内完成 <code>get</code> 或者 <code>put</code> 操作。具体的方法如下：</p><ul><li><p>对于 <code>get</code> 操作，首先判断 <code>key</code> 是否存在：</p><ul><li><p>如果 <code>key</code> 不存在，则返回 <em>-1</em>；</p></li><li><p>如果 <code>key</code> 存在，则 <code>key</code> 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</p></li></ul></li><li><p>对于 <code>put</code> 操作，首先判断 <code>key</code> 是否存在：</p><ul><li><p>如果 <code>key</code> 不存在，使用 <code>key</code> 和 <code>value</code> 创建一个新的节点，在双向链表的头部添加该节点，并将 <code>key</code> 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</p></li><li><p>如果 <code>key</code> 存在，则与 <code>get</code> 操作类似，先通过哈希表定位，再将对应的节点的值更新为 <code>value</code>，并将该节点移到双向链表的头部。</p></li></ul></li></ul><p>上述各项操作中，访问哈希表的时间复杂度为 <em>O(1)<em>，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 *O(1)</em>。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 *O(1)</em> 时间内完成。</p><p><strong>小贴士</strong></p><p>在双向链表的实现中，使用一个<strong>伪头部</strong>（dummy head）和<strong>伪尾部</strong>（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/146/1.PNG" target="_blank" rel="noopener">fig1</a> <a href="https://assets.leetcode-cn.com/solution-static/146/2.PNG" target="_blank" rel="noopener">fig2</a> <a href="https://assets.leetcode-cn.com/solution-static/146/3.PNG" target="_blank" rel="noopener">fig3</a> <a href="https://assets.leetcode-cn.com/solution-static/146/4.PNG" target="_blank" rel="noopener">fig4</a> <a href="https://assets.leetcode-cn.com/solution-static/146/5.PNG" target="_blank" rel="noopener">fig5</a> <a href="https://assets.leetcode-cn.com/solution-static/146/6.PNG" target="_blank" rel="noopener">fig6</a> <a href="https://assets.leetcode-cn.com/solution-static/146/7.PNG" target="_blank" rel="noopener">fig7</a> <a href="https://assets.leetcode-cn.com/solution-static/146/8.PNG" target="_blank" rel="noopener">fig8</a> <a href="https://assets.leetcode-cn.com/solution-static/146/9.PNG" target="_blank" rel="noopener">fig9</a> <a href="https://assets.leetcode-cn.com/solution-static/146/10.PNG" target="_blank" rel="noopener">fig10</a> </p><details>    <summary>哈希表 + 双向链表Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key=<span class="number">0</span>, value=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="keyword">None</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.cache = dict()</span><br><span class="line">        <span class="comment"># 使用伪头部和伪尾部节点    </span></span><br><span class="line">        self.head = DLinkedNode()</span><br><span class="line">        self.tail = DLinkedNode()</span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        node = self.cache[key]</span><br><span class="line">        self.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            node = DLinkedNode(key, value)</span><br><span class="line">            <span class="comment"># 添加进哈希表</span></span><br><span class="line">            self.cache[key] = node</span><br><span class="line">            <span class="comment"># 添加至双向链表的头部</span></span><br><span class="line">            self.addToHead(node)</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.size &gt; self.capacity:</span><br><span class="line">                <span class="comment"># 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                removed = self.removeTail()</span><br><span class="line">                <span class="comment"># 删除哈希表中对应的项</span></span><br><span class="line">                self.cache.pop(removed.key)</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            node.value = value</span><br><span class="line">            self.moveToHead(node)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        node.prev = self.head</span><br><span class="line">        node.next = self.head.next</span><br><span class="line">        self.head.next.prev = node</span><br><span class="line">        self.head.next = node</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        node.prev.next = node.next</span><br><span class="line">        node.next.prev = node.prev</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToHead</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        self.addToHead(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span><span class="params">(self)</span>:</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表 + 双向链表Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value)</span> </span>&#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> HashMap&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode newNode = <span class="keyword">new</span> DLinkedNode(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode tail = removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DLinkedNode <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode res = tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表 + 双向链表C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLinkedNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    DLinkedNode(): key(<span class="number">0</span>), value(<span class="number">0</span>), prev(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    DLinkedNode(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value): key(_key), value(_value), prev(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> _capacity): capacity(_capacity), size(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.count(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.count(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> DLinkedNode(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache[key] = node;</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(node);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode* removed = removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.erase(removed-&gt;key);</span><br><span class="line">                <span class="comment">// 防止内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表 + 双向链表Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="keyword">int</span></span><br><span class="line">    capacity <span class="keyword">int</span></span><br><span class="line">    cache <span class="keyword">map</span>[<span class="keyword">int</span>]*DLinkedNode</span><br><span class="line">    head, tail *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DLinkedNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    key, value <span class="keyword">int</span></span><br><span class="line">    prev, next *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDLinkedNode</span><span class="params">(key, value <span class="keyword">int</span>)</span> *<span class="title">DLinkedNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;DLinkedNode&#123;</span><br><span class="line">        key: key,</span><br><span class="line">        value: value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LRUCache</span></span> &#123;</span><br><span class="line">    l := LRUCache&#123;</span><br><span class="line">        cache: <span class="keyword">map</span>[<span class="keyword">int</span>]*DLinkedNode&#123;&#125;,</span><br><span class="line">        head: initDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        tail: initDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        capacity: capacity,</span><br><span class="line">    &#125;</span><br><span class="line">    l.head.next = l.tail</span><br><span class="line">    l.tail.prev = l.head</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := this.cache[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    node := this.cache[key]</span><br><span class="line">    this.moveToHead(node)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := this.cache[key]; !ok &#123;</span><br><span class="line">        node := initDLinkedNode(key, value)</span><br><span class="line">        this.cache[key] = node</span><br><span class="line">        this.addToHead(node)</span><br><span class="line">        this.size++</span><br><span class="line">        <span class="keyword">if</span> this.size &gt; this.capacity &#123;</span><br><span class="line">            removed := this.removeTail()</span><br><span class="line">            <span class="built_in">delete</span>(this.cache, removed.key)</span><br><span class="line">            this.size--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node := this.cache[key]</span><br><span class="line">        node.value = value</span><br><span class="line">        this.moveToHead(node)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">addToHead</span><span class="params">(node *DLinkedNode)</span></span> &#123;</span><br><span class="line">    node.prev = this.head</span><br><span class="line">    node.next = this.head.next</span><br><span class="line">    this.head.next.prev = node</span><br><span class="line">    this.head.next = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">removeNode</span><span class="params">(node *DLinkedNode)</span></span> &#123;</span><br><span class="line">    node.prev.next = node.next</span><br><span class="line">    node.next.prev = node.prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">moveToHead</span><span class="params">(node *DLinkedNode)</span></span> &#123;</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    this.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">removeTail</span><span class="params">()</span> *<span class="title">DLinkedNode</span></span> &#123;</span><br><span class="line">    node := this.tail.prev</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：对于 <code>put</code> 和 <code>get</code> 都是 <em>O(1)</em>。</p></li><li><p>空间复杂度：O(capacity) ，因为哈希表和双向链表最多存储 capacity+1 个元素。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>134. 加油站</title>
    <link href="http://yoursite.com/2020/10/05/134.%20%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    <id>http://yoursite.com/2020/10/05/134. 加油站/</id>
    <published>2020-10-04T17:17:12.000Z</published>
    <updated>2020-10-06T02:02:06.728Z</updated>
    
    <content type="html"><![CDATA[<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><a id="more"></a><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明: </p><p>如果题目有解，该答案即为唯一答案。<br>输入数组均为非空数组，且长度相同。<br>输入数组中的元素均为非负数。<br>示例 1:</p><pre><code>输入: gas  = [1,2,3,4,5]cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。</code></pre><p>示例 2:</p><pre><code>输入: gas  = [2,3,4]cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。</code></pre><h1 id="方法：一次遍历"><a href="#方法：一次遍历" class="headerlink" title="方法：一次遍历"></a>方法：一次遍历</h1><p><strong>想法</strong></p><p>第一想法是检查每一个加油站：</p><ul><li><p>选择该加油站为出发站</p></li><li><p>模拟汽车环路行驶，在每一个加油站检查我们还剩多少升汽油。</p></li></ul><p>这意味着 O(N^2)的时间复杂度。显然，我们可以做得更好。</p><p>首先注意两件事情：</p><blockquote><p>如果 <code>sum(gas) &lt; sum(cost)</code> ，那么不可能环行一圈，这种情况下答案是 <code>-1</code> 。</p></blockquote><p><a href="https://pic.leetcode-cn.com/4381241b2ed28ee64703425af2e6a4ddb85df5dad25d644c89d7bdbcd2927c8b-image.png" target="_blank" rel="noopener">image.png</a></p><p>我们可以用这个式子计算环行过程中邮箱里剩下的油：<code>total_tank = sum(gas) - sum(cost)</code>  ，如果 <code>total_tank &lt; 0</code> 则返回 <code>-1</code> 。</p><blockquote><p>对于加油站 <code>i</code> ，如果 <code>gas[i] - cost[i] &lt; 0</code> ，则不可能从这个加油站出发，因为在前往 <code>i + 1</code> 的过程中，汽油就不够了。</p></blockquote><p><a href="https://pic.leetcode-cn.com/5f9a6f57444dc93f334fdb782f4368e3863888b82fc90d4f9b490eeb53cf86fe-image.png" target="_blank" rel="noopener">image.png</a></p><p>第二个规则可以被一般化，我们引入变量 <code>curr_tank</code> ，记录当前油箱里剩余的总油量。如果在某一个加油站 <code>curr_tank</code>比 <code>0</code> 小，意味着我们无法到达这个加油站。<strong>一个站的收益如果小于0，肯定不能作为起点；而连续的多个站也可以等效地看做一个站，如果其累积收益小于0，就跳过，寻找下一个。</strong></p><p>下一步我们把这个加油站当做新的起点，并将 <code>curr_tank</code> 重置为 0 ，因为重新出发，油箱中的油为 0 。（从上一次重置的加油站到当前加油站的任意一个加油站出发，到达当前加油站之前， <code>curr_tank</code> 也一定会比 0 小,<strong>即如果A站不能到B站，那么A，B之间到任何一个站都不能到B站，（B站是A站第一个不能到的站）</strong> ）</p><p><strong>算法</strong></p><p>那么现在算法是很直接明了的：</p><ol><li><p>初始化 <code>total_tank</code> 和 <code>curr_tank</code> 为 0 ，并且选择 <code>0</code> 号加油站为起点。</p></li><li><p>遍历所有的加油站：</p><ul><li><p>每一步中，都通过加上 <code>gas[i]</code> 和减去 <code>cost[i]</code> 来更新 <code>total_tank</code> 和 <code>curr_tank</code> 。</p></li><li><p>如果在 <code>i + 1</code> 号加油站， <code>curr_tank &lt; 0</code> ，将 <code>i + 1</code> 号加油站作为新的起点，同时重置 <code>curr_tank = 0</code> ，让油箱也清空。</p></li></ul></li><li><p>如果 <code>total_tank &lt; 0</code> ，返回 <code>-1</code> ，否则返回 <code>starting station</code>。</p></li></ol><p><strong>算法原理</strong></p><p>想象 <code>total_tank &gt;= 0</code> 的情况，同时上述算法返回 <em>N_s</em> 作为出发加油站。</p><p>算法直接保证了从 <em>N_s</em> 可以到达 <em>0</em> ，但是剩余的路程，即从 <em>0</em> 到站 <em>N_s</em> 是否有足够的油呢？</p><blockquote><p>如何确保从 <em>N_s</em> 出发可以环行一圈？</p></blockquote><p>我们使用 <a href="https://baike.baidu.com/item/%E5%8F%8D%E8%AF%81%E6%B3%95/5017739?fr=aladdin" target="_blank" rel="noopener">反证法</a> 。假设存在 <em>0 &lt; k &lt; N_s</em> ，使得我们从 <em>N_s</em> 出发无法到达 <code>k</code> 号加油站。</p><p>条件 <code>total_tank &gt;= 0</code> 可以被写作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i=1&#125;^&#123;N&#125;&#123;\alpha_i&#125;\ge0\qquad(1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\alpha_i&gt;=0</span><br></pre></td></tr></table></figure><p>,<br>其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\alpha_i=gas[i]-cost[i]</span><br></pre></td></tr></table></figure><p>我们将出发站点 <em>N_s</em> 和无法到达站点 <code>k</code> 作为分隔点，将左式分成三个部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i=1&#125;^&#123;k&#125;&#123;\alpha_i&#125;+\sum_&#123;i=k+1&#125;^&#123;N_s-1&#125;&#123;\alpha_i&#125;+\sum_&#123;i=N_s&#125;^&#123;N&#125;&#123;\alpha_i&#125;\ge0\qquad(2)</span><br></pre></td></tr></table></figure><p>根据算法流程，第二项为负，因为每一个出发点前面一段路途的 <code>curr_tank</code> 一定为负。否则，出发点应该是比 <em>N_s</em> 更靠前的一个加油站而不是 <em>N_s</em> 。当且仅当 <em>k = N_s - 1</em> ，第二项才为 0 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i=k+1&#125;^&#123;i=N_s-1&#125;&#123;\alpha_i&#125;\le0\qquad(3)</span><br></pre></td></tr></table></figure><p>结合不等式 <code>(2)</code> 和 <code>(3)</code> ，可以得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i=0&#125;^&#123;i=k&#125;&#123;\alpha_i&#125;+\sum_&#123;i=N_s&#125;^&#123;i=N&#125;&#123;\alpha_i&#125;\ge0\qquad(4)</span><br></pre></td></tr></table></figure><p>同时，因为 <em>k</em> 是一个从 <em>N_s</em> 出发不可到达的站点，意味着</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i=N_s&#125;^&#123;i=N&#125;&#123;\alpha_i&#125;+\sum_&#123;i=0&#125;^&#123;i=k&#125;&#123;\alpha_i&#125;&lt;0\qquad(5)</span><br></pre></td></tr></table></figure><p>结合不等式 <code>(4)</code> 和 <code>(5)</code> ，可以得到一个矛盾。因此，假设 “存在一个 <em>0 &lt; k &lt; N_s</em> ，从 <em>N_s</em> 出发无法到达 <em>k</em>” 不成立。</p><p>因此，从 <em>N_s</em> 出发一定能环行一圈， <em>N_s</em> 是一个可行解。根据题目描述，答案是唯一的。</p><p>上面的官方题解看起来很饶，公式（5）存在以结论证结论的问题，而以每站汽油累计量profit[i] = gas[i] - cost[i]思考这个问题更容易理解。</p><p>若sum(gas) &gt;= sum(cost)，则必定存在解（贪心策略不用严格证明，大家以汽油累计量为0，每站汽油累计量可正可负，极限条件画个环形图理解下：大致就是左边累积量少，我就往右边走，反之亦然）</p><p>再加上题目条件若有解则唯一，</p><p>我们只需找到以i开头的总累计油量有剩余cur_tank + gas[i] - cost[i] &gt;= 0即可——这就是本题贪心策略的依据</p><p><strong>实现</strong></p><p> <a href="https://pic.leetcode-cn.com/87e7bb7a0745fe4916de8deb8687b4a84b3482daab0643f1ae6d4a02cf03ceb0-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/4dad65b5a9ed763e2760129635f1704be4a9e093ea66bc4e244657cb59c35744-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/022e56703b9ce5f53fb8ad9c6d51cc74468bff670eb29dfa48cb0625c9d57cba-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/256c9491248c8cf0e8fca7370346ea22333edc4394c57f211c1783a6b163235a-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/d1cef311a434c64d3fd85ea0d1adb5374e1b16d802110c90c833ceb4121bb19c-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/6be953413c1dbb884e5b2e92837cc4384ba32fa662f7c2c0784cb8e1bff973b2-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/ca82d1cec3e8d2a325c20f1dab270bcae405e21f4990e46f38f5394fe6c65249-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/469511c0afc12420e34588cf19cb373ee22e9d4fb5c472d6b92e764f12e0fd7e-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/dcbe6e6975e1ee7d2cedfbdc9cff3d8212b066e6d5d63535ba435aceec67af9c-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/8c6d7bb66df5271a3383bce38fadbf0bfd52c1b035582903c3a6ebd4df8d1989-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/f1aea61b070c96e2e5c718dd3b9a35e40fa74f769204398fbdbd0a7466fa7eff-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/d450f8d85053fbdd914e21e6e0d56b0b7ebd797bea4cfb6fa5b250f794bcaf61-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/67399856acdd96570218a3de68ec86de6d6f385e517cc5e1991493433ca58b05-image.png" target="_blank" rel="noopener">image.png</a> </p><details>    <summary>一次遍历Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(gas)</span><br><span class="line">        </span><br><span class="line">        total_tank, curr_tank = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        starting_station = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            total_tank += gas[i] - cost[i]</span><br><span class="line">            curr_tank += gas[i] - cost[i]</span><br><span class="line">            <span class="comment"># If one couldn't get here,</span></span><br><span class="line">            <span class="keyword">if</span> curr_tank &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># Pick up the next station as the starting one.</span></span><br><span class="line">                starting_station = i + <span class="number">1</span></span><br><span class="line">                <span class="comment"># Start with an empty tank.</span></span><br><span class="line">                curr_tank = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> starting_station <span class="keyword">if</span> total_tank &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></details><details>    <summary>一次遍历Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = gas.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total_tank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curr_tank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> starting_station = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      total_tank += gas[i] - cost[i];</span><br><span class="line">      curr_tank += gas[i] - cost[i];</span><br><span class="line">      <span class="comment">// If one couldn't get here,</span></span><br><span class="line">      <span class="keyword">if</span> (curr_tank &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Pick up the next station as the starting one.</span></span><br><span class="line">        starting_station = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Start with an empty tank.</span></span><br><span class="line">        curr_tank = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_tank &gt;= <span class="number">0</span> ? starting_station : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>一次遍历C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = gas.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total_tank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curr_tank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> starting_station = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      total_tank += gas[i] - cost[i];</span><br><span class="line">      curr_tank += gas[i] - cost[i];</span><br><span class="line">      <span class="comment">// If one couldn't get here,</span></span><br><span class="line">      <span class="keyword">if</span> (curr_tank &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Pick up the next station as the starting one.</span></span><br><span class="line">        starting_station = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Start with an empty tank.</span></span><br><span class="line">        curr_tank = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_tank &gt;= <span class="number">0</span> ? starting_station : <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： O(N) ， 这是因为只有一个遍历了所有加油站一次的循环。</p></li><li><p>空间复杂度： O(1)  ，因为此算法只使用了常数个变量。</p></li></ul><p><strong>延伸阅读</strong></p><p>还有许多加油站问题的变种问题，这里是一些例子：</p><p><a href="https://www.sciencedirect.com/science/article/pii/S002001901730203X" target="_blank" rel="noopener">允许 Δ 次停留的加油站间最小路径开销</a> </p><p><a href="https://link.springer.com/chapter/10.1007/978-3-540-75520-3_48" target="_blank" rel="noopener">油箱有容量限制下的加油站间最小路径开销</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>412. Fizz Buzz</title>
    <link href="http://yoursite.com/2020/10/05/412.%20Fizz%20Buzz/"/>
    <id>http://yoursite.com/2020/10/05/412. Fizz Buzz/</id>
    <published>2020-10-04T16:26:12.000Z</published>
    <updated>2020-10-04T17:02:23.520Z</updated>
    
    <content type="html"><![CDATA[<p>写一个程序，输出从 1 到 n 数字的字符串表示。</p><a id="more"></a><ol><li><p>如果n是3的倍数，输出“Fizz”；</p></li><li><p>如果n是5的倍数，输出“Buzz”；</p></li><li><p>如果n同时是3和5的倍数，输出 “FizzBuzz”。</p></li></ol><p>示例：</p><pre><code>n = 15,</code></pre><p>返回:</p><pre><code>[    &quot;1&quot;,    &quot;2&quot;,    &quot;Fizz&quot;,    &quot;4&quot;,    &quot;Buzz&quot;,    &quot;Fizz&quot;,    &quot;7&quot;,    &quot;8&quot;,    &quot;Fizz&quot;,    &quot;Buzz&quot;,    &quot;11&quot;,    &quot;Fizz&quot;,    &quot;13&quot;,    &quot;14&quot;,    &quot;FizzBuzz&quot;]</code></pre><h1 id="方法一：-模拟法"><a href="#方法一：-模拟法" class="headerlink" title="方法一： 模拟法"></a>方法一： 模拟法</h1><p><strong>思路</strong></p><p>就像你每次玩 FizzBuzz 那样，你只需要判断这个数是能被 <code>3</code> 整除？ 还是能被 <code>5</code> 整除？ 或者是都能被整除。</p><p><strong>算法</strong></p><ol><li>初始化一个空的答案列表。</li><li>遍历 <em>1 … N</em>。</li><li>对于每个数，判断它能不能同时被 3 和 5 整除，如果可以就把 FizzBuzz 加入答案列表。</li><li>如果不行，判断它能不能被 3 整除，如果可以，把 Fizz 加入答案列表。</li><li>如果还是不行，判断它能不能被 5 整除，如果可以，把 Buzz 加入答案列表。</li><li>如果以上都不行，把这个数加入答案列表。<details> <summary>模拟法Java</summary></details></li></ol><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ans list</span></span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> divisibleBy3 = (num % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">boolean</span> divisibleBy5 = (num % <span class="number">5</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (divisibleBy3 &amp;&amp; divisibleBy5) &#123;</span><br><span class="line">        <span class="comment">// Divides by both 3 and 5, add FizzBuzz</span></span><br><span class="line">        ans.add(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (divisibleBy3) &#123;</span><br><span class="line">        <span class="comment">// Divides by 3, add Fizz</span></span><br><span class="line">        ans.add(<span class="string">"Fizz"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (divisibleBy5) &#123;</span><br><span class="line">        <span class="comment">// Divides by 5, add Buzz</span></span><br><span class="line">        ans.add(<span class="string">"Buzz"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Not divisible by 3 or 5, add the number</span></span><br><span class="line">        ans.add(Integer.toString(num));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details>    <summary>模拟法Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fizzBuzz</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># ans list</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            divisible_by_3 = (num % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            divisible_by_5 = (num % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> divisible_by_3 <span class="keyword">and</span> divisible_by_5:</span><br><span class="line">                <span class="comment"># Divides by both 3 and 5, add FizzBuzz</span></span><br><span class="line">                ans.append(<span class="string">"FizzBuzz"</span>)</span><br><span class="line">            <span class="keyword">elif</span> divisible_by_3:</span><br><span class="line">                <span class="comment"># Divides by 3, add Fizz</span></span><br><span class="line">                ans.append(<span class="string">"Fizz"</span>)</span><br><span class="line">            <span class="keyword">elif</span> divisible_by_5:</span><br><span class="line">                <span class="comment"># Divides by 5, add Buzz</span></span><br><span class="line">                ans.append(<span class="string">"Buzz"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Not divisible by 3 or 5, add the number</span></span><br><span class="line">                ans.append(str(num))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： <em>O(N)</em></li><li>空间复杂度： <em>O(1)</em></li></ul><h1 id="方法二：-字符串连接"><a href="#方法二：-字符串连接" class="headerlink" title="方法二： 字符串连接"></a>方法二： 字符串连接</h1><p><strong>思路</strong></p><p>这个方法不会降低渐进复杂度，但是当 <code>FizzBuzz</code> 的规则变得更复杂的时候，这将会是个更优雅的解法。比方说，玩个 <code>FizzBuzzJazz</code> 的游戏。规则如下：</p><pre>3 ---> "Fizz" , 5 ---> "Buzz", 7 ---> "Jazz"</pre><p>如果你还是用之前的方法来解决这个问题的话，那将会有非常多的条件需要判断哦~</p><ol><li>能不能被 3 整除</li><li>能不能被 5 整除</li><li>能不能被 7 整除</li><li>能不能同时被 3 和 5 整除</li><li>能不能同时被 5 和 7 整除</li><li>能不能同时被 3 和 7 整除</li><li>能不能同时被 3，5，7 整除</li><li>不能被 3，5，7 其中任何一个数整除</li></ol><p>如果 <code>FizzBuzz</code> 照着这种方式变地更复杂的话，那么你要写的判断可能会让你抓狂。</p><p><strong>算法</strong></p><p>我们放弃使用之前的联合判断，取而代之依次判断是否能被给定的数整数。这道题中，就是依次判断能不能被 3 整除，能不能被 5 整除。如果能被 3 整除，就把对应的 <code>Fizz</code> 连接到答案字符串，如果能被 5 整除，就把 <code>Buzz</code> 连接到答案字符串。</p><p>举个例子，现在需要判断 15，步骤将会是下面这样的：</p><blockquote><p>条件 1： 15 % 3 == 0, num_ans_str = “Fizz”<br>条件 2： 15 % 5 == 0, num_ans_str += “Buzz”<br>=&gt; num_ans_str = “FizzBuzz”</p></blockquote><p>对于 <code>FizzBuzz</code> 来说，只需要判断两个条件就可以了，而不需要像方法一中那样判断三个条件。</p><p>同样的，对于 <code>FizzBuzzJazz</code>，现在只需要判断三个条件就可以了。</p><details>    <summary>字符串连接Java</summary><figure class="highlight java"><figcaption><span>[solution-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ans list</span></span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> divisibleBy3 = (num % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">boolean</span> divisibleBy5 = (num % <span class="number">5</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      String numAnsStr = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (divisibleBy3) &#123;</span><br><span class="line">        <span class="comment">// Divides by 3, add Fizz</span></span><br><span class="line">        numAnsStr += <span class="string">"Fizz"</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (divisibleBy5) &#123;</span><br><span class="line">        <span class="comment">// Divides by 5, add Buzz</span></span><br><span class="line">        numAnsStr += <span class="string">"Buzz"</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (numAnsStr.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="comment">// Not divisible by 3 or 5, add the number</span></span><br><span class="line">        numAnsStr += Integer.toString(num);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Append the current answer str to the ans list</span></span><br><span class="line">      ans.add(numAnsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>字符串连接Python</summary><figure class="highlight python"><figcaption><span>[solution-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fizzBuzz</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># ans list</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            divisible_by_3 = (num % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            divisible_by_5 = (num % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            num_ans_str = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> divisible_by_3:</span><br><span class="line">                <span class="comment"># Divides by 3</span></span><br><span class="line">                num_ans_str += <span class="string">"Fizz"</span></span><br><span class="line">            <span class="keyword">if</span> divisible_by_5:</span><br><span class="line">                <span class="comment"># Divides by 5</span></span><br><span class="line">                num_ans_str += <span class="string">"Buzz"</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> num_ans_str:</span><br><span class="line">                <span class="comment"># Not divisible by 3 or 5</span></span><br><span class="line">                num_ans_str = str(num)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Append the current answer str to the ans list</span></span><br><span class="line">            ans.append(num_ans_str)  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li>时间复杂度： <em>O(N)</em></li><li>空间复杂度： <em>O(1)</em><br><br></li></ul><h1 id="方法三-用散列表"><a href="#方法三-用散列表" class="headerlink" title="方法三 用散列表"></a>方法三 用散列表</h1><p><strong>思路</strong></p><p>这个方法是对方法二的优化。当数字和答案的映射是定好的，那么方法二用起来也还可以。但是如果你遇到一个变态的面试官，他跟你说他需要更自由的映射关系呢？</p><p>每个映射一个判断显然是不可行的，这样写出来的代码一定是丑陋不堪且难以维护的。</p><p>如果老板有这样一个需求，明天你把映射关系换掉或者删除一个映射关系吧。对于这种要求，我们只能一个个去修改判断条件的代码。</p><p>但我们实际上有个更优雅的做法，那就是把映射关系放在 <code>散列表</code> 里面。</p><p><strong>算法</strong></p><ol><li>把所有的映射关系放在散列表 <code>fizzBuzzHash</code> 中，这个散列表形如 <code>{ 3: &#39;Fizz&#39;, 5: &#39;Buzz&#39; }</code>。</li><li>遍历 <em>1 … N</em>。</li><li>对于每个数字，遍历 <code>fizzBuzzHash</code> 中的键，检查是否能被它整除。</li><li>如果这个数能被键整除，就把当前键映射的值加到到答案字符串后面去。对于散列表的每个键值对，都这样操作。</li><li>最后将答案字符串加入答案列表。</li></ol><blockquote><p>通过这样的方式你可以对散列表<code>添加/删除</code>映射关系，同时还不需要修改太多代码。</p></blockquote><p>而对于 <code>FizzBuzzJazz</code> 这个问题，散列表就可以是这样的，<code>{ 3: &#39;Fizz&#39;, 5: &#39;Buzz&#39;, 7: &#39;Jazz&#39; }</code>。</p><details>    <summary>用散列表Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ans list</span></span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hash map to store all fizzbuzz mappings.</span></span><br><span class="line">    HashMap&lt;Integer, String&gt; fizzBizzDict =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;Integer, String&gt;() &#123;</span><br><span class="line">          &#123;</span><br><span class="line">            put(<span class="number">3</span>, <span class="string">"Fizz"</span>);</span><br><span class="line">            put(<span class="number">5</span>, <span class="string">"Buzz"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line"></span><br><span class="line">      String numAnsStr = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Integer key : fizzBizzDict.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the num is divisible by key,</span></span><br><span class="line">        <span class="comment">// then add the corresponding string mapping to current numAnsStr</span></span><br><span class="line">        <span class="keyword">if</span> (num % key == <span class="number">0</span>) &#123;</span><br><span class="line">          numAnsStr += fizzBizzDict.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (numAnsStr.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="comment">// Not divisible by 3 or 5, add the number</span></span><br><span class="line">        numAnsStr += Integer.toString(num);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Append the current answer str to the ans list</span></span><br><span class="line">      ans.add(numAnsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>用散列表Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fizzBuzz</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># ans list</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Dictionary to store all fizzbuzz mappings</span></span><br><span class="line">        fizz_buzz_dict = &#123;<span class="number">3</span> : <span class="string">"Fizz"</span>, <span class="number">5</span> : <span class="string">"Buzz"</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            num_ans_str = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> fizz_buzz_dict.keys():</span><br><span class="line"></span><br><span class="line">                <span class="comment"># If the num is divisible by key,</span></span><br><span class="line">                <span class="comment"># then add the corresponding string mapping to current num_ans_str</span></span><br><span class="line">                <span class="keyword">if</span> num % key == <span class="number">0</span>:</span><br><span class="line">                    num_ans_str += fizz_buzz_dict[key]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> num_ans_str:</span><br><span class="line">                num_ans_str = str(num)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Append the current answer str to the ans list</span></span><br><span class="line">            ans.append(num_ans_str)  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： <em>O(N)</em></li><li>空间复杂度： <em>O(1)</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写一个程序，输出从 1 到 n 数字的字符串表示。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>371. 两整数之和</title>
    <link href="http://yoursite.com/2020/10/04/371.%20%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2020/10/04/371. 两整数之和/</id>
    <published>2020-10-04T04:40:12.000Z</published>
    <updated>2020-10-04T16:25:24.939Z</updated>
    
    <content type="html"><![CDATA[<p>不使用运算符 + 和 -，计算两整数a、b之和。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: a = 1, b = 2输出: 3</code></pre><p>示例 2:</p><pre><code>输入: a = -2, b = 3输出: 1</code></pre><h1 id="利用位操作实现加法"><a href="#利用位操作实现加法" class="headerlink" title="利用位操作实现加法"></a>利用位操作实现加法</h1><p>首先看十进制是如何做的： 5+7=12，三步走 </p><ul><li>第一步：相加各位的值，不算进位，得到2。 </li><li>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。  </li><li>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 </li></ul><p>同样我们可以用三步走的方式计算二进制值相加： 5—101，7—111 </p><ul><li>第一步：相加各位的值，不算进位，得到010，<strong>二进制每位相加就相当于各位做异或操作</strong>，101^111。 </li><li>第二步：计算进位值，得到1010，<strong>相当于各位进行与操作得到101，再向左移一位得到1010</strong>，(101&amp;111)&lt;&lt;1。  </li><li>第三步重复上述两步，各位相加 010^1010=1000，进位值为100=(010 &amp; 1010)&lt;&lt;1。 </li><li>继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。 </li><li>结束条件：<strong>进位为0，即a为最终的求和结果。</strong><details>  <summary>利用位操作实现加法</summary></details></li></ul><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a ^ b;</span><br><span class="line">            b = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾一下我们小学就开始学习的十进制的加法，比如<code>15+7</code>，最低位<code>5+7</code>得到<code>12</code>，对<code>10</code>取模得到<code>2</code>，进位为<code>1</code>，再高位相加<code>1+0</code>再加上进位<code>1</code>就得到高位结果<code>2</code>,组合起来就是<code>22</code>。这里面涉及到了两个数字，一个是相加得到的低位，也就是<code>5+7</code>得到的结果<code>2</code>，第二个是进位<code>1</code>。在二进制的计算中就是要通过位操作来得到结果的低位和进位，对于不同的情况，用表格来表示一下，两个数字分别为<code>a</code>和<code>b</code></p><table><thead><tr><th align="center">a</th><th align="center">b</th><th align="center">低位</th><th align="center">进位</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><p>从上面的表格就可以发现，<code>低位 = a^b</code>，<code>进位 = a &amp; b</code>。这样的计算可能要持续多次，回想一下在十进制的计算中，如果进位一直大于0，就得往后面进行计算，在这里也是一样，只要进位不是0，我们就得一直重复计算低位和进位的操作（需要在下一次计算之前要把进位向左移动一位，这样进位才能和更高位进行运算）。这个时候的<code>a</code>和<code>b</code>就是刚才计算的低位和进位，用简单的加法迭代的代码表示：</p><details>    <summary>利用位操作实现加法</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> lower;</span><br><span class="line">    <span class="keyword">int</span> carrier;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        lower = a^b;    <span class="comment">// 计算低位</span></span><br><span class="line">        carrier = a&amp;b;  <span class="comment">// 计算进位</span></span><br><span class="line">        <span class="keyword">if</span> (carrier==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        a = lower;</span><br><span class="line">        b = carrier&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lower;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不使用运算符 + 和 -，计算两整数a、b之和。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>202. 快乐数</title>
    <link href="http://yoursite.com/2020/10/04/202.%20%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
    <id>http://yoursite.com/2020/10/04/202. 快乐数/</id>
    <published>2020-10-04T01:30:12.000Z</published>
    <updated>2020-10-04T04:38:25.560Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个算法来判断一个数 n 是不是快乐数。</p><a id="more"></a><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p>示例：</p><pre><code>输入：19输出：true解释：1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="9d8ce931-e835-45d1-a3d2-ab54b52b5377">202. 快乐数 - Lizzi.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：用-HashSet-检测循环"><a href="#方法一：用-HashSet-检测循环" class="headerlink" title="方法一：用 HashSet 检测循环"></a>方法一：用 HashSet 检测循环</h2><p>我们可以先举几个例子。我们从 <em>7</em> 开始。则下一个数字是 <em>49<em>（因为 *7^2=49</em>），然后下一个数字是 <em>97</em>（因为 <em>4^2+9^2=97</em>）。我们可以不断重复该的过程，直到我们得到 <em>1</em>。因为我们得到了 <em>1</em>，我们知道 *7</em> 是一个快乐数，函数应该返回 <code>true</code>。</p><p><a href="https://assets.leetcode-cn.com/solution-static/202/202_fig1.png" target="_blank" rel="noopener">fig1</a></p><p>再举一个例子，让我们从 <em>116</em> 开始。通过反复通过平方和计算下一个数字，我们最终得到 <em>58</em>，再继续计算之后，我们又回到 <em>58</em>。由于我们回到了一个已经计算过的数字，可以知道有一个循环，因此不可能达到 <em>1</em>。所以对于 <em>116</em>，函数应该返回 <code>false</code>。</p><p><a href="https://assets.leetcode-cn.com/solution-static/202/202_fig2.png" target="_blank" rel="noopener">fig2</a></p><p>根据我们的探索，我们猜测会有以下三种可能。</p><ol><li>最终会得到 <em>1</em>。</li><li>最终会进入循环。</li><li>值会越来越大，最后接近无穷大。</li></ol><p>第三个情况比较难以检测和处理。我们怎么知道它会继续变大，而不是最终得到 <em>1</em> 呢？我们可以仔细想一想，每一位数的最大数字的下一位数是多少。</p><table><thead><tr><th>Digits</th><th align="center">Largest</th><th align="right">Next</th></tr></thead><tbody><tr><td>1</td><td align="center">9</td><td align="right">81</td></tr><tr><td>2</td><td align="center">99</td><td align="right">162</td></tr><tr><td>3</td><td align="center">999</td><td align="right">243</td></tr><tr><td>4</td><td align="center">9999</td><td align="right">324</td></tr><tr><td>13</td><td align="center">9999999999999</td><td align="right">1053</td></tr></tbody></table><p>对于 <em>3</em> 位数的数字，它不可能大于 <em>243*。这意味着它要么被困在 *243</em> 以下的循环内，要么跌到 <em>1</em>。<em>4</em> 位或 <em>4</em> 位以上的数字在每一步都会丢失一位，直到降到 <em>3</em> 位为止。所以我们知道，最坏的情况下，算法可能会在 <em>243</em> 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 <em>1</em>。但它不会无限期地进行下去，所以我们排除第三种选择。</p><p>即使在代码中你不需要处理第三种情况，你仍然需要理解为什么它永远不会发生，这样你就可以证明为什么你不处理它。</p><p><strong>算法：</strong></p><p>算法分为两部分，我们需要设计和编写代码。</p><ol><li>给一个数字 <em>n</em>，它的下一个数字是什么？</li><li>按照一系列的数字来判断我们是否进入了一个循环。</li></ol><p>第 1 部分我们按照题目的要求做数位分离，求平方和。</p><p>第 2 部分可以使用 HashSet 完成。每次生成链中的下一个数字时，我们都会检查它是否已经在 HashSet 中。</p><ul><li>如果它不在 HashSet 中，我们应该添加它。</li><li>如果它在 HashSet 中，这意味着我们处于一个循环中，因此应该返回 <code>false</code>。</li></ul><p>我们使用 HashSet  而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集中需要 <em>O(1)</em> 的时间，而对于其他数据结构，则需要 <em>O(n)</em> 的时间。选择正确的数据结构是解决这些问题的关键部分。</p><details>    <summary>用 HashSet 检测循环Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(n)</span>:</span></span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            n, digit = divmod(n, <span class="number">10</span>)</span><br><span class="line">            total_sum += digit ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">        seen.add(n)</span><br><span class="line">        n = get_next(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br></pre></td></tr></table></figure></details><details>    <summary>用 HashSet 检测循环Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !seen.contains(n)) &#123;</span><br><span class="line">            seen.add(n);</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>用 HashSet 检测循环C#</summary><figure class="highlight csharp"><figcaption><span>[solution1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsHappy</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        HashSet &lt;<span class="keyword">int</span>&gt; seen = <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !seen.Contains(n)) &#123;</span><br><span class="line">            seen.Add(n);</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>用 HashSet 检测循环Golang</summary><figure class="highlight golang"><figcaption><span>[solution1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ; n != <span class="number">1</span> &amp;&amp; !m[n]; n, m[n] = step(n), <span class="literal">true</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">step</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        sum += (n%<span class="number">10</span>) * (n%<span class="number">10</span>)</span><br><span class="line">        n = n/<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>确定这个问题的时间复杂度对于一个 “简单” 级别的问题来说是一个挑战。如果您对这些问题还不熟悉，可以尝试只计算  <code>getNext(n)</code> 函数的时间复杂度。</p><ul><li>时间复杂度：<br>O(243 *3 + logn+loglogn+logloglogn)…=O(logn)。<ul><li>查找给定数字的下一个值的成本为O(logn) ，因为我们正在处理数字中的每位数字，而数字中的位数由 logn 给定。</li><li>要计算出总的时间复杂度，我们需要仔细考虑循环中有多少个数字，它们有多大。</li></ul><ul><li>我们在上面确定，一旦一个数字低于 <em>243*，它就不可能回到 *243</em> 以上。因此，我们就可以用 <em>243</em> 以下最长循环的长度来代替 <em>243</em>，不过，因为常数无论如何都无关紧要，所以我们不会担心它。</li><li>对于高于 <em>243</em> 的 <em>n</em>，我们需要考虑循环中每个数高于 <em>243</em> 的成本。通过数学运算，我们可以证明在最坏的情况下，这些成本将是 O(logn)+O(loglogn)+O(logloglogn) 。幸运的是，O(logn)  是占主导地位的部分，而其他部分相比之下都很小（总的来说，它们的总和小于O(logn)），所以我们可以忽略它们。</li></ul></li><li>空间复杂度：O(logn) 。与时间复杂度密切相关的是衡量我们放入 HashSet 中的数字以及它们有多大的指标。对于足够大的 <em>n</em>，大部分空间将由 <em>n</em> 本身占用。我们可以很容易地优化到O(243<em>3)=O(1) ，方法是只保存集合中小于 *243</em> 的数字，因为对于较高的数字，无论如何都不可能返回到它们。</li></ul><h2 id="方法二：快慢指针法"><a href="#方法二：快慢指针法" class="headerlink" title="方法二：快慢指针法"></a>方法二：快慢指针法</h2><p>通过反复调用 <code>getNext(n)</code> 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。<code>next</code> 指针是通过调用 <code>getNext(n)</code> 函数获得。</p><p>意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的快的称为 “乌龟”，跑得快的称为 “兔子”。</p><p>不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/202/1.jpg" target="_blank" rel="noopener">fig1</a> <a href="https://assets.leetcode-cn.com/solution-static/202/2.jpg" target="_blank" rel="noopener">fig2</a> <a href="https://assets.leetcode-cn.com/solution-static/202/3.jpg" target="_blank" rel="noopener">fig3</a> <a href="https://assets.leetcode-cn.com/solution-static/202/4.jpg" target="_blank" rel="noopener">fig4</a> <a href="https://assets.leetcode-cn.com/solution-static/202/5.jpg" target="_blank" rel="noopener">fig5</a> <a href="https://assets.leetcode-cn.com/solution-static/202/6.jpg" target="_blank" rel="noopener">fig6</a> <a href="https://assets.leetcode-cn.com/solution-static/202/7.jpg" target="_blank" rel="noopener">fig7</a> <a href="https://assets.leetcode-cn.com/solution-static/202/8.jpg" target="_blank" rel="noopener">fig8</a> </p><p><strong>算法：</strong></p><p>我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 <code>getNext(n)</code> 函数的嵌套调用）。</p><p>如果 <code>n</code> 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。</p><p>如果 <code>n</code> 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。</p><details>    <summary>快慢指针法Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(number)</span>:</span></span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> number &gt; <span class="number">0</span>:</span><br><span class="line">            number, digit = divmod(number, <span class="number">10</span>)</span><br><span class="line">            total_sum += digit ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">    slow_runner = n</span><br><span class="line">    fast_runner = get_next(n)</span><br><span class="line">    <span class="keyword">while</span> fast_runner != <span class="number">1</span> <span class="keyword">and</span> slow_runner != fast_runner:</span><br><span class="line">        slow_runner = get_next(slow_runner)</span><br><span class="line">        fast_runner = get_next(get_next(fast_runner))</span><br><span class="line">    <span class="keyword">return</span> fast_runner == <span class="number">1</span></span><br></pre></td></tr></table></figure></details><details>    <summary>快慢指针法Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowRunner = n;</span><br><span class="line">        <span class="keyword">int</span> fastRunner = getNext(n);</span><br><span class="line">        <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">            slowRunner = getNext(slowRunner);</span><br><span class="line">            fastRunner = getNext(getNext(fastRunner));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>快慢指针法C#</summary><figure class="highlight csharp"><figcaption><span>[solution2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsHappy</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowRunner = n;</span><br><span class="line">        <span class="keyword">int</span> fastRunner = getNext(n);</span><br><span class="line">        <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">            slowRunner = getNext(slowRunner);</span><br><span class="line">            fastRunner = getNext(getNext(fastRunner));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>快慢指针法Golang</summary><figure class="highlight golang"><figcaption><span>[solution2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    slow, fast := n, step(n)</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="number">1</span> &amp;&amp; slow != fast &#123;</span><br><span class="line">        slow = step(slow)</span><br><span class="line">        fast = step(step(fast))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">step</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        sum += (n%<span class="number">10</span>) * (n%<span class="number">10</span>)</span><br><span class="line">        n = n/<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(logn)  。该分析建立在对前一种方法的分析的基础上，但是这次我们需要跟踪两个指针而不是一个指针来分析，以及在它们相遇前需要绕着这个循环走多少次。<ul><li>如果没有循环，那么快跑者将先到达 1，慢跑者将到达链表中的一半。我们知道最坏的情况下，成本是    O(2logn) = O(logn) 。</li><li>一旦两个指针都在循环中，在每个循环中，快跑者将离慢跑者更近一步。一旦快跑者落后慢跑者一步，他们就会在下一步相遇。假设循环中有 <em>k</em> 个数字。如果他们的起点是相隔 <em>k-1</em> 的位置（这是他们可以开始的最远的距离），那么快跑者需要 <em>k-1</em> 步才能到达慢跑者，这对于我们的目的来说也是不变的。因此，主操作仍然在计算起始 n 的下一个值，即 O(logn)  。</li></ul></li><li>空间复杂度：<em>O(1)</em>，对于这种方法，我们不需要哈希集来检测循环。指针需要常数的额外空间。</li></ul><h2 id="方法三：数学"><a href="#方法三：数学" class="headerlink" title="方法三：数学"></a>方法三：数学</h2><p>前两种方法是你在面试中应该想到的。第三种方法不是你在面试中会写的，而是针对对数学好奇的人，因为它很有趣。</p><p>下一个值可能比自己大的最大数字是什么？根据我们之前的分析，我们知道它必须低于 243。因此，我们知道任何循环都必须包含小于 243 的数字，用这么小的数字，编写一个能找到所有周期的强力程序并不困难。</p><p>如果这样做，您会发现只有一个循环：4→16→37→58→89→145→42→20→4 。所有其他数字都在进入这个循环的链上，或者在进入 <em>1</em> 的链上。</p><p>因此，我们可以硬编码一个包含这些数字的散列集，如果我们达到其中一个数字，那么我们就知道在循环中。</p><p><strong>算法：</strong></p><details>    <summary>数学Python</summary><figure class="highlight python"><figcaption><span>[solution3-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">    cycle_members = &#123;<span class="number">4</span>, <span class="number">16</span>, <span class="number">37</span>, <span class="number">58</span>, <span class="number">89</span>, <span class="number">145</span>, <span class="number">42</span>, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(number)</span>:</span></span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> number &gt; <span class="number">0</span>:</span><br><span class="line">            number, digit = divmod(number, <span class="number">10</span>)</span><br><span class="line">            total_sum += digit ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> cycle_members:</span><br><span class="line">        n = get_next(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br></pre></td></tr></table></figure></details><details>    <summary>数学Java</summary><figure class="highlight java"><figcaption><span>[solution3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Integer&gt; cycleMembers =</span><br><span class="line">        <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="number">4</span>, <span class="number">16</span>, <span class="number">37</span>, <span class="number">58</span>, <span class="number">89</span>, <span class="number">145</span>, <span class="number">42</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !cycleMembers.contains(n)) &#123;</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>数学C#</summary><figure class="highlight csharp"><figcaption><span>[solution3-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsHappy</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        HashSet&lt;<span class="keyword">int</span>&gt; cycleMembers =</span><br><span class="line">            <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>] &#123;<span class="number">4</span>, <span class="number">16</span>, <span class="number">37</span>, <span class="number">58</span>, <span class="number">89</span>, <span class="number">145</span>, <span class="number">42</span>, <span class="number">20</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !cycleMembers.Contains(n)) &#123;</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>数学Golang</summary><figure class="highlight golang"><figcaption><span>[solution3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    cycle := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;<span class="number">4</span>: <span class="literal">true</span>, <span class="number">6</span>: <span class="literal">true</span>, <span class="number">37</span>: <span class="literal">true</span>, <span class="number">58</span>: <span class="literal">true</span>, <span class="number">89</span>: <span class="literal">true</span>, <span class="number">145</span>: <span class="literal">true</span>, <span class="number">42</span>: <span class="literal">true</span>, <span class="number">20</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> n != <span class="number">1</span> &amp;&amp; !cycle[n] &#123;</span><br><span class="line">        n = step(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">step</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        sum += (n%<span class="number">10</span>) * (n%<span class="number">10</span>)</span><br><span class="line">        n = n/<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(logn)  。和上面一样。</li><li>空间复杂度：<em>O(1)</em>，我们没有保留我们所遇到的数字的历史记录。硬编码哈希集的大小是固定的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个算法来判断一个数 n 是不是快乐数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>326. 3的幂</title>
    <link href="http://yoursite.com/2020/09/30/326.%203%E7%9A%84%E5%B9%82/"/>
    <id>http://yoursite.com/2020/09/30/326. 3的幂/</id>
    <published>2020-09-30T06:30:12.000Z</published>
    <updated>2020-10-03T16:14:24.038Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数，写一个函数来判断它是否是3的幂次方。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: 27输出: true</code></pre><p>示例 2:</p><pre><code>输入: 0输出: false</code></pre><p>示例 3:</p><pre><code>输入: 9输出: true</code></pre><p>示例 4:</p><pre><code>输入: 45输出: false</code></pre><p>进阶：</p><pre><code>你能不使用循环或者递归来完成本题吗？</code></pre><h1 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h1><p>在本文中，我们将探讨加速简单计算的方法，以及为什么在实践中有用。 </p><h2 id="方法一：循环迭代"><a href="#方法一：循环迭代" class="headerlink" title="方法一：循环迭代"></a>方法一：循环迭代</h2><p>找出数字 <code>n</code> 是否是数字 <code>b</code> 的幂的一个简单方法是，<code>n%3</code>  只要余数为 0，就一直将 <code>n</code> 除以 <code>b</code>。</p><pre><code>n=b^x * n=b*b*...*b</code></pre><p>因此，应该可以将 <code>n</code> 除以 <code>b</code>  x 次，每次都有 0 的余数，最终结果是 1。 </p><details>    <summary>循环迭代</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>注意我们需要一个警卫来检查那个 <code>n！=0</code>，否则 while 循环将永远不会结束。对于负数，该算法没有意义，因此我们也将包括该保护。 </p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(log_b(n)) ，在我们的例子中是O(logn) 。除数是用对数表示的。 </li><li>空间复杂度：<em>O(1)</em>，没有使用额外的空间。</li></ul><h2 id="方法二：基准转换"><a href="#方法二：基准转换" class="headerlink" title="方法二：基准转换"></a>方法二：基准转换</h2><p>在基数 10 中，10 的所有幂都从数字 1 开始，然后只跟 0（例如10、100、1000）。其他基地及其各自的权力也是如此。例如，在基数 2 中，<em>10 _2<em>、</em>100 _2</em> 和 <em>1000 _2</em> 分别表示为  <em>2_{10}</em>, <em>4_{10}</em> 和 <em>8_{10}</em>。因此，如果我们把我们的数转换成基3，并且表示形式是 100…0，那么这个数就是3的幂。</p><p><strong>证明 ：</strong><br>给定以 3 为底的数字表示为数组 <code>s</code>，第 0 位开始为有效数。<br>因此，只有一个数字 1，其余的都是 0，这意味着这个数字是 3 的幂。 </p><p><strong>实现：</strong></p><ul><li>我们所要做的就是将数字转换为以3为底的基数 ，并检查它是否为前导1，后跟所有 0。 </li><li>两个内置的Java函数将帮助我们前进。 </li></ul><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String baseChange = Integer.toString(number, base);</span><br></pre></td></tr></table></figure><ul><li>上面的代码将 <code>number</code> 转换以 <code>base</code> 为底的基数，并以字符串形式返回结果。例如，<code>integer.toString（5，2）=“101”</code> 和 <code>integer.toString（5，3）=“12”</code>。 </li></ul><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> matches = myString.matches(<span class="string">"123"</span>);</span><br></pre></td></tr></table></figure><p>上面的代码检查字符串中是否存在特定的正则表达式。例如，如果字符串 <code>mystring</code> 中存在子字符串 “123”，上面的内容将返回 true。 </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> powerOfThree = baseChange.matches(<span class="string">"^10**"</span>)</span><br></pre></td></tr></table></figure><p>我们将使用上面的正则表达式来检查字符串是否以1 <code>^1</code> 开头，后跟 0 或 多个 0 <code>0*</code> 并且不包含任何其他值 <code>*</code>。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(n, <span class="number">3</span>).matches(<span class="string">"^10**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(log_3n)</em>。<ul><li>假设：<ul><li><code>Integer.toString()</code> - 基转换通常是作为一个重复的除法来实现的。复杂性应该类似于我们的方法 1:<em>O（\ log_3n）</em>的复杂性。</li><li><code>String.matches()</code> - 方法迭代整个字符串。<code>n</code> 以 3 为基数表示的位数是<em>O（\log_3n）</em>。 </li></ul></li></ul></li><li>空间复杂度：<em>O(\log_3n)</em>。我们使用两个附加变量。<ul><li>以 3 为基数表示数字的字符串（大小为 <em>\log_3n</em>）</li><li>正则表达式的字符串（常量大小） </li></ul></li></ul><h2 id="方法三：运算法"><a href="#方法三：运算法" class="headerlink" title="方法三：运算法"></a>方法三：运算法</h2><p>我们可以用下面的数学公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = 3^i </span><br><span class="line"></span><br><span class="line">\ i = \ log_3(n) </span><br><span class="line"></span><br><span class="line">\ i = \frac&#123;\ log_b(n)&#125;&#123;\ log_b(3)&#125;</span><br></pre></td></tr></table></figure><p>若 <code>n</code> 是 3 的幂则 <code>i</code> 是整数。在 Java 中，我们通过取小数部分（利用 <code>% 1</code>）来检查数字是否是整数，并检查它是否是 0。 </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Math.log10(n) / Math.log10(<span class="number">3</span>)) % <span class="number">1</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常见的陷阱 :</strong><br>这个解决方案是有问题的，因为我们开始使用 <code>double</code> s，这意味着我们会遇到精度错误。说明在比较双精度数时不应使用 <code>==</code>。这是因为 <code>Math.log10(n)/Math.log10(3)</code> 的结果可能是 <code>5.0000001</code> 或 <code>4.9999999</code>。使用 <code>Math.log()</code> 函数而不是<code>Math.log10()</code> 可以观察到这种效果。 </p><p>为了解决这个问题，我们需要将结果与 <code>epsilon</code> 进行比较。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (Math.log(n) / Math.log(<span class="number">3</span>) + epsilon) % <span class="number">1</span> &lt;= <span class="number">2</span> * epsilon;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：*Unknown$。这里主要消耗时间的运算是 <code>Math.log</code>，它限制了我们算法的时间复杂性。实现依赖于我们使用的语言和编译器 。</li><li>空间复杂度： <em>O(1)</em>，我们没有使用任何额外的内存。<code>epsilon</code> 变量可以是内联的。 </li></ul><h2 id="方法四：整数限制"><a href="#方法四：整数限制" class="headerlink" title="方法四：整数限制"></a>方法四：整数限制</h2><p>一个重要的信息可以从函数名中推导出来。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br></pre></td></tr></table></figure><p>我们可以看出 <code>n</code> 的类型是  <code>int</code>。在 Java 中说明了该变量是四个字节，他的最大值为 <strong>2147483647</strong>。有三种方法可以计算出该最大值。</p><ol><li><a href="http://stackoverflow.com/questions/15004944/max-value-of-integer" target="_blank" rel="noopener">Google</a></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3. MaxInt = 2^32/2 - 1 ,因为我们使用 32 位来表示数字，所以范围的一半用于负数，0 是正数的一部分。</span><br><span class="line"></span><br><span class="line">知道了 `n` 的限制，我们现在可以推断出 `n` 的最大值，也就是 3 的幂，是 **1162261467**。我们计算如下： </span><br><span class="line"></span><br><span class="line">```math</span><br><span class="line">3^&#123;\lfloor&#123;&#125;\log_3&#123;MaxInt&#125;\rfloor&#123;&#125;&#125; = 3^&#123;\lfloor&#123;&#125;19.56\rfloor&#123;&#125;&#125; = 3^&#123;19&#125; = 1162261467</span><br></pre></td></tr></table></figure></li></ol><p>因此，我们应该返回 <code>true</code> 的 <code>n</code> 的可能值是 <em>3^0<em>，</em>3^1<em>…</em>3 ^ {19}*。因为 3 是质数，所以 *3^{19}</em> 的除数只有 <em>3^0<em>，</em>3^1<em>…</em>3 ^{19}*，因此我们只需要将 *3^{19}</em> 除以 <code>n</code>。若余数为 <strong>0</strong> 意味着 <code>n</code> 是 *3^{19}$ 的除数，因此是 3 的幂。 </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(1)</em>。我们只做了一次操作。 </li><li>空间复杂度： <em>O(1)</em>，没有使用额外空间。</li></ul><h2 id="性能测量-："><a href="#性能测量-：" class="headerlink" title="性能测量 ："></a>性能测量 ：</h2><p>函数的单次运行使得难以测量两种解的差别。在 leetcode 上的 $Accepted* <em>Solutions</em>  <em>Runtime</em> <em>Distribution</em> 页面上，所有解决方案都在 <code>15 ms</code> 到 <code>20 ms</code> 之间。为了完整性，我们提出了以下基准，以了解这两个解决方案的区别。 </p><p><strong>Java基准码 :</strong></p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Solution sol = <span class="keyword">new</span> Solution();</span><br><span class="line">    <span class="keyword">int</span> iterations = <span class="number">1</span>; <span class="comment">// See table header for this value</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        sol.isPowerOfThree(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下表中，以秒为单位。<br>| Iterations |<em>10^6</em> |<em>10^7</em>|<em>10^8</em>|<em>10^9</em>|*Maxint$|<br>|–|–|–|–|–|–|<br>| Java Approach 1: (Naive) | 0.04 |0.07|0.30|2.47|5.26|<br>|Java Approach 2: (Strings) | 0.68 |4.02|38.90|409.16|893.89|<br>| Java Approach 3: (Logarithms) | 0.09 |0.50|4.59|45.53|97.50|<br>|Java Approach 4: (Fast) | 0.04 |0.06|0.08|0.41|0.78|</p><p>正如我们所看到的，对于小的 N 值，差异并不明显，但是随着我们进行更多的迭代，并且传递给 <code>isPowerOfThree()</code> 的 <code>n</code> 的值增长，我们看到方法 4 的性能显著提高。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论 :"></a>结论 :</h2><p>像这样的简单优化似乎可以忽略不计，但历史上，当计算能力成为一个问题时，它允许某些计算机程序（如Quake 3）成为可能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数，写一个函数来判断它是否是3的幂次方。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>268. 缺失数字</title>
    <link href="http://yoursite.com/2020/09/30/268.%20%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/09/30/268. 缺失数字/</id>
    <published>2020-09-30T02:30:12.000Z</published>
    <updated>2020-09-30T03:16:46.091Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [3,0,1]输出: 2</code></pre><p>示例 2:</p><pre><code>输入: [9,6,4,2,3,5,7,0,1]输出: 8</code></pre><p>说明:</p><pre><code>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</code></pre><h1 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h1><p><strong>分析</strong></p><p>如果数组是有序的，那么就很容易知道缺失的数字是哪个了。</p><p><strong>算法</strong></p><p>首先我们对数组进行排序，随后我们可以在常数时间内判断两种特殊情况：0 没有出现在数组的首位，以及 <em>n</em> 没有出现在数组的末位。如果这两种特殊情况都不满足，那么缺失的数字一定在 0 和 <em>n</em> 之间（不包括两者）。此时我们可以在线性时间内扫描这个数组，如果某一个数比它前面的那个数大了超过 1，那么这两个数之间的那个数即为缺失的数字。</p><details>    <summary>排序Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断 n 是否出现在末位</span></span><br><span class="line">        <span class="keyword">if</span> (nums[nums.length-<span class="number">1</span>] != nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断 0 是否出现在首位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时缺失的数字一定在 (0, n) 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> expectedNum = nums[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != expectedNum) &#123;</span><br><span class="line">                <span class="keyword">return</span> expectedNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未缺失任何数字（保证函数有返回值）</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>排序Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Ensure that n is at the last index</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">-1</span>] != len(nums):</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="comment"># Ensure that 0 is at the first index</span></span><br><span class="line">        <span class="keyword">elif</span> nums[<span class="number">0</span>] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If we get here, then the missing number is on the range (0, n)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            expected_num = nums[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] != expected_num:</span><br><span class="line">                <span class="keyword">return</span> expected_num</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(nlogn)。由于排序的时间复杂度为 O(nlogn) ，扫描数组的时间复杂度为 <em>O(n)</em>，因此总的时间复杂度为O(nlogn)。</li><li>空间复杂度：<em>O(1)</em> 或 <em>O(n)*。空间复杂度取决于使用的排序算法，根据排序算法是否进行原地排序（即不使用额外的数组进行临时存储），空间复杂度为 *O(1)</em> 或 <em>O(n)</em>。</li></ul><h1 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h1><p><strong>分析</strong></p><p>我们可以直接查询每个数是否在数组中出现过来找出缺失的数字。如果使用哈希表，那么每一次查询操作都是常数时间的。</p><p><strong>算法</strong></p><p>我们将数组中的所有数插入到一个集合中，这样每次查询操作的时间复杂度都是 <em>O(1)</em> 的。</p><details>    <summary>哈希表Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; numSet = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) numSet.add(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> expectedNumCount = nums.length + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> number = <span class="number">0</span>; number &lt; expectedNumCount; number++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!numSet.contains(number)) &#123;</span><br><span class="line">                <span class="keyword">return</span> number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        num_set = set(nums)</span><br><span class="line">        n = len(nums) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> number <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> number <span class="keyword">not</span> <span class="keyword">in</span> num_set:</span><br><span class="line">                <span class="keyword">return</span> number</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li>时间复杂度：<em>O(n)<em>。集合的插入操作的时间复杂度都是 *O(1)</em>，一共插入了 *n</em> 个数，时间复杂度为 <em>O(n)<em>。集合的查询操作的时间复杂度同样是 *O(1)</em>，最多查询 *n+1</em> 次，时间复杂度为 <em>O(n)</em>。因此总的时间复杂度为 <em>O(n)</em>。</li><li>空间复杂度：<em>O(n)*。集合中会存储 *n</em> 个数，因此空间复杂度为 <em>O(n)</em>。</li></ul><h1 id="方法三：位运算"><a href="#方法三：位运算" class="headerlink" title="方法三：位运算"></a>方法三：位运算</h1><p><strong>分析</strong></p><p>由于异或运算（XOR）满足结合律，并且对一个数进行两次完全相同的异或运算会得到原来的数，因此我们可以通过异或运算找到缺失的数字。</p><p><strong>算法</strong></p><p>我们知道数组中有 <em>n</em> 个数，并且缺失的数在 <em>[0..n]</em> 中。因此我们可以先得到 <em>[0..n]</em> 的异或值，再将结果对数组中的每一个数进行一次异或运算。未缺失的数在 <em>[0..n]</em> 和数组中各出现一次，因此异或后得到 0。而缺失的数字只在 <em>[0..n]</em> 中出现了一次，在数组中没有出现，因此最终的异或结果即为这个缺失的数字。</p><p>在编写代码时，由于 <em>[0..n]</em> 恰好是这个数组的下标加上 <em>n</em>，因此可以用一次循环完成所有的异或运算，例如下面这个例子：</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>数字</td><td>0</td><td>1</td><td>3</td><td>4</td></tr></tbody></table><p>可以将结果的初始值设为 <em>n</em>，再对数组中的每一个数以及它的下标进行一个异或运算，<br>就得到了缺失的数字为 2。</p><details>    <summary>位运算Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> missing = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            missing ^= i ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> missing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>位运算Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        missing = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            missing ^= i ^ num</span><br><span class="line">        <span class="keyword">return</span> missing</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)*。这里假设异或运算的时间复杂度是常数的，总共会进行 *O(n)</em> 次异或运算，因此总的时间复杂度为 <em>O(n)</em>。</li><li>空间复杂度：<em>O(1)*。算法中只用到了 *O(1)</em> 的额外空间，用来存储答案。</li></ul><h1 id="方法四：数学"><a href="#方法四：数学" class="headerlink" title="方法四：数学"></a>方法四：数学</h1><p><strong>分析</strong></p><p>我们可以用 <a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E6%B1%82%E5%92%8C" target="_blank" rel="noopener">高斯求和公式</a> 求出 <em>[0..n]</em> 的和，减去数组中所有数的和，就得到了缺失的数字。</p><p><strong>算法</strong></p><p>我们在线性时间内可以求出数组中所有数的和，并在常数时间内求出前 <em>n+1</em> 个自然数（包括 0）的和，将后者减去前者，就得到了缺失的数字。</p><details>    <summary>数学Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expectedSum = nums.length*(nums.length + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> actualSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) actualSum += num;</span><br><span class="line">        <span class="keyword">return</span> expectedSum - actualSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>数学Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        expected_sum = len(nums)*(len(nums)+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        actual_sum = sum(nums)</span><br><span class="line">        <span class="keyword">return</span> expected_sum - actual_sum</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em>。求出数组中所有数的和的时间复杂度为 <em>O(n)</em>，高斯求和公式的时间复杂度为 <em>O(1)</em>，因此总的时间复杂度为 <em>O(n)</em>。</li><li>空间复杂度：<em>O(1)*。算法中只用到了 *O(1)</em> 的额外空间，用来存储答案。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>204. 计数质数</title>
    <link href="http://yoursite.com/2020/09/29/204.%20%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/"/>
    <id>http://yoursite.com/2020/09/29/204. 计数质数/</id>
    <published>2020-09-29T08:30:12.000Z</published>
    <updated>2020-09-30T02:45:06.077Z</updated>
    
    <content type="html"><![CDATA[<p>统计所有小于非负整数 n 的质数的数量。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：n = 10输出：4解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</code></pre><p>示例 2：</p><pre><code>输入：n = 0输出：0</code></pre><p>示例 3：</p><pre><code>输入：n = 1输出：0</code></pre><p>提示：</p><pre><code>0 &lt;= n &lt;= 5 * 106</code></pre><h1 id="总括："><a href="#总括：" class="headerlink" title="总括："></a>总括：</h1><p>此篇题解将共讲述暴力算法、优化暴力算法、厄拉多塞（话说这位老哥第一个量了地球周长）所创造的厄拉多塞筛法、及运用厄拉多塞筛法时于内存上的优化方法。在解释思路时，将尽量一步步地进行详细解读。</p><p>希望对大家能有所帮助！</p><hr><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h1><h2 id="暴力法（计算超时）："><a href="#暴力法（计算超时）：" class="headerlink" title="暴力法（计算超时）："></a><strong>暴力法（计算超时）：</strong></h2><p>验证一个数是否为质数（素数）有很多方法。但最容易想到的莫非用暴力计算的方式一步步碾压过去的方法。虽然这种方法不是最优的，但是其对于我们了解素数仍是有所帮助的。</p><p>思路：验证某个数是否为质数时，将其对每一个比其小的数进行取余运算，并对取余为零的情况进行计数。由于质数是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。所以，当计数结果为 1 时，该数为质数。</p><p>在实际操作中，由于 1 和任意一个数必然取余为零，所以可以直接排除。并当没有取余为零的情况时，其才为质数。</p><p>得代码如下：</p><details>    <summary>暴力法Csharp</summary><figure class="highlight csharp"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountPrimes</span>(<span class="params"><span class="keyword">int</span> n</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> sign = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sign = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign)</span><br><span class="line">            count++; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力法C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> sign = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sign = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign)</span><br><span class="line">            count++; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="优化暴力算法："><a href="#优化暴力算法：" class="headerlink" title="优化暴力算法："></a><strong>优化暴力算法：</strong></h2><p>细究暴力计算的方法，我们可以发现，假如一个数为 9 ，那么其二分之一（4.5）后的数都可以不用进行计算，因为肯定是有余的 。事实上情况会比这更好一些：对正整数 n ，如果用 2 到 √n 之间(包含边界)的所有整数去除，均无法整除，则 n 为质数。</p><p>并且，我们可以发现，一切非 2 偶数一定不可能为质数。所以，我们可以在此处进行另一步的优化。</p><p>有个这些令人庆幸的发现，我们的代码也将如虎添翼：</p><details>    <summary>暴力法Csharp</summary><figure class="highlight csharp"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountPrimes</span>(<span class="params"><span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;;</span><br><span class="line">    <span class="comment">//从3开始验算，所以初始值为1（2为质数）。</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值</span></span><br><span class="line">        <span class="comment">//*如果 x = 2^n ，则 x &amp; (n - 1) == x % n</span></span><br><span class="line">        <span class="comment">//if(i % 2 == 0)</span></span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>; ;</span><br><span class="line">        <span class="keyword">bool</span> sign = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//用 j * j &lt;= i 代替 j &lt;= √i 会更好。</span></span><br><span class="line">        <span class="comment">//因为我们已经排除了所有偶数，所以每次循环加二将规避偶数会减少循环次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j * j &lt;=i; j+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sign = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign)</span><br><span class="line">            count++; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力法C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;;</span><br><span class="line">    <span class="comment">//从3开始验算，所以初始值为1（2为质数）。</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值</span></span><br><span class="line">        <span class="comment">//*如果 x = 2^n ，则 x &amp; (n - 1) == x % n</span></span><br><span class="line">        <span class="comment">//if(i % 2 == 0)</span></span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>; ;</span><br><span class="line">        <span class="keyword">bool</span> sign = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//用 j * j &lt;= i 代替 j &lt;= √i 会更好。</span></span><br><span class="line">        <span class="comment">//因为我们已经排除了所有偶数，所以每次循环加二将规避偶数会减少循环次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j * j &lt;=i; j+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                sign = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign)</span><br><span class="line">            count++; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力法Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (odd(i)) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">odd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>(暴力法系列的 C# 和 C++ 的代码几乎相同。)</p><p>经过对暴力算法的此番优化，我们的代码初步达到了应用的最低门槛，但显然还是不大理想，好似总感觉存在不必要的操作。但我们经过以上的研究（可以早一步排除偶数），再结合质数的性质，可以推想出：如果我们在进行顺序遍历时，每取得一个数（排除0、1），如果将它所有的倍数（排除0、1、本身）都清除，那么，剩下的数是不是必为素数？</p><p>没错，这个有趣且实用的方法便是著名的<strong>厄拉多塞筛法</strong>！</p><h2 id="三、厄拉多塞筛法："><a href="#三、厄拉多塞筛法：" class="headerlink" title="三、厄拉多塞筛法："></a><strong>三、厄拉多塞筛法：</strong></h2><p>使用厄拉多塞筛法进行 1 到 64 的质数查找的过程如下：</p><p> <a href="https://pic.leetcode-cn.com/a1faca1423ae40210283ae99735d3816702ccf4ea3d14b452bd31b52dc5c1ab7-%E8%B4%A8%E6%95%B001.png" target="_blank" rel="noopener">质数01.png</a> <a href="https://pic.leetcode-cn.com/9ce249c55336894269a24b07b24aeda45c9282d2bd7bcfe8b6a4924010f30c56-%E8%B4%A8%E6%95%B002.png" target="_blank" rel="noopener">质数02.png</a> <a href="https://pic.leetcode-cn.com/9907eb6310771945b98d85507e9ac396066eca6687d4a124d8d580cb4cb77331-%E8%B4%A8%E6%95%B003.png" target="_blank" rel="noopener">质数03.png</a> <a href="https://pic.leetcode-cn.com/44a83633f6e730b105c747efe1ea99f1ade9461278735ac1bb310264fe7f7890-%E8%B4%A8%E6%95%B004.png" target="_blank" rel="noopener">质数04.png</a> <a href="https://pic.leetcode-cn.com/11cdfac5138c3a0a1529407157264c066cc36b2acbd6160cb94fe848d5882c47-%E8%B4%A8%E6%95%B005.png" target="_blank" rel="noopener">质数05.png</a> <a href="https://pic.leetcode-cn.com/1474c46f44db885dd00a70dfb475d68cdde33a882cbd9f0e8f16561189441bd6-%E8%B4%A8%E6%95%B006.png" target="_blank" rel="noopener">质数06.png</a> <a href="https://pic.leetcode-cn.com/d1892c5f2c2fc9c76f7d998ac0bf57fa8f11579fb17a6e3305896d40c263b41e-%E8%B4%A8%E6%95%B007.png" target="_blank" rel="noopener">质数07.png</a> <a href="https://pic.leetcode-cn.com/4983199ef4fd10fff41c3e11f052793ea4c7e8fa1122ff1c31ece11a94eea561-%E8%B4%A8%E6%95%B008.png" target="_blank" rel="noopener">质数08.png</a> <a href="https://pic.leetcode-cn.com/cd1a2a9c42fc47a45c907c2e72f88421847d995275a677fd75c0eacce8996c06-%E8%B4%A8%E6%95%B009.png" target="_blank" rel="noopener">质数09.png</a> <a href="https://pic.leetcode-cn.com/e5172309e50d91eb5fced486d2b479677a6cbf594f157e18cc2b080b2cf7acdd-%E8%B4%A8%E6%95%B010.png" target="_blank" rel="noopener">质数10.png</a> <a href="https://pic.leetcode-cn.com/d9c9c9a293b63a9ae6b991f491add5a527b4ed0590c5c1e55bc1d7adf0bbcd30-%E8%B4%A8%E6%95%B011.png" target="_blank" rel="noopener">质数11.png</a> <a href="https://pic.leetcode-cn.com/f6bbb60ddcd9b5ad283163d9ac1612e128fc909120125192e86d77bdf80db6e9-%E8%B4%A8%E6%95%B012.png" target="_blank" rel="noopener">质数12.png</a> <a href="https://pic.leetcode-cn.com/95d13d8085953ddd6cba4298479fe110672e7331922b43b105c8eedaed14a870-%E8%B4%A8%E6%95%B013.png" target="_blank" rel="noopener">质数13.png</a> <a href="https://pic.leetcode-cn.com/9f6f86ac5a51f27e5abbeb25dd25cc527125ef7bcb3822e7ff6229b739166e7b-%E8%B4%A8%E6%95%B014.png" target="_blank" rel="noopener">质数14.png</a> <a href="https://pic.leetcode-cn.com/a81d726b272aec84d583574a6f8ab82245bf85591495a07aff84ed4f5db3db96-%E8%B4%A8%E6%95%B015.png" target="_blank" rel="noopener">质数15.png</a> <a href="https://pic.leetcode-cn.com/95be087f2ccf42f1e020ca2b762ab31eb82209c02a1f2dd5ddcf0ce3dec28eb3-%E8%B4%A8%E6%95%B016.png" target="_blank" rel="noopener">质数16.png</a> <a href="https://pic.leetcode-cn.com/d173b60cd95b8b6cbdadb8a8c5ccc477a8afd48093c3b4bac07216e1d0cd6b83-%E8%B4%A8%E6%95%B017.png" target="_blank" rel="noopener">质数17.png</a> </p><p>（做图片的时候把质数弄成了素数……）</p><p>对此，我们可以声明一个长度为最大限制数的布尔数组。用布尔值来区别筛选出的数和质数。</p><p>运用厄拉多塞筛法得代码如下：</p><details>    <summary>厄拉多塞筛法Csharp</summary><figure class="highlight csharp"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountPrimes</span>(<span class="params"><span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span>[] signs = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//因为在 C# 中，布尔类型的默认值为 假。所以在此处用了逻辑非（！）操作符。</span></span><br><span class="line">        <span class="keyword">if</span> (!signs[i])</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//排除不是质数的数</span></span><br><span class="line">                signs[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>厄拉多塞筛法C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始默认所有数为质数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; signs(n, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signs[i]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i) &#123;</span><br><span class="line">                <span class="comment">//排除不是质数的数</span></span><br><span class="line">                signs[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>厄拉多塞筛法Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] signs = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//因为在 Java 中，布尔类型的默认值为 假。所以在此处用了逻辑非（！）操作符。</span></span><br><span class="line">            <span class="keyword">if</span> (!signs[i]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i) &#123;</span><br><span class="line">                    signs[j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>## **四、运用比特表（Bitmap）算法对筛法进行内存优化：**<p>上面运用厄拉多塞筛法求一定范围内的质数已经十分高效了。然而，我们使用布尔数组标记一个数是否为质数时，每个值都占用了一个字节（Byte）。但是，我们仅需要两个不同的值来表示是否为质数即可。即一个比特（bit）来表示即可（0、1）。如果这样的话，我们便最优可节省八分之七的空间（然而，还得结合代码和实际情况，并不是用了就一定有效果）。</p><ul><li>关于比特表算法在此便简要概述以下（可略过）：</li></ul><p>假如有从 1 至 8 总共八个数。现有一个字节大小的内存空间可供使用（仅供参考，不考虑实际用途及比特算法的最佳用处）。如何将每个数登记下来，并可以随时检查一个数是否存在呢？</p><p>如果用一个数组表示，即使不考虑数组的内存开销，哪怕用一个 byte 类型的变量记录每一数也将超出内存可使用范围。但是由于每个字节共有八个比特位，则可以用每个比特位来表示每个数字则恰好可以登记完所有的数字。</p><p>示例：</p><ol><li>登记数字 1 ：0 0 0 0 0 0 0 1</li><li>登记数字 1、3：0 0 0 0 0 1 0 1</li><li>登记数字 1、2、3、4、5 ：0 0 0 1 1 1 1 1</li></ol><p>得代码如下：</p><details>    <summary>运用比特表Csharp</summary><figure class="highlight csharp"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountPrimes</span>(<span class="params"><span class="keyword">int</span> n</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//一个 int 变量占用 32 字节</span></span><br><span class="line">    <span class="comment">//在C#中，提供了点阵列（BitArray）数组，用这玩意可读性一定会好于我写的代码。</span></span><br><span class="line">    <span class="keyword">int</span>[] signs = <span class="keyword">new</span> <span class="keyword">int</span>[n / <span class="number">32</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将元素和需确定得数字经行按位或运算，如果值改变，说明不存在该数字（未登记该数字），则其为质数。</span></span><br><span class="line">        <span class="comment">//(当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值)</span></span><br><span class="line">        <span class="comment">//*如果 x = 2^n ，则 x &amp; (n - 1) == x % n</span></span><br><span class="line">        <span class="comment">//下面判断可以写成</span></span><br><span class="line">        <span class="comment">//if ((signs[i / size] &amp; (1 &lt;&lt; (i % 32))) == 0)</span></span><br><span class="line">        <span class="keyword">if</span> ((signs[i / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">31</span>))) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//登记该数字</span></span><br><span class="line">                signs[j / <span class="number">32</span>] |= <span class="number">1</span> &lt;&lt; (j &amp; <span class="number">31</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>运用比特表C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//一个 int 变量不知道占多少字节（但请注意，这里采用了常量）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; signs(n / size + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//将元素和需确定得数字经行按位或运算，如果值改变，说明不存在该数字（未登记该数字），则其为质数。</span></span><br><span class="line">        <span class="comment">//在C++中，其提供了 bitset 来操作位，在此便不做介绍了。如果用了，可读性肯定会更好。</span></span><br><span class="line">        <span class="comment">//(当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值)</span></span><br><span class="line">        <span class="comment">//*如果 x = 2^n ，则 x &amp; (n - 1) == x % n</span></span><br><span class="line">        <span class="comment">//下面判断可以写成</span></span><br><span class="line">        <span class="comment">//if ((signs[i / size] &amp; (1 &lt;&lt; (i % 32))) == 0)</span></span><br><span class="line">        <span class="keyword">if</span> ((signs[i / size] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; (size - <span class="number">1</span>)))) == <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i)&#123;</span><br><span class="line">                <span class="comment">//登记该数字</span></span><br><span class="line">            signs[j / size] |= <span class="number">1</span> &lt;&lt; (j &amp; (size - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>经测试，C# 内存优化效果较为明显，但 C++ 效果不大明显。但这种方法显然是为了特殊情况而准备（比如一亿个数）。不过也可能是我写的不好。仅作参考，如果有所错误恳请您斧正。<p>（其实有时候代码的可读性要胜于代码改动所带来的一点的性能上的提升。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计所有小于非负整数 n 的质数的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>191. 位1的个数</title>
    <link href="http://yoursite.com/2020/09/28/191.%20%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2020/09/28/191. 位1的个数/</id>
    <published>2020-09-28T03:27:12.000Z</published>
    <updated>2020-09-29T08:37:42.516Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &apos;1&apos;。</code></pre><p>示例 2：</p><pre><code>输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &apos;1&apos;。</code></pre><p>示例 3：</p><pre><code>输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &apos;1&apos;。</code></pre><p>提示：</p><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</p><p>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p><p>进阶:</p><pre><code>如果多次调用这个函数，你将如何优化你的算法？</code></pre><h1 id="方法-1：循环和位移动"><a href="#方法-1：循环和位移动" class="headerlink" title="方法 1：循环和位移动"></a>方法 1：循环和位移动</h1><p><strong>算法</strong></p><p>这个方法比较直接。我们遍历数字的 32 位。如果某一位是 <em>1</em> ，将计数器加一。</p><p>我们使用 <em>位掩码</em> 来检查数字的第 <em>i^{th}</em> 位。一开始，掩码 <em>m=1</em> 因为 <em>1</em> 的二进制表示是</p><pre><code>0000 0000 0000 0000 0000 0000 0000 0001</code></pre><p>显然，任何数字跟掩码 <em>1</em> 进行逻辑与运算，都可以让我们获得这个数字的最低位。检查下一位时，我们将掩码左移一位。</p><pre><code>0000 0000 0000 0000 0000 0000 0000 0010</code></pre><p>并重复此过程。</p><details>    <summary>循环和位移动</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">            bits++;</span><br><span class="line">        &#125;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(1)</em> 。运行时间依赖于数字 <em>n</em> 的位数。由于这题中 <em>n</em> 是一个 32 位数，所以运行时间是 <em>O(1)</em> 的。</p></li><li><p>空间复杂度：<em>O(1)</em>。没有使用额外空间。</p></li></ul><h1 id="方法-2：位操作的小技巧"><a href="#方法-2：位操作的小技巧" class="headerlink" title="方法 2：位操作的小技巧"></a>方法 2：位操作的小技巧</h1><p><strong>算法</strong></p><p>我们可以把前面的算法进行优化。我们不再检查数字的每一个位，而是不断把数字最后一个 <em>1</em> 反转，并把答案加一。当数字变成 <em>0</em> 的时候偶，我们就知道它没有 <em>1</em> 的位了，此时返回答案。</p><p>这里关键的想法是对于任意数字 <em>n</em> ，将 <em>n</em> 和 <em>n - 1</em> 做与运算，会把最后一个 <em>1</em> 的位变成 <em>0</em> 。为什么？考虑 <em>n</em> 和 <em>n - 1</em> 的二进制表示。</p><p><a href="https://pic.leetcode-cn.com/abfd6109e7482d70d20cb8fc1d632f90eacf1b5e89dfecb2e523da1bcb562f66-image.png" target="_blank" rel="noopener">image.png</a></p><p><em>图片 1. 将 *n</em> 和 <em>n-1</em> 做与运算会将最低位的 <em>1</em> 变成 <em>0*</em></p><p>在二进制表示中，数字 <em>n</em> 中最低位的 <em>1</em> 总是对应 <em>n - 1</em> 中的 <em>0</em> 。因此，将 <em>n</em> 和 <em>n - 1</em> 与运算总是能把 <em>n</em> 中最低位的 <em>1</em> 变成 <em>0</em> ，并保持其他位不变。</p><p>使用这个小技巧，代码变得非常简单。</p><details>    <summary>位操作的小技巧</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：<em>O(1)</em> 。运行时间与 <em>n</em> 中位为 <em>1</em> 的有关。在最坏情况下， <em>n</em> 中所有位都是 <em>1</em> 。对于 32 位整数，运行时间是 <em>O(1)</em> 的。</p></li><li><p>空间复杂度：<em>O(1)</em> 。没有使用额外空间。</p></li></ul><h1 id="位运算技巧"><a href="#位运算技巧" class="headerlink" title="位运算技巧"></a>位运算技巧</h1><h2 id="n-amp-n-1-把最后一个-1-的位变成-0"><a href="#n-amp-n-1-把最后一个-1-的位变成-0" class="headerlink" title="n &amp; (n-1) 把最后一个 1 的位变成 0"></a>n &amp; (n-1) 把最后一个 1 的位变成 0</h2><p>任意数字 n ，将 n 和 n - 1 做与运算，会把最后一个 1 的位变成 0</p><h2 id="n-amp-n-保留-n-最右边的-1"><a href="#n-amp-n-保留-n-最右边的-1" class="headerlink" title="n &amp; (-n) 保留 n 最右边的 1"></a>n &amp; (-n) 保留 <code>n</code> 最右边的 <code>1</code></h2><p>我们通过 <code>n &amp; (-n)</code> 保留 <code>n</code> 最右边的 <code>1</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>172. 阶乘后的零</title>
    <link href="http://yoursite.com/2020/09/27/172.%20%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/"/>
    <id>http://yoursite.com/2020/09/27/172. 阶乘后的零/</id>
    <published>2020-09-27T07:27:12.000Z</published>
    <updated>2020-09-27T07:56:47.989Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数 n，返回 n! 结果尾数中零的数量。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: 3输出: 0解释: 3! = 6, 尾数中没有零。</code></pre><p>示例 2:</p><pre><code>输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零.说明: 你算法的时间复杂度应为 O(log n) 。</code></pre><h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><p>看到这道题首先排除掉计算阶乘，先求乘数中含有10，5，2的个数，零的数量取决于这三个因子</p><details>    <summary>解法一</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int trailingZeroes(int n) &#123;</span><br><span class="line">        int numfive=0;</span><br><span class="line">        int numtwo=0;</span><br><span class="line">        int numten=0;</span><br><span class="line">        for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">            int i = j;</span><br><span class="line">            while (i % 10 == 0) &#123;</span><br><span class="line">                numten++;</span><br><span class="line">                i = i / 10;</span><br><span class="line">            &#125;</span><br><span class="line">            while (i % 5 == 0) &#123;</span><br><span class="line">                numfive++;</span><br><span class="line">                i = i / 5;</span><br><span class="line">            &#125;</span><br><span class="line">            while (i % 2 == 0) &#123;</span><br><span class="line">                numtwo++;</span><br><span class="line">                i = i / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return numten + Math.min(numfive, numtwo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>之前小红书面试的时候碰到的一道题，没想到又是 leetcode 的原题。这种没有通用解法的题，完全依靠于对题目的分析理解了，自己当时也是在面试官的提示下慢慢出来的，要是想不到题目的点，还是比较难做的。</p><p>首先肯定不能依赖于把阶乘算出来再去判断有多少个零了，因为阶乘很容易就溢出了，所以先一步一步理一下思路吧。</p><p>首先末尾有多少个 <code>0</code> ，只需要给当前数乘以一个 <code>10</code> 就可以加一个 <code>0</code>。</p><p>再具体对于 <code>5!</code>，也就是 <code>5 * 4 * 3 * 2 * 1 = 120</code>，我们发现结果会有一个 <code>0</code>，原因就是 <code>2</code> 和 <code>5</code> 相乘构成了一个 <code>10</code>。而对于 <code>10</code> 的话，其实也只有 <code>2 * 5</code>  可以构成，所以我们只需要找有多少对 <code>2/5</code>。</p><p>我们把每个乘数再稍微分解下，看一个例子。</p><p><code>11! = 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 = 11 * (2 * 5) * 9 * (4 * 2) * 7 * (3 * 2) * (1 * 5) * (2 * 2) * 3 * (1 * 2) * 1</code></p><p>对于含有 <code>2</code> 的因子的话是  <code>1 * 2, 2 * 2, 3 * 2, 4 * 2 ...</code></p><p>对于含有 <code>5</code> 的因子的话是  <code>1 * 5, 2 * 5...</code></p><p>含有 <code>2</code> 的因子每两个出现一次，含有 <code>5</code> 的因子每 <code>5</code> 个出现一次，所有 <code>2</code> 出现的个数远远多于 <code>5</code>，换言之找到一个 <code>5</code>，一定能找到一个 <code>2</code> 与之配对。所以我们只需要找有多少个 <code>5</code>。</p><p>直接的，我们只需要判断每个累乘的数有多少个 <code>5</code> 的因子即可。</p><details>    <summary>解法二</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = i;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                N /= <span class="number">5</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>但发生了超时，我们继续分析。</p><p>对于一个数的阶乘，就如之前分析的，<code>5</code> 的因子一定是每隔 <code>5</code> 个数出现一次，也就是下边的样子。</p><p><code>n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) *... * n</code></p><p>因为每隔 <code>5</code> 个数出现一个 <code>5</code>，所以计算出现了多少个 <code>5</code>，我们只需要用 <code>n/5</code> 就可以算出来。</p><p>但还没有结束，继续分析。</p><p><code>... * (1 * 5) * ... * (1 * 5 * 5) * ... * (2 * 5 * 5) * ... * (3 * 5 * 5) * ... * n</code></p><p>每隔 <code>25</code> 个数字，出现的是两个 <code>5</code>，所以除了每隔 <code>5</code> 个数算作一个 <code>5</code>，每隔 <code>25</code> 个数，还需要多算一个 <code>5</code>。</p><p>也就是我们需要再加上 <code>n / 25</code> 个 <code>5</code>。</p><p>同理我们还会发现每隔 <code>5 * 5 * 5 = 125</code> 个数字，会出现 <code>3</code> 个 <code>5</code>，所以我们还需要再加上 <code>n / 125</code> 。</p><p>综上，规律就是每隔 <code>5</code> 个数，出现一个 <code>5</code>，每隔 <code>25</code> 个数，出现 <code>2</code> 个 <code>5</code>，每隔 <code>125</code> 个数，出现 <code>3</code> 个 <code>5</code>… 以此类推。</p><p>最终 <code>5</code> 的个数就是 <code>n / 5 + n / 25 + n / 125 ...</code></p><p>写程序的话，如果直接按照上边的式子计算，分母可能会造成溢出。所以算 <code>n / 25</code> 的时候，我们先把 <code>n</code> 更新，<code>n = n / 5</code>，然后再计算 <code>n / 5</code> 即可。后边的同理。</p><details>    <summary>解法二</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        count += n / <span class="number">5</span>;</span><br><span class="line">        n = n / <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数 n，返回 n! 结果尾数中零的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>190. 颠倒二进制位</title>
    <link href="http://yoursite.com/2020/09/27/190.%20%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"/>
    <id>http://yoursite.com/2020/09/27/190. 颠倒二进制位/</id>
    <published>2020-09-27T07:27:12.000Z</published>
    <updated>2020-09-28T03:12:13.275Z</updated>
    
    <content type="html"><![CDATA[<p>颠倒给定的 32 位无符号整数的二进制位。</p><a id="more"></a><p>示例 1：</p><pre><code>输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</code></pre><p>示例 2：</p><pre><code>输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。</code></pre><p>提示：</p><pre><code>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</code></pre><p>进阶:</p><pre><code>如果多次调用这个函数，你将如何优化你的算法？</code></pre><h1 id="方法一：逐位颠倒"><a href="#方法一：逐位颠倒" class="headerlink" title="方法一：逐位颠倒"></a>方法一：逐位颠倒</h1><p>虽然这个问题并不难，但它常常是面试开始时的一个热身问题。重点是测试一个人对数据类型和位操作的基本知识。</p><p>在面试的时候逐位颠倒作为最直接的解决方案。</p><p><a href="https://pic.leetcode-cn.com/15bcf5b6db9b5211046655737571e3fe2668f9ecfc24ce517cd2b0882824aecd-file_1585801736085" target="_blank" rel="noopener">逐位颠倒</a></p><p>尽管听起来很简单，但上述逻辑的不同实现产生不同的解决方案。例如，要检索整数 <code>n</code> 中最右边的位，可以应用模运算（即 <code>n%2</code>）或与运算（即 <code>n &amp;1</code>）。另一个例子是，为了组合反转位（例如 <em>2^a，2^b</em>）的结果，可以使用加法运算（即 <em>2^a+2^b</em>）或再次使用位或运算（即 <em>2^a | 2^b</em>）。</p><p><strong>算法：</strong><br>在这里，我们将展示基于上述逻辑的实现示例。</p><p><a href="https://pic.leetcode-cn.com/ca2460d77758bd033e787f6b1602f5571891520acae4eefa7bcc7f1fe48b5a2e-file_1585801736110" target="_blank" rel="noopener">实现示例</a><br>关键思想是，对于位于索引 <code>i</code> 处的位，在反转之后，其位置应为 <code>31-i</code>（注：索引从零开始）。</p><ul><li>我们从右到左遍历输入整数的位字符串（即 <code>n=n&gt;&gt;1</code>）。要检索整数的最右边的位，我们应用与运算（<code>n&amp;1</code>）。</li><li>对于每个位，我们将其反转到正确的位置（即<code>（n&amp;1）&lt;&lt;power</code>）。然后添加到最终结果。</li><li>当 <code>n==0</code> 时，我们终止迭代。</li></ul><details>    <summary>逐位颠倒Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 1. 将给定的二进制数,由低到高位逐个取出</span></span><br><span class="line">            <span class="comment">// 1.1 右移 i 位,</span></span><br><span class="line">            <span class="keyword">int</span> tmp = n &gt;&gt; i;</span><br><span class="line">            <span class="comment">// 1.2  取有效位</span></span><br><span class="line">            tmp = tmp &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 2. 然后通过位运算将其放置到反转后的位置.</span></span><br><span class="line">            tmp = tmp &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">            <span class="comment">// 3. 将上述结果再次通过运算结合到一起</span></span><br><span class="line">            result |= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>逐位颠倒Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n, an integer</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        ret, power = <span class="number">0</span>, <span class="number">31</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            ret += (n &amp; <span class="number">1</span>) &lt;&lt; power</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">            power -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></details><details>    <summary>逐位颠倒C++</summary><figure class="highlight c++"><figcaption><span>[solution1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ret = <span class="number">0</span>, power = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">      ret += (n &amp; <span class="number">1</span>) &lt;&lt; power;</span><br><span class="line">      n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      power -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>逐位颠倒Go</summary><figure class="highlight go"><figcaption><span>[solution1-Go]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBits</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    ret := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line">    power := <span class="keyword">uint32</span>(<span class="number">31</span>)</span><br><span class="line">    <span class="keyword">for</span> num != <span class="number">0</span> &#123;</span><br><span class="line">        ret += (num &amp; <span class="number">1</span>) &lt;&lt; power</span><br><span class="line">        num = num &gt;&gt; <span class="number">1</span></span><br><span class="line">        power -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li>时间复杂度：log_2(N) 。在算法中，我们有一个循环来迭代输入的最高非零位，即log_2(N)  。</li><li>空间复杂度：O(1) ，因为不管输入是什么，内存的消耗是固定的。</li></ul><h1 id="方法二：带记忆化的按字节颠倒"><a href="#方法二：带记忆化的按字节颠倒" class="headerlink" title="方法二：带记忆化的按字节颠倒"></a>方法二：带记忆化的按字节颠倒</h1><p>有人可能会说，每字节（8 位的比特位）反转可能更有效。由于该题的输入是固定的 32 位整数，所以在本题中不一定是这样的。但是在处理长字节流时，它会变得更有效。</p><p><a href="https://pic.leetcode-cn.com/365599a4030d26a019d37ad97c201e64e2fa3ae9fd7b43d689e8a4d7f802141e-file_1585801736122" target="_blank" rel="noopener">带记忆化的按字节颠倒</a></p><p>使用字节作为迭代单位的另一个隐含优点是，我们可以使用记忆化技术，可以缓存先前计算的值，以避免重新计算。</p><p>记忆化的后续问题是：如果该函数多次被调用，你该如何优化。</p><p>若要按自己为单位反转位，可以应用上述所示的算法。在这里，我们展示一种完全基于算术和位操作，不基于任何循环语句，如下所示：</p><figure class="highlight python"><figcaption><span>[example-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseByte</span><span class="params">(byte)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (byte * <span class="number">0x0202020202</span> &amp; <span class="number">0x010884422010</span>) % <span class="number">1023</span></span><br></pre></td></tr></table></figure><p>这个算法为用 3 个操作反转一个字节中的位，在 Sean Eron Anderson 的在线电子书 Bit Twiddling Hacks 中可以看到更多的细节。</p><p><strong>算法：</strong></p><ul><li>我们按字节遍历整数。为了检索整数中最右边的字节，我们应用位掩码为 <code>11111111</code> 的与操作（即 <code>n&amp;0xff</code>）。</li><li>对于每个字节，首先我们通过一个名为 <code>reverseByte(byte)</code> 的函数来反转字节中的位。然后将反转的结果添加到答案中。</li><li>对于函数 <code>reverseByte(byte)</code>，我们使用记忆化技术，它缓存函数的结果并直接返回结果，以便将来遇到相同的输入。</li></ul><p>注意，可以选择更小的单位而不是字节，例如 4 位的单位，这将需要更多的计算来交换更少的缓存空间。记忆化技术是空间和计算时间之间的权衡。</p><details>    <summary>带记忆化的按字节颠倒Python</summary><figure class="highlight python"><figcaption><span>[solution21-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n, an integer</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        ret, power = <span class="number">0</span>, <span class="number">24</span></span><br><span class="line">        cache = dict()</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            ret += self.reverseByte(n &amp; <span class="number">0xff</span>, cache) &lt;&lt; power</span><br><span class="line">            n = n &gt;&gt; <span class="number">8</span></span><br><span class="line">            power -= <span class="number">8</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseByte</span><span class="params">(self, byte, cache)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> byte <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">            cache[byte] = (byte * <span class="number">0x0202020202</span> &amp; <span class="number">0x010884422010</span>) % <span class="number">1023</span> </span><br><span class="line">        <span class="keyword">return</span> cache[byte]</span><br></pre></td></tr></table></figure></details><details>    <summary>带记忆化的按字节颠倒Python</summary><figure class="highlight python"><figcaption><span>[solution21-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n, an integer</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        ret, power = <span class="number">0</span>, <span class="number">24</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            ret += self.reverseByte(n &amp; <span class="number">0xff</span>) &lt;&lt; power</span><br><span class="line">            n = n &gt;&gt; <span class="number">8</span></span><br><span class="line">            power -= <span class="number">8</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="comment"># memoization with decorator</span></span><br><span class="line"><span class="meta">    @functools.lru_cache(maxsize=256)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseByte</span><span class="params">(self, byte)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (byte * <span class="number">0x0202020202</span> &amp; <span class="number">0x010884422010</span>) % <span class="number">1023</span></span><br></pre></td></tr></table></figure></details><details>    <summary>带记忆化的按字节颠倒C++</summary><figure class="highlight c++"><figcaption><span>[solution21-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseByte(<span class="keyword">uint32_t</span> byte, <span class="built_in">map</span>&lt;<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>&gt; cache) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.find(byte) != cache.end()) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[byte];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">uint32_t</span> value = (byte * <span class="number">0x0202020202</span> &amp; <span class="number">0x010884422010</span>) % <span class="number">1023</span>;</span><br><span class="line">        cache.emplace(byte, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> ret = <span class="number">0</span>, power = <span class="number">24</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>&gt; cache;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            ret += reverseByte(n &amp; <span class="number">0xff</span>, cache) &lt;&lt; power;</span><br><span class="line">            n = n &gt;&gt; <span class="number">8</span>;</span><br><span class="line">            power -= <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>带记忆化的按字节颠倒Go</summary><figure class="highlight go"><figcaption><span>[solution21-Go]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseByte</span><span class="params">(b <span class="keyword">uint32</span>, cache <span class="keyword">map</span>[<span class="keyword">uint32</span>]<span class="keyword">uint64</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    value, ok := cache[b]</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    value = (<span class="keyword">uint64</span>(b) * <span class="number">0x0202020202</span> &amp; <span class="number">0x010884422010</span>) % <span class="number">1023</span></span><br><span class="line">    cache[b] = value</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBits</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    ret := <span class="keyword">uint64</span>(<span class="number">0</span>)</span><br><span class="line">    power := <span class="keyword">uint64</span>(<span class="number">24</span>)</span><br><span class="line">    <span class="keyword">var</span> cache = <span class="keyword">map</span>[<span class="keyword">uint32</span>]<span class="keyword">uint64</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num != <span class="number">0</span> &#123;</span><br><span class="line">        ret += reverseByte(num &amp; <span class="number">0xff</span>, cache) &lt;&lt; power</span><br><span class="line">        num = num &gt;&gt; <span class="number">8</span></span><br><span class="line">        power -= <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">uint32</span>(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(1) 。尽管我们在算法中有一个循环，但是无论输入是什么，迭代次数都是固定的，因为在我们的问题中整数是固定大小（32 位）的。</li><li>空间复杂度：O(1) ，同样，尽管我们使用了缓存来保留反转字节的结果，但缓存中的大小总数限制为 <em>2^8=256</em>。</li></ul><h1 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h1><p>在方法 2 中，我们展示了一个关于如何在不使用循环语句的情况下反转字节中的位的示例。</p><p><strong>在面试过程中，你可能会被要求在不使用循环的情况下反转整个 32 位。</strong> </p><p>在这里，我们提出了一种只使用位操作的解决方案。</p><p>这种思想可以看作是一种分治的策略，我们通过掩码将 32 位整数划分成具有较少位的块，然后通过将每个块反转，最后将每个块的结果合并得到最终结果。</p><p>在下图中，我们演示如何使用上述思想反转两个位。同样的，这个想法可以应用到比特块上。</p><p><a href="https://pic.leetcode-cn.com/c57a82424197ba1f4091a67cc4a6c575b35dcc0bf9d077415838d3b22d4b1ff3-file_1585801736118" target="_blank" rel="noopener">不使用循环语句的情况下反转字节中的位</a></p><p><strong>算法：</strong></p><p>我们可以通过以下步骤实现该算法：</p><ul><li>首先，我们将原来的 32 位分为 2 个 16 位的块。</li><li>然后我们将 16 位块分成 2 个 8 位的块。</li><li>然后我们继续将这些块分成更小的块，直到达到 1 位的块。</li><li>在上述每个步骤中，我们将中间结果合并为一个整数，作为下一步的输入。</li></ul><p>既然知道 int 值一共32位，那么可以采用分治思想，反转左右16位，然后反转每个16位中的左右8位，依次类推，最后反转2位，反转后合并即可，同时可以利用位运算在原地反转。JDK中的Integer.bitCount()函数也是使用类似的方法。</p><p>这么说比较抽象，可以直接结合代码看下面的步骤，也可以拿代码在IDE中debug一下，看每一步都做了什么</p><ol><li>首先随便找一个数 (为了看的清楚用_作分隔，可以忽略)</li></ol><pre><code>十进制43261596;   // 0000 ‭0010 1001 0100 _ 0001 1110 1001 1100‬</code></pre><ol start="2"><li>左边16位移到右边，右边16位移到左边，然后使用|符号合并起来</li></ol><pre><code>Java中的无符号位移 &gt;&gt;&gt;：无论是正数还是负数，高位通通补0。&gt;&gt;：带符号右移。正数右移高位补0，负数右移高位补1。|：按位或逻辑，该位只要有一位为1，结果就为1，这里用来合并</code></pre><ol start="3"><li>使用一些有规律的数，将16位，再分成左右8位进行反转后合并，起始数字变为‭0001 1110 1001 1100 _ 0000 0010 1001 0100‬</li></ol><pre><code>0xff00ff00 表示16进制数1111 1111 0000 0000 _ 1111 1111 0000 0000 ，0x00ff00ff 表示16进制数0000 0000 1111 1111 _ 0000 0000 1111 1111，</code></pre><ol start="4"><li><p>重复以上步骤，分组、合并，最后得到反转后的结果。</p></li><li><p>总结来说就是利用位运算进行反转，同时存储反转后的数，继续分治进行反转，直到全部反转完成，变化过程为：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 原数字43261596</span><br><span class="line"> 0000 ‭0010 1001 0100 _ 0001 1110 1001 1100‬ </span><br><span class="line">// 反转左右16位：</span><br><span class="line">‭ 0001 1110 1001 1100 _ 0000 0010 1001 0100‬ </span><br><span class="line">// 继续分为8位一组反转：</span><br><span class="line"> 1001 1100 0001 1110 _ 1001 0100 0000 0010</span><br><span class="line">// 4位一组反转：</span><br><span class="line"> 1100 1001 1110 0001 _ 0100 1001 0010 0000‬</span><br><span class="line">// 2位一组反转：</span><br><span class="line"> 0011 0110 1011 0100 _ 0001 0110 1000 0000</span><br><span class="line">// 每两位再反转一下</span><br><span class="line">‭ 0011 1001 0111 1000 _ 0010 1001 0100 0000‬‬</span><br><span class="line">// 这就是43261596反转后的结果：‭964176192‬</span><br></pre></td></tr></table></figure><details>    <summary>不使用循环语句的情况下反转字节中的位Java</summary><figure class="highlight java"><figcaption><span>[solution3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n = (n &gt;&gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>); </span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>); </span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>); </span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>); </span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>不使用循环语句的情况下反转字节中的位Python</summary><figure class="highlight python"><figcaption><span>[solution3-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n, an integer</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        n = (n &gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure></details><details>    <summary>不使用循环语句的情况下反转字节中的位C++</summary><figure class="highlight c++"><figcaption><span>[solution3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        n = (n &gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>不使用循环语句的情况下反转字节中的位Go</summary><figure class="highlight go"><figcaption><span>[solution3-Go]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBits</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    num = (num &gt;&gt; <span class="number">16</span>) | (num &lt;&lt; <span class="number">16</span>)</span><br><span class="line">    num = ((num &amp; <span class="number">0xff00ff</span>00) &gt;&gt; <span class="number">8</span>) | ((num &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">    num = ((num &amp; <span class="number">0xf0f0f0f</span>0) &gt;&gt; <span class="number">4</span>) | ((num &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>)</span><br><span class="line">    num = ((num &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((num &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>)</span><br><span class="line">    num = ((num &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((num &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(1) ，没有使用循环。</li><li>空间复杂度：O(1) ，没有使用变量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;颠倒给定的 32 位无符号整数的二进制位。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
</feed>
