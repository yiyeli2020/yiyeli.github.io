title: 2. ä¸¤æ•°ç›¸åŠ 

date: 2020-11-20 11:30:12

categories: 2020å¹´11æœˆ

tags: [Leetcode, Math, Linked List]

---

ç»™å‡ºä¸¤ä¸ª éç©º çš„é“¾è¡¨ç”¨æ¥è¡¨ç¤ºä¸¤ä¸ªéè´Ÿçš„æ•´æ•°ã€‚å…¶ä¸­ï¼Œå®ƒä»¬å„è‡ªçš„ä½æ•°æ˜¯æŒ‰ç…§ é€†åº çš„æ–¹å¼å­˜å‚¨çš„ï¼Œå¹¶ä¸”å®ƒä»¬çš„æ¯ä¸ªèŠ‚ç‚¹åªèƒ½å­˜å‚¨ ä¸€ä½ æ•°å­—ã€‚

å¦‚æœï¼Œæˆ‘ä»¬å°†è¿™ä¸¤ä¸ªæ•°ç›¸åŠ èµ·æ¥ï¼Œåˆ™ä¼šè¿”å›ä¸€ä¸ªæ–°çš„é“¾è¡¨æ¥è¡¨ç¤ºå®ƒä»¬çš„å’Œã€‚

æ‚¨å¯ä»¥å‡è®¾é™¤äº†æ•°å­— 0 ä¹‹å¤–ï¼Œè¿™ä¸¤ä¸ªæ•°éƒ½ä¸ä¼šä»¥ 0 å¼€å¤´ã€‚

<!-- more -->


ç¤ºä¾‹ï¼š
    
    è¾“å…¥ï¼š(2 -> 4 -> 3) + (5 -> 6 -> 4)
    è¾“å‡ºï¼š7 -> 0 -> 8
    åŸå› ï¼š342 + 465 = 807
    
# ğŸ“– æ–‡å­—é¢˜è§£
## æ–¹æ³•ä¸€ï¼šæ¨¡æ‹Ÿ

**æ€è·¯ä¸ç®—æ³•**

ç”±äºè¾“å…¥çš„ä¸¤ä¸ªé“¾è¡¨éƒ½æ˜¯**é€†åº**å­˜å‚¨æ•°å­—çš„ä½æ•°çš„ï¼Œå› æ­¤ä¸¤ä¸ªé“¾è¡¨ä¸­åŒä¸€ä½ç½®çš„æ•°å­—å¯ä»¥ç›´æ¥ç›¸åŠ ã€‚

æˆ‘ä»¬åŒæ—¶éå†ä¸¤ä¸ªé“¾è¡¨ï¼Œé€ä½è®¡ç®—å®ƒä»¬çš„å’Œï¼Œå¹¶ä¸å½“å‰ä½ç½®çš„è¿›ä½å€¼ç›¸åŠ ã€‚å…·ä½“è€Œè¨€ï¼Œå¦‚æœå½“å‰ä¸¤ä¸ªé“¾è¡¨å¤„ç›¸åº”ä½ç½®çš„æ•°å­—ä¸º *n1,n2*ï¼Œè¿›ä½å€¼ä¸º carry ï¼Œåˆ™å®ƒä»¬çš„å’Œä¸º n1+n2+carryï¼›å…¶ä¸­ï¼Œç­”æ¡ˆé“¾è¡¨å¤„ç›¸åº”ä½ç½®çš„æ•°å­—ä¸º (n1+n2+carry)%10 ï¼Œè€Œæ–°çš„è¿›ä½å€¼ä¸º(n1+n2+carry)/10ã€‚

å¦‚æœä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ä¸åŒï¼Œåˆ™å¯ä»¥è®¤ä¸ºé•¿åº¦çŸ­çš„é“¾è¡¨çš„åé¢æœ‰è‹¥å¹²ä¸ª *0* ã€‚

æ­¤å¤–ï¼Œå¦‚æœé“¾è¡¨éå†ç»“æŸåï¼Œæœ‰ carry>0 ï¼Œè¿˜éœ€è¦åœ¨ç­”æ¡ˆé“¾è¡¨çš„åé¢é™„åŠ ä¸€ä¸ªèŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹çš„å€¼ä¸º carryã€‚

<details> 
    <summary>æˆ‘çš„åˆå§‹è§£æ³•Java</summary>

```
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        List<String> list = new ArrayList();
        int add = 0;
        ListNode dummy = new ListNode(-1);
        ListNode curr = dummy;
        while (l1 != null && l2 != null) {
            ListNode p = new ListNode((l1.val + l2.val + add) % 10);
            add = (l1.val + l2.val + add) / 10;
            curr.next = p;
            curr = curr.next;
            l1 = l1.next;
            l2 = l2.next;

        }
        if (l1 == null && l2 == null) {
            if (add != 0) {
                ListNode p = new ListNode(add);
                curr.next = p;
            }
        } else {
            curr.next = (l1 != null) ? l1 : l2;
            curr = curr.next;
            ListNode pre = new ListNode(-1);
            while (curr != null) {
                int temp=curr.val;
                curr.val = (temp + add) % 10;
                add = (temp + add) / 10;
                pre = curr;
                curr = curr.next;
            }
            if (add != 0) {
                ListNode p = new ListNode(add);
                pre.next = p;
            }
        }
        return dummy.next;
    }
```
</details>


**è¸©çš„å‘**
æ³¨æ„åœ¨ç´¯åŠ è®¡ç®—æ—¶å…ˆç”¨ä¸´æ—¶å€¼å­˜å‚¨,ä»¥å…æ”¹å˜å½“å‰çš„å€¼ã€‚


**ä»£ç **
<details> 
    <summary>æ¨¡æ‹ŸC++</summary>

```C++ [sol1-C++]
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *head = nullptr, *tail = nullptr;
        int carry = 0;
        while (l1 || l2) {
            int n1 = l1 ? l1->val: 0;
            int n2 = l2 ? l2->val: 0;
            int sum = n1 + n2 + carry;
            if (!head) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail->next = new ListNode(sum % 10);
                tail = tail->next;
            }
            carry = sum / 10;
            if (l1) {
                l1 = l1->next;
            }
            if (l2) {
                l2 = l2->next;
            }
        }
        if (carry > 0) {
            tail->next = new ListNode(carry);
        }
        return head;
    }
};
```
</details>
<details> 
    <summary>æ¨¡æ‹ŸJava</summary>

```Java [sol1-Java]
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = null, tail = null;
        int carry = 0;
        while (l1 != null || l2 != null) {
            int n1 = l1 != null ? l1.val : 0;
            int n2 = l2 != null ? l2.val : 0;
            int sum = n1 + n2 + carry;
            if (head == null) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail.next = new ListNode(sum % 10);
                tail = tail.next;
            }
            carry = sum / 10;
            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
        if (carry > 0) {
            tail.next = new ListNode(carry);
        }
        return head;
    }
}
```
</details>
<details> 
    <summary>æ¨¡æ‹ŸJavaScript</summary>

```JavaScript [sol1-JavaScript]
var addTwoNumbers = function(l1, l2) {
    let head = null, tail = null;
    let carry = 0;
    while (l1 || l2) {
        const n1 = l1 ? l1.val : 0;
        const n2 = l2 ? l2.val : 0;
        const sum = n1 + n2 + carry;
        if (!head) {
            head = tail = new ListNode(sum % 10);
        } else {
            tail.next = new ListNode(sum % 10);
            tail = tail.next;
        }
        carry = Math.floor(sum / 10);
        if (l1) {
            l1 = l1.next;
        }
        if (l2) {
            l2 = l2.next;
        }
    }
    if (carry > 0) {
        tail.next = new ListNode(carry);
    }
    return head;
};
```
</details>
<details> 
    <summary>æ¨¡æ‹ŸGolang</summary>

```Golang [sol1-Golang]
func addTwoNumbers(l1, l2 *ListNode) (head *ListNode) {
    var tail *ListNode
    carry := 0
    for l1 != nil || l2 != nil {
        n1, n2 := 0, 0
        if l1 != nil {
            n1 = l1.Val
            l1 = l1.Next
        }
        if l2 != nil {
            n2 = l2.Val
            l2 = l2.Next
        }
        sum := n1 + n2 + carry
        sum, carry = sum%10, sum/10
        if head == nil {
            head = &ListNode{Val: sum}
            tail = head
        } else {
            tail.Next = &ListNode{Val: sum}
            tail = tail.Next
        }
    }
    if carry > 0 {
        tail.Next = &ListNode{Val: carry}
    }
    return
}
```
</details>
<details> 
    <summary>æ¨¡æ‹ŸC</summary>

```C [sol1-C]
struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {
    struct ListNode *head = NULL, *tail = NULL;
    int carry = 0;
    while (l1 || l2) {
        int n1 = l1 ? l1->val : 0;
        int n2 = l2 ? l2->val : 0;
        int sum = n1 + n2 + carry;
        if (!head) {
            head = tail = malloc(sizeof(struct ListNode));
            tail->val = sum % 10;
            tail->next = NULL;
        } else {
            tail->next = malloc(sizeof(struct ListNode));
            tail->next->val = sum % 10;
            tail = tail->next;
            tail->next = NULL;
        }
        carry = sum / 10;
        if (l1) {
            l1 = l1->next;
        }
        if (l2) {
            l2 = l2->next;
        }
    }
    if (carry > 0) {
        tail->next = malloc(sizeof(struct ListNode));
        tail->next->val = carry;
        tail->next->next = NULL;
    }
    return head;
}
```

</details>
**å¤æ‚åº¦åˆ†æ**
- æ—¶é—´å¤æ‚åº¦ï¼šO(max(m,n)) ï¼Œå…¶ä¸­ *m,n* ä¸ºä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ã€‚æˆ‘ä»¬è¦éå†ä¸¤ä¸ªé“¾è¡¨çš„å…¨éƒ¨ä½ç½®ï¼Œè€Œå¤„ç†æ¯ä¸ªä½ç½®åªéœ€è¦ *O(1)* çš„æ—¶é—´ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šO(max(m,n)) ã€‚ç­”æ¡ˆé“¾è¡¨çš„é•¿åº¦æœ€å¤šä¸ºè¾ƒé•¿é“¾è¡¨çš„é•¿åº¦ *+1*ã€‚