
title: 103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†

date: 2022-9-23 15:39:12

categories: 2022å¹´9æœˆ

tags: [Leetcode,Tree, Breadth-First Search, Binary Tree]

---

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ é”¯é½¿å½¢å±‚åºéå† ã€‚ï¼ˆå³å…ˆä»å·¦å¾€å³ï¼Œå†ä»å³å¾€å·¦è¿›è¡Œä¸‹ä¸€å±‚éå†ï¼Œä»¥æ­¤ç±»æ¨ï¼Œå±‚ä¸å±‚ä¹‹é—´äº¤æ›¿è¿›è¡Œï¼‰ã€‚




<!-- more -->


ç¤ºä¾‹ 1ï¼š

    è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
    è¾“å‡ºï¼š[[3],[20,9],[15,7]]

ç¤ºä¾‹ 2ï¼š

    è¾“å…¥ï¼šroot = [1]
    è¾“å‡ºï¼š[[1]]
ç¤ºä¾‹ 3ï¼š

    è¾“å…¥ï¼šroot = []
    è¾“å‡ºï¼š[]


æç¤ºï¼š

æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ [0, 2000] å†…
-100 <= Node.val <= 100


[TOC]

# ğŸ“– æ–‡å­—é¢˜è§£

## æ–¹æ³•ä¸€ï¼šå¹¿åº¦ä¼˜å…ˆéå†

æ­¤é¢˜æ˜¯ã€Œ102. äºŒå‰æ ‘çš„å±‚åºéå†ã€çš„å˜ç§ï¼Œæœ€åè¾“å‡ºçš„è¦æ±‚æœ‰æ‰€å˜åŒ–ï¼Œè¦æ±‚æˆ‘ä»¬æŒ‰å±‚æ•°çš„å¥‡å¶æ¥å†³å®šæ¯ä¸€å±‚çš„è¾“å‡ºé¡ºåºã€‚è§„å®šäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ä¸ºç¬¬ 
0
0 å±‚ï¼Œå¦‚æœå½“å‰å±‚æ•°æ˜¯å¶æ•°ï¼Œä»å·¦è‡³å³è¾“å‡ºå½“å‰å±‚çš„èŠ‚ç‚¹å€¼ï¼Œå¦åˆ™ï¼Œä»å³è‡³å·¦è¾“å‡ºå½“å‰å±‚çš„èŠ‚ç‚¹å€¼ã€‚

æˆ‘ä»¬ä¾ç„¶å¯ä»¥æ²¿ç”¨ç¬¬ 102 é¢˜çš„æ€æƒ³ï¼Œä¿®æ”¹å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œå¯¹æ ‘è¿›è¡Œé€å±‚éå†ï¼Œç”¨é˜Ÿåˆ—ç»´æŠ¤å½“å‰å±‚çš„æ‰€æœ‰å…ƒç´ ï¼Œå½“é˜Ÿåˆ—ä¸ä¸ºç©ºçš„æ—¶å€™ï¼Œæ±‚å¾—å½“å‰é˜Ÿåˆ—çš„é•¿åº¦ sizeï¼Œæ¯æ¬¡ä»é˜Ÿåˆ—ä¸­å–å‡º size ä¸ªå…ƒç´ è¿›è¡Œæ‹“å±•ï¼Œç„¶åè¿›è¡Œä¸‹ä¸€æ¬¡è¿­ä»£ã€‚

ä¸ºäº†æ»¡è¶³é¢˜ç›®è¦æ±‚çš„è¿”å›å€¼ä¸ºã€Œå…ˆä»å·¦å¾€å³ï¼Œå†ä»å³å¾€å·¦ã€äº¤æ›¿è¾“å‡ºçš„é”¯é½¿å½¢ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨ã€ŒåŒç«¯é˜Ÿåˆ—ã€çš„æ•°æ®ç»“æ„æ¥ç»´æŠ¤å½“å‰å±‚èŠ‚ç‚¹å€¼è¾“å‡ºçš„é¡ºåºã€‚

åŒç«¯é˜Ÿåˆ—æ˜¯ä¸€ä¸ªå¯ä»¥åœ¨é˜Ÿåˆ—ä»»æ„ä¸€ç«¯æ’å…¥å…ƒç´ çš„é˜Ÿåˆ—ã€‚åœ¨å¹¿åº¦ä¼˜å…ˆæœç´¢éå†å½“å‰å±‚èŠ‚ç‚¹æ‹“å±•ä¸‹ä¸€å±‚èŠ‚ç‚¹çš„æ—¶å€™æˆ‘ä»¬ä»ç„¶ä»å·¦å¾€å³æŒ‰é¡ºåºæ‹“å±•ï¼Œä½†æ˜¯å¯¹å½“å‰å±‚èŠ‚ç‚¹çš„å­˜å‚¨æˆ‘ä»¬ç»´æŠ¤ä¸€ä¸ªå˜é‡ isOrderLeft è®°å½•æ˜¯ä»å·¦è‡³å³è¿˜æ˜¯ä»å³è‡³å·¦çš„ï¼š

å¦‚æœä»å·¦è‡³å³ï¼Œæˆ‘ä»¬æ¯æ¬¡å°†è¢«éå†åˆ°çš„å…ƒç´ æ’å…¥è‡³åŒç«¯é˜Ÿåˆ—çš„æœ«å°¾ã€‚
å¦‚æœä»å³è‡³å·¦ï¼Œæˆ‘ä»¬æ¯æ¬¡å°†è¢«éå†åˆ°çš„å…ƒç´ æ’å…¥è‡³åŒç«¯é˜Ÿåˆ—çš„å¤´éƒ¨ã€‚
å½“éå†ç»“æŸçš„æ—¶å€™æˆ‘ä»¬å°±å¾—åˆ°äº†ç­”æ¡ˆæ•°ç»„ã€‚


<details>
    <summary>C++</summary>
    
```
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if (!root) {
            return ans;
        }

        queue<TreeNode*> nodeQueue;
        nodeQueue.push(root);
        bool isOrderLeft = true;

        while (!nodeQueue.empty()) {
            deque<int> levelList;
            int size = nodeQueue.size();
            for (int i = 0; i < size; ++i) {
                auto node = nodeQueue.front();
                nodeQueue.pop();
                if (isOrderLeft) {
                    levelList.push_back(node->val);
                } else {
                    levelList.push_front(node->val);
                }
                if (node->left) {
                    nodeQueue.push(node->left);
                }
                if (node->right) {
                    nodeQueue.push(node->right);
                }
            }
            ans.emplace_back(vector<int>{levelList.begin(), levelList.end()});
            isOrderLeft = !isOrderLeft;
        }

        return ans;
    }
};
```
</details>

<details>
    <summary>Java</summary>
    
```
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans = new LinkedList<List<Integer>>();
        if (root == null) {
            return ans;
        }

        Queue<TreeNode> nodeQueue = new ArrayDeque<TreeNode>();
        nodeQueue.offer(root);
        boolean isOrderLeft = true;

        while (!nodeQueue.isEmpty()) {
            Deque<Integer> levelList = new LinkedList<Integer>();
            int size = nodeQueue.size();
            for (int i = 0; i < size; ++i) {
                TreeNode curNode = nodeQueue.poll();
                if (isOrderLeft) {
                    levelList.offerLast(curNode.val);
                } else {
                    levelList.offerFirst(curNode.val);
                }
                if (curNode.left != null) {
                    nodeQueue.offer(curNode.left);
                }
                if (curNode.right != null) {
                    nodeQueue.offer(curNode.right);
                }
            }
            ans.add(new LinkedList<Integer>(levelList));
            isOrderLeft = !isOrderLeft;
        }

        return ans;
    }
}

```
</details>

<details>
    <summary>JavaScript</summary>
    
```
var zigzagLevelOrder = function(root) {
    if (!root) {
        return [];
    }

    const ans = [];
    const nodeQueue = [root];

    let isOrderLeft = true;

    while (nodeQueue.length) {
        let levelList = [];
        const size = nodeQueue.length;
        for (let i = 0; i < size; ++i) {
            const node = nodeQueue.shift();
            if (isOrderLeft) {
                levelList.push(node.val);
            } else {
                levelList.unshift(node.val);
            }
            if (node.left !== null) {
                nodeQueue.push(node.left);
            }
            if (node.right !== null) {
                nodeQueue.push(node.right);
            }
        }            
        ans.push(levelList);
        isOrderLeft = !isOrderLeft;
    }

    return ans;
};

```
</details>

<details>
    <summary>Golang</summary>
    
```
func zigzagLevelOrder(root *TreeNode) (ans [][]int) {
    if root == nil {
        return
    }
    queue := []*TreeNode{root}
    for level := 0; len(queue) > 0; level++ {
        vals := []int{}
        q := queue
        queue = nil
        for _, node := range q {
            vals = append(vals, node.Val)
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
        // æœ¬è´¨ä¸Šå’Œå±‚åºéå†ä¸€æ ·ï¼Œæˆ‘ä»¬åªéœ€è¦æŠŠå¥‡æ•°å±‚çš„å…ƒç´ ç¿»è½¬å³å¯
        if level%2 == 1 {
            for i, n := 0, len(vals); i < n/2; i++ {
                vals[i], vals[n-1-i] = vals[n-1-i], vals[i]
            }
        }
        ans = append(ans, vals)
    }
    return
}
```
</details>

<details>
    <summary>C</summary>
    
```
#define N 2000

int** zigzagLevelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) {
    *returnSize = 0;
    if (root == NULL) {
        return NULL;
    }
    int** ans = malloc(sizeof(int*) * N);
    *returnColumnSizes = malloc(sizeof(int) * N);
    struct TreeNode* nodeQueue[N];
    int left = 0, right = 0;
    nodeQueue[right++] = root;
    bool isOrderLeft = true;

    while (left < right) {
        int levelList[N * 2];
        int front = N, rear = N;
        int size = right - left;
        for (int i = 0; i < size; ++i) {
            struct TreeNode* node = nodeQueue[left++];
            if (isOrderLeft) {
                levelList[rear++] = node->val;
            } else {
                levelList[--front] = node->val;
            }
            if (node->left) {
                nodeQueue[right++] = node->left;
            }
            if (node->right) {
                nodeQueue[right++] = node->right;
            }
        }
        int* tmp = malloc(sizeof(int) * (rear - front));
        for (int i = 0; i < rear - front; i++) {
            tmp[i] = levelList[i + front];
        }
        ans[*returnSize] = tmp;
        (*returnColumnSizes)[*returnSize] = rear - front;
        (*returnSize)++;
        isOrderLeft = !isOrderLeft;
    }
    return ans;
} 
```
</details>

## å¤æ‚åº¦åˆ†æ

æ—¶é—´å¤æ‚åº¦ï¼š
O(N)ï¼Œå…¶ä¸­ N ä¸ºäºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°ã€‚æ¯ä¸ªèŠ‚ç‚¹ä¼šä¸”ä»…ä¼šè¢«éå†ä¸€æ¬¡ã€‚
ç©ºé—´å¤æ‚åº¦ï¼š
O(N)ã€‚æˆ‘ä»¬éœ€è¦ç»´æŠ¤å­˜å‚¨èŠ‚ç‚¹çš„é˜Ÿåˆ—å’Œå­˜å‚¨èŠ‚ç‚¹å€¼çš„åŒç«¯é˜Ÿåˆ—ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(N)ã€‚


[^1]:https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/solution/er-cha-shu-de-ju-chi-xing-ceng-xu-bian-l-qsun/