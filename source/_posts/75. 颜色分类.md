
title: 75. 颜色分类

date: 2022-11-11 11:12:12

categories: 2022年11月

tags: [Leetcode, Array, Two Pointers, Sorting]

---



给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。


<!-- more -->

[TOC]


我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

必须在不使用库的sort函数的情况下解决这个问题。

 

示例 1：

    输入：nums = [2,0,2,1,1,0]
    输出：[0,0,1,1,2,2]
示例 2：

    输入：nums = [2,0,1]
    输出：[0,1,2]
 

提示：

    n == nums.length
    1 <= n <= 300
    nums[i] 为 0、1 或 2
 

进阶：
    
    你可以不使用代码库中的排序函数来解决这道题吗？
    你能想出一个仅使用常数空间的一趟扫描算法吗？
    


# 前言[^1]

本题是经典的「荷兰国旗问题」，由计算机科学家 Edsger W. Dijkstra 首先提出。

根据题目中的提示，我们可以统计出数组中 0,1,2  的个数，再根据它们的数量，重写整个数组。这种方法较为简单，也很容易想到，而本题解中会介绍两种基于指针进行交换的方法。

# 方法一：单指针

## 思路与算法

我们可以考虑对数组进行两次遍历。在第一次遍历中，我们将数组中所有的 000 交换到数组的头部。在第二次遍历中，我们将数组中所有的 111 交换到头部的 000 之后。此时，所有的 222 都出现在数组的尾部，这样我们就完成了排序。

具体地，我们使用一个指针 ptr 表示「头部」的范围，ptr 中存储了一个整数，表示数组 nums 从位置 000 到位置 ptr−1 都属于「头部」。ptr 的初始值为 000，表示还没有数处于「头部」。

在第一次遍历中，我们从左向右遍历整个数组，如果找到了 000，那么就需要将 000 与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。在遍历结束之后，所有的 000 都被交换到「头部」的范围，并且「头部」只包含 000。

在第二次遍历中，我们从「头部」开始，从左向右遍历整个数组，如果找到了 111，那么就需要将 111 与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。在遍历结束之后，所有的 111 都被交换到「头部」的范围，并且都在 000 之后，此时 222 只出现在「头部」之外的位置，因此排序完成。


<details>
    <summary></summary>

```

```
</details>



[^1]:https://leetcode.cn/problems/sort-colors/solutions/437968/yan-se-fen-lei-by-leetcode-solution/