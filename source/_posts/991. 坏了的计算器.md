
title: 991. 坏了的计算器

date: 2021-11-03 11:12:12

categories: 2021年11月

tags: [Leetcode, Math, Greedy]

---

返回显示数字 Y 所需的最小操作数。


<!-- more -->

[TOC]

在显示着数字的坏计算器上，我们可以执行以下两种操作：

双倍（Double）：将显示屏上的数字乘 2；
递减（Decrement）：将显示屏上的数字减 1 。
最初，计算器显示数字 X。

返回显示数字 Y 所需的最小操作数。



示例 1：
    
    输入：X = 2, Y = 3
    输出：2
    解释：先进行双倍运算，然后再进行递减运算 {2 -> 4 -> 3}.
示例 2：
    
    输入：X = 5, Y = 8
    输出：2
    解释：先递减，再双倍 {5 -> 4 -> 8}.
示例 3：
    
    输入：X = 3, Y = 10
    输出：3
    解释：先双倍，然后递减，再双倍 {3 -> 6 -> 5 -> 10}.
示例 4：
    
    输入：X = 1024, Y = 1
    输出：1023
    解释：执行递减运算 1023 次


提示：
    
    1 <= X <= 10^9
    1 <= Y <= 10^9

# 方法一：逆向思维

**思路**

除了对 `X` 执行乘 2 或 减 1 操作之外，我们也可以对 `Y` 执行`除 2`（当 `Y` 是偶数时）或者`加 1 `操作。

为什么这道题采用逆向思维更优？

正向思维：在X<Y时要实现操作数最小，要将X逼近Y的1/2值或1/4值或1/8值或...再进行*2操作，难点在于要判断要逼近的是1/2值还是1/4值还是其他值，逻辑复杂 

逆向思维：在Y>X时Y只管/2，到了Y<X时在+1逼近 说白了就是，正向思维采用的是先小跨度的-1操作，再大跨度的*2操作；逆向思维采用的是先大跨度的/2操作，再小跨度的-1操作

然而事实上往往是先大后小的解决问题思维在实现起来会比较简单

下面的解释我没有太理解，但重点是要分奇数和偶数。奇数不能直接除2，可以先加1

这样做的动机是我们可以总是贪心地执行除 2 操作：

* 当 `Y` 是偶数，如果先执行 2 次加法操作，再执行 1 次除法操作，我们可以通过先执行 1 次除法操作，再执行 1 次加法操作以使用更少的操作次数得到相同的结果 [`(Y+2) / 2` vs `Y/2 + 1`]。

* 当 `Y` 是奇数，如果先执行 3 次加法操作，再执行 1 次除法操作，我们可以将其替代为顺次执行加法、除法、加法操作以使用更少的操作次数得到相同的结果 [`(Y+3) / 2` vs `(Y+1) / 2 + 1`]。


**算法**

当 `Y` 大于 `X` 时，如果它是奇数，我们执行加法操作，否则执行除法操作。之后，我们需要执行 `X - Y` 次加法操作以得到 `X`。

```java [uRsowHNz-Java]
class Solution {
    public int brokenCalc(int startValue, int target) {
        int res = 0;
        while (startValue < target) {
            res++;
            target = ((target & 1) == 1) ? target + 1 : target / 2;
        }
        return res + startValue - target;
    }
}
```
```python [uRsowHNz-Python]
class Solution(object):
    def brokenCalc(self, X, Y):
        ans = 0
        while Y > X:
            ans += 1
            if Y%2: Y += 1
            else: Y /= 2

        return ans + X-Y
```


**复杂度分析**

* 时间复杂度：  O(logY)

* 空间复杂度：  *O(1)*。



