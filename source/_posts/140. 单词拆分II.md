---
title: 140. å•è¯æ‹†åˆ†II

date: 2020-05-29 11:23:12

categories: 2020å¹´5æœˆ

tags: [LeetCode,Dynamic Programming,Backtracking]

---

ç»™å®šä¸€ä¸ªéç©ºå­—ç¬¦ä¸² s å’Œä¸€ä¸ªåŒ…å«éç©ºå•è¯åˆ—è¡¨çš„å­—å…¸ wordDictï¼Œåœ¨å­—ç¬¦ä¸²ä¸­å¢åŠ ç©ºæ ¼æ¥æ„å»ºä¸€ä¸ªå¥å­ï¼Œä½¿å¾—å¥å­ä¸­æ‰€æœ‰çš„å•è¯éƒ½åœ¨è¯å…¸ä¸­ã€‚è¿”å›æ‰€æœ‰è¿™äº›å¯èƒ½çš„å¥å­ã€‚

<!-- more -->


# ğŸ“–é¢˜ç›®æè¿°ï¼š

ç»™å®šä¸€ä¸ªéç©ºå­—ç¬¦ä¸² s å’Œä¸€ä¸ªåŒ…å«éç©ºå•è¯åˆ—è¡¨çš„å­—å…¸ wordDictï¼Œåœ¨å­—ç¬¦ä¸²ä¸­å¢åŠ ç©ºæ ¼æ¥æ„å»ºä¸€ä¸ªå¥å­ï¼Œä½¿å¾—å¥å­ä¸­æ‰€æœ‰çš„å•è¯éƒ½åœ¨è¯å…¸ä¸­ã€‚è¿”å›æ‰€æœ‰è¿™äº›å¯èƒ½çš„å¥å­ã€‚

è¯´æ˜ï¼š

åˆ†éš”æ—¶å¯ä»¥é‡å¤ä½¿ç”¨å­—å…¸ä¸­çš„å•è¯ã€‚
ä½ å¯ä»¥å‡è®¾å­—å…¸ä¸­æ²¡æœ‰é‡å¤çš„å•è¯ã€‚

ç¤ºä¾‹ 1ï¼š

    è¾“å…¥:
    s = "catsanddog"
    wordDict = ["cat", "cats", "and", "sand", "dog"]
    è¾“å‡º:
    [
    Â  "cats and dog",
    Â  "cat sand dog"
    ]
ç¤ºä¾‹ 2ï¼š
    
    è¾“å…¥:
    s = "pineapplepenapple"
    wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
    è¾“å‡º:
    [
    Â  "pine apple pen apple",
    Â  "pineapple pen apple",
    Â  "pine applepen apple"
    ]
    è§£é‡Š: æ³¨æ„ä½ å¯ä»¥é‡å¤ä½¿ç”¨å­—å…¸ä¸­çš„å•è¯ã€‚
ç¤ºä¾‹Â 3ï¼š

    è¾“å…¥:
    s = "catsandog"
    wordDict = ["cats", "dog", "sand", "and", "cat"]
    è¾“å‡º:
    []
# ğŸ“–æ–¹æ³• 1ï¼šæš´åŠ›æ±‚è§£

**ç®—æ³•**

è§£å†³æ­¤é¢˜æœ€ç®€å•çš„æ–¹æ³•æ˜¯ä½¿ç”¨å›æº¯ã€‚ä¸ºäº†æ‰¾åˆ°è§£ï¼Œæˆ‘ä»¬æ£€æŸ¥å­—ç¬¦ä¸²ï¼ˆ*s*ï¼‰çš„æ‰€æœ‰å¯èƒ½å‰ç¼€æ˜¯å¦åœ¨å­—å…¸ä¸­ï¼Œå¦‚æœåœ¨ï¼ˆæ¯”æ–¹è¯´ *s1* ï¼‰ï¼Œé‚£ä¹ˆè°ƒç”¨å›æº¯å‡½æ•°å¹¶æ£€æŸ¥å‰©ä½™éƒ¨åˆ†çš„å­—ç¬¦ä¸²ã€‚
å¦‚æœå‰©ä½™éƒ¨åˆ†å¯ä»¥å½¢æˆæœ‰æ•ˆæ‹†åˆ†ï¼Œè¿™ä¸ªå‡½æ•°è¿”å›å‰ç¼€ *s1* ï¼Œå¹¶å°†å›æº¯è°ƒç”¨çš„å‰©ä½™ç»“æœï¼ˆå³ *s-s1*ï¼‰è·Ÿåœ¨ *s1* çš„åé¢ã€‚å¦åˆ™ï¼Œè¿”å›ç©ºåˆ—è¡¨ã€‚

```Java []
public class Solution {
    public List<String> wordBreak(String s, Set<String> wordDict) {
        return word_Break(s, wordDict, 0);
    }
    public List<String> word_Break(String s, Set<String> wordDict, int start) {
        LinkedList<String> res = new LinkedList<>();
        if (start == s.length()) {
            res.add("");
        }
        for (int end = start + 1; end <= s.length(); end++) {
            if (wordDict.contains(s.substring(start, end))) {
                List<String> list = word_Break(s, wordDict, end);
                for (String l : list) {
                    res.add(s.substring(start, end) + (l.equals("") ? "" : " ") + l);
                }
            }
        }
        return res;
    }
}
```

**å¤æ‚åº¦åˆ†æ**

* æ—¶é—´å¤æ‚åº¦ï¼š*O(n^n)*ï¼Œè€ƒè™‘æœ€åæƒ…å†µ *s* = "aaaaaaa "ï¼Œ*s* çš„æ¯ä¸€ä¸ªå‰ç¼€éƒ½åœ¨å­—å…¸ä¸­ï¼Œå›æº¯æ ‘çš„å¤§å°ä¼šè¾¾åˆ°  *n^n* ã€‚

* ç©ºé—´å¤æ‚åº¦ï¼š*O(n^3)*ï¼Œæœ€åæƒ…å†µä¸‹ï¼Œå›æº¯çš„æ·±åº¦å¯ä»¥è¾¾åˆ° *n* å±‚ï¼Œæ¯å±‚å¯èƒ½åŒ…å« *n* ä¸ªå­—ç¬¦ä¸²ï¼Œä¸”æ¯ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦éƒ½ä¸º *n* ã€‚


#  ğŸ“–æ–¹æ³• 2ï¼šè®°å¿†åŒ–å›æº¯

**ç®—æ³•**

åœ¨ä¹‹å‰çš„æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºè®¸å¤šå­é—®é¢˜çš„æ±‚è§£éƒ½æ˜¯å†—ä½™çš„ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬å¯¹äºç›¸åŒçš„å­ä¸²è°ƒç”¨äº†å‡½æ•°å¤šæ¬¡ã€‚

ä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬ä½¿ç”¨è®°å¿†åŒ–çš„æ–¹æ³•ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ª *key:value* è¿™æ ·çš„å“ˆå¸Œè¡¨æ¥è¿›è¡Œä¼˜åŒ–ã€‚åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œ *key* æ˜¯å½“å‰è€ƒè™‘å­—ç¬¦ä¸²çš„å¼€å§‹ä¸‹æ ‡ï¼Œ *value* åŒ…å«äº†æ‰€æœ‰ä»å¤´å¼€å§‹çš„æ‰€æœ‰å¯è¡Œå¥å­ã€‚ä¸‹æ¬¡æˆ‘ä»¬é‡åˆ°ç›¸åŒä½ç½®å¼€å§‹çš„è°ƒç”¨æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ä»å“ˆå¸Œè¡¨é‡Œè¿”å›ç»“æœï¼Œè€Œä¸éœ€è¦é‡æ–°è®¡ç®—ç»“æœã€‚

é€šè¿‡è®°å¿†åŒ–çš„æ–¹æ³•ï¼Œè®¸å¤šå†—ä½™çš„å­é—®é¢˜éƒ½å¯ä»¥è¢«çœå»ï¼Œå›æº¯æ ‘å¾—åˆ°äº†å‰ªæï¼Œæ‰€ä»¥æå¤§ç¨‹åº¦é™ä½äº†æ—¶é—´å¤æ‚åº¦ã€‚

```Java []
public class Solution {

    public List<String> wordBreak(String s, Set<String> wordDict) {
        return word_Break(s, wordDict, 0);
    }
    HashMap<Integer, List<String>> map = new HashMap<>();

    public List<String> word_Break(String s, Set<String> wordDict, int start) {
        if (map.containsKey(start)) {
            return map.get(start);
        }
        LinkedList<String> res = new LinkedList<>();
        if (start == s.length()) {
            res.add("");
        }
        for (int end = start + 1; end <= s.length(); end++) {
            if (wordDict.contains(s.substring(start, end))) {
                List<String> list = word_Break(s, wordDict, end);
                for (String l : list) {
                    res.add(s.substring(start, end) + (l.equals("") ? "" : " ") + l);
                }
            }
        }
        map.put(start, res);
        return res;
    }
}
```

**å¤æ‚åº¦åˆ†æ**

* æ—¶é—´å¤æ‚åº¦ï¼š*O(n^3)* ã€‚å›æº¯æ ‘çš„å¤§å°æœ€å¤š *n^2* ã€‚åˆ›å»ºåˆ—è¡¨éœ€è¦ *n* çš„æ—¶é—´ã€‚

#  ğŸ“–æ–¹æ³• 3ï¼šä½¿ç”¨åŠ¨æ€è§„åˆ’

**ç®—æ³•**

æœ¬é¢˜æ˜¯[ã€ŒåŠ›æ‰£ã€ç¬¬ 139 é¢˜ï¼šå•è¯æ‹†åˆ†](https://leetcode-cn.com/problems/word-break/)çš„ååºé—®é¢˜ï¼Œæœ¬é¢˜è§£åŸºäºè¯¥é—®é¢˜çš„é¢˜è§£[ã€ŠåŠ¨æ€è§„åˆ’ï¼ˆPython ä»£ç ã€Java ä»£ç ï¼‰ã€‹](https://leetcode-cn.com/problems/word-break/solution/dong-tai-gui-hua-python-dai-ma-by-liweiwei1419-2/)ç¼–å†™è€Œæˆï¼Œéœ€è¦å…ˆé˜…è¯»è¯¥é¢˜è§£ï¼Œæ‰èƒ½ç†è§£æœ¬é¢˜è§£çš„å†…å®¹ã€‚


æˆ‘ä»¬å°±æ¥ç€ä½¿ç”¨ä¸Šä¸€é¢˜çš„åˆ°çš„åŠ¨æ€è§„åˆ’çš„çŠ¶æ€æ•°ç»„æ¥è§£ç­”è¿™ä¸ªé—®é¢˜ã€‚

  [140-1.png](https://pic.leetcode-cn.com/b9af083076b82e1aba5c68b586dd7f6ef10104b7e6d9f4c94d94eb7af16bc382-140-1.png)  [140-2.png](https://pic.leetcode-cn.com/9ac605be599eb7281d4ba34367fe9d2c7c10afc3a29ef21b9a80c888a13e4810-140-2.png)  [140-3.png](https://pic.leetcode-cn.com/7ea186fae0e865fe0b151ac245c117d24c20b949f86bbc9f1dcb4a59e0c12c5f-140-3.png)  [140-4.png](https://pic.leetcode-cn.com/82422fb7edf8c3316920534f76b06212758a955dfe9d43484d3273a6ef84acff-140-4.png) 


**å‚è€ƒä»£ç  1**ï¼šçŠ¶æ€çš„å®šä¹‰ä¸ºï¼šä»¥ `s[i]` ç»“å°¾çš„å­å­—ç¬¦ä¸²æ˜¯å¦å¯ä»¥è¢«ç©ºæ ¼æ‹†åˆ†ä¸ºä¸€ä¸ªæˆ–å¤šä¸ªåœ¨å­—å…¸ä¸­å‡ºç°çš„å•è¯ã€‚

å…¶ä¸­çš„dfså†™çš„ååˆ†ç²¾å¦™ï¼Œéå¸¸ç»å…¸ï¼Œæˆ‘åˆçœ‹ä»£ç å¾ˆéš¾ç†è§£ï¼Œåœ¨IDEAä¸­æ‰“äº†æ–­ç‚¹é€è¡Œè¿è¡Œæ‰ç†è§£ï¼Œå¯¹æœ€æ—©å†™å‡ºè¿™ç§è§£æ³•çš„äººçœŸæ˜¯é’¦ä½©ä¸å·²ã€‚
ä¸è¿‡æœ‰äº›ä»£ç å¯ä»¥æ›´ç®€åŒ–ä¸€äº›ï¼Œä¾‹å¦‚åˆå§‹åŒ–Set<String> å¯ä»¥ç›´æ¥èµ‹å€¼ã€‚

        Set<String> wordSet=new HashSet<>(wordDict);
æ‹¼æ¥å¥å­æ—¶ä¸ä¸€å®šéè¦ç”¨StringBuilderï¼Œç›´æ¥ç”¨ StringUtils.join()å‡½æ•°å³å¯ã€‚

        StringUtils.join(stringlist, " ");

```Python []
from typing import List
from collections import deque


class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        size = len(s)
        # é¢˜ç›®ä¸­è¯´éç©ºå­—ç¬¦ä¸²ï¼Œä»¥ä¸‹ assert ä¸€å®šé€šè¿‡
        assert size > 0

        # é¢„å¤„ç†ï¼ŒæŠŠ wordDict æ”¾è¿›ä¸€ä¸ªå“ˆå¸Œè¡¨ä¸­
        word_set = {word for word in wordDict}
        # print(word_set)

        # çŠ¶æ€ï¼šä»¥ s[i] ç»“å°¾
        # è¿™ç§çŠ¶æ€å®šä¹‰å¾ˆå¸¸è§
        dp = [False for _ in range(size)]

        dp[0] = s[0] in word_set

        # print(dp)

        # ä½¿ç”¨ r è¡¨ç¤ºå³è¾¹ç•Œï¼Œå¯ä»¥å–åˆ°
        # ä½¿ç”¨ l è¡¨ç¤ºå·¦è¾¹ç•Œï¼Œä¹Ÿå¯ä»¥å–åˆ°
        for r in range(1, size):
            # Python çš„è¯­æ³•ï¼Œåœ¨åˆ‡ç‰‡çš„æ—¶å€™ä¸åŒ…æ‹¬å³è¾¹ç•Œ
            # å¦‚æœæ•´ä¸ªå•è¯å°±ç›´æ¥åœ¨ word_set ä¸­ï¼Œç›´æ¥è¿”å›å°±å¥½äº†
            # å¦åˆ™æŠŠå•è¯åšåˆ†å‰²ï¼ŒæŒ¨ä¸ªå»åˆ¤æ–­
            if s[:r + 1] in word_set:
                dp[r] = True
                continue

            for l in range(r):
                # dp[l] å†™åœ¨å‰é¢ä¼šæ›´å¿«ä¸€ç‚¹ï¼Œå¦åˆ™è¿˜è¦å»åˆ‡ç‰‡ï¼Œç„¶åå†æ”¾å…¥ hash è¡¨åˆ¤é‡
                if dp[l] and s[l + 1: r + 1] in word_set:
                    dp[r] = True
                    # è¿™ä¸ª break å¾ˆé‡è¦ï¼Œä¸€æ—¦å¾—åˆ° dp[r] = True ï¼Œå¾ªç¯ä¸å¿…å†ç»§ç»­
                    break
        res = []
        # å¦‚æœæœ‰è§£ï¼Œæ‰æœ‰å¿…è¦å›æº¯
        if dp[-1]:
            queue = deque()

            self.__dfs(s, size - 1, wordDict, res, queue, dp)
        return res

    def __dfs(self, s, end, word_set, res, path, dp):
        # print('åˆšå¼€å§‹', s[:end + 1])
        # å¦‚æœä¸ç”¨æ‹†åˆ†ï¼Œæ•´ä¸ªå•è¯å°±åœ¨ word_set ä¸­å°±å¯ä»¥ç»“ç®—äº†
        if s[:end + 1] in word_set:
            path.appendleft(s[:end + 1])
            res.append(' '.join(path))
            path.popleft()

        for i in range(end):
            if dp[i]:
                suffix = s[i + 1:end + 1]
                if suffix in word_set:
                    path.appendleft(suffix)
                    self.__dfs(s, i, word_set, res, path, dp)
                    path.popleft()


if __name__ == '__main__':
    # s = "leetcode"
    # wordDict = ["leet", "code"]
    s = "pineapplepenapple"
    wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]

    # s = "a"
    # wordDict = ["a"]
    solution = Solution()
    result = solution.wordBreak(s, wordDict)
    print(result)

    # ["pine apple pen apple","pineapple pen apple","pine applepen apple"]
```
```Java []
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

public class Solution {

    public List<String> wordBreak(String s, List<String> wordDict) {
        int len = s.length();
        // çŠ¶æ€å®šä¹‰ï¼šä»¥ s[i] ç»“å°¾çš„å­å­—ç¬¦ä¸²æ˜¯å¦ç¬¦åˆé¢˜æ„
        boolean[] dp = new boolean[len];

        // é¢„å¤„ç†
        Set<String> wordSet = new HashSet<>();
        for (String word : wordDict) {
            wordSet.add(word);
        }

        // åŠ¨æ€è§„åˆ’é—®é¢˜ä¸€èˆ¬éƒ½æœ‰èµ·ç‚¹ï¼Œèµ·ç‚¹ä¹Ÿç›¸å¯¹å¥½åˆ¤æ–­ä¸€äº›
        // dp[0] = wordSet.contains(s.charAt(0));
        for (int r = 0; r < len; r++) {
            if (wordSet.contains(s.substring(0, r + 1))) {
                dp[r] = true;
                continue;
            }
            for (int l = 0; l < r; l++) {
                // dp[l] å†™åœ¨å‰é¢ä¼šæ›´å¿«ä¸€ç‚¹ï¼Œå¦åˆ™è¿˜è¦å»åˆ‡ç‰‡ï¼Œç„¶åå†æ”¾å…¥ hash è¡¨åˆ¤é‡
                if (dp[l] && wordSet.contains(s.substring(l + 1, r + 1)) ) {
                    dp[r] = true;
                    // è¿™ä¸ª break å¾ˆé‡è¦ï¼Œä¸€æ—¦å¾—åˆ° dp[r] = True ï¼Œå¾ªç¯ä¸å¿…å†ç»§ç»­
                    break;
                }
            }
        }

        List<String> res = new ArrayList<>();
        if (dp[len - 1]) {
            LinkedList<String> queue = new LinkedList<>();
            dfs(s, len - 1, wordSet, res, queue, dp);
            return res;
        }

        return res;
    }

    private void dfs(String s, int end, Set<String> wordSet, List<String> res, LinkedList<String> queue, boolean[] dp) {
        if (wordSet.contains(s.substring(0, end + 1))) {
            queue.addFirst(s.substring(0, end + 1));

            StringBuilder stringBuilder = new StringBuilder();
            for (String word : queue) {
                stringBuilder.append(word);
                stringBuilder.append(" ");
            }
            stringBuilder.deleteCharAt(stringBuilder.length() - 1);
            res.add(stringBuilder.toString());

            queue.removeFirst();
        }

        for (int i = 0; i < end; i++) {

            if (dp[i]) {
                String suffix = s.substring(i + 1, end + 1);

                if (wordSet.contains(suffix)) {
                    queue.addFirst(suffix);
                    dfs(s, i, wordSet, res, queue, dp);
                    queue.removeFirst();
                }
            }

        }
    }


    public static void main(String[] args) {
        String s = "pineapplepenapple";
        List<String> wordDict = new ArrayList<>();
        wordDict.add("apple");
        wordDict.add("pen");
        wordDict.add("applepen");
        wordDict.add("pine");
        wordDict.add("pineapple");
        Solution solution = new Solution();
        List<String> res = solution.wordBreak(s, wordDict);
        System.out.println(res);
    }
}
```


**å‚è€ƒä»£ç  2**ï¼šçŠ¶æ€ï¼šdp[i] è¡¨ç¤ºå­ä¸² s[0:i] ï¼ˆå³é•¿åº¦ä¸º i çš„å­ä¸²ï¼Œå…¶å®å°±æ˜¯å‰ç¼€ï¼‰å¯ä»¥è¢«ç©ºæ ¼æ‹†åˆ†ï¼Œå¹¶ä¸”æ‹†åˆ†ä»¥åçš„å•è¯æ˜¯å¦è½åœ¨ wordDict ä¸­ã€‚


```Python []
from typing import List
from collections import deque


class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        size = len(s)

        # é¢˜ç›®ä¸­è¯´éç©ºå­—ç¬¦ä¸²ï¼Œä»¥ä¸‹ assert ä¸€å®šé€šè¿‡
        assert size > 0

        # é¢„å¤„ç†ï¼ŒæŠŠ wordDict æ”¾è¿›ä¸€ä¸ªå“ˆå¸Œè¡¨ä¸­
        word_set = {word for word in wordDict}

        # dp[i] è¡¨ç¤ºé•¿åº¦ä¸º i çš„ sï¼Œæ»¡è¶³é¢˜æ„
        # 0 è¡¨ç¤º False ï¼Œ1 è¡¨ç¤º True
        dp = [0 for _ in range(size + 1)]
        dp[0] = 1

        for i in range(1, size + 1):
            # i è¡¨ç¤º s å­ä¸²çš„é•¿åº¦
            for j in range(i):
                # j è¡¨ç¤ºåå­ä¸²çš„èµ·å§‹ä½ç½®ï¼Œæœ€å¤šåˆ° i-1
                # j ä¹Ÿæ­£æ­£å¥½è¡¨ç¤ºå‰å­ä¸²çš„é•¿åº¦
                # dp[j] å†™åœ¨å‰é¢ä¼šæ›´å¿«ä¸€ç‚¹ï¼Œå¦åˆ™è¿˜è¦å»åˆ‡ç‰‡ï¼Œç„¶åå†æ”¾å…¥ hash è¡¨åˆ¤é‡
                if dp[j] and s[j:i] in word_set:
                    dp[i] = 1
                    break

        res = []
        # å¦‚æœæœ‰è§£ï¼Œæ‰æœ‰å¿…è¦å›æº¯
        if dp[-1]:
            queue = deque()
            self.__dfs(s, size, word_set, res, queue, dp)
        return res

    def __dfs(self, s, length, word_set, res, path, dp):
        if length == 0:
            res.append(' '.join(path))
            return
        for i in range(length):
            if dp[i]:
                suffix = s[i:length]
                if suffix in word_set:
                    path.appendleft(suffix)
                    self.__dfs(s, i, word_set, res, path, dp)
                    path.popleft()


if __name__ == '__main__':
    s = "pineapplepenapple"
    wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
    solution = Solution()
    result = solution.wordBreak(s, wordDict)
    print(result)
```
```Java []
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

public class Solution2 {

    public List<String> wordBreak(String s, List<String> wordDict) {
        int len = s.length();
        // çŠ¶æ€å®šä¹‰ï¼šé•¿åº¦ä¸º i çš„å­å­—ç¬¦ä¸²æ˜¯å¦ç¬¦åˆé¢˜æ„
        boolean[] dp = new boolean[len + 1];

        // é¢„å¤„ç†
        Set<String> wordSet = new HashSet<>();
        for (String word : wordDict) {
            wordSet.add(word);
        }

        // è¿™ä¸ªçŠ¶æ€çš„è®¾ç½®éå¸¸å…³é”®ï¼Œè¯´æ˜å‰éƒ¨åˆ†çš„å­—ç¬¦ä¸²å·²ç»åœ¨ wordSet ä¸­
        dp[0] = true;
        for (int r = 1; r < len + 1; r++) {
            for (int l = 0; l < r; l++) {
                // dp[l] å†™åœ¨å‰é¢ä¼šæ›´å¿«ä¸€ç‚¹ï¼Œå¦åˆ™è¿˜è¦å»åˆ‡ç‰‡ï¼Œç„¶åå†æ”¾å…¥ hash è¡¨åˆ¤é‡
                if (dp[l] && wordSet.contains(s.substring(l, r))  ) {
                    dp[r] = true;
                    // è¿™ä¸ª break å¾ˆé‡è¦ï¼Œä¸€æ—¦å¾—åˆ° dp[r] = True ï¼Œå¾ªç¯ä¸å¿…å†ç»§ç»­
                    break;
                }
            }
        }
        List<String> res = new ArrayList<>();
        if (dp[len]) {
            LinkedList<String> queue = new LinkedList<>();
            dfs(s, len, wordSet, res, queue, dp);
            return res;
        }

        return res;
    }

    private void dfs(String s, int end, Set<String> wordSet, List<String> res, LinkedList<String> queue, boolean[] dp) {
        if (end == 0) {
            StringBuilder stringBuilder = new StringBuilder();
            for (String word : queue) {
                stringBuilder.append(word);
                stringBuilder.append(" ");
            }
            stringBuilder.deleteCharAt(stringBuilder.length() - 1);
            res.add(stringBuilder.toString());
            return;
        }

        for (int i = 0; i < end; i++) {
            if (dp[i]) {
                String suffix = s.substring(i, end);
                if (wordSet.contains(suffix)) {
                    queue.addFirst(suffix);
                    dfs(s, i, wordSet, res, queue, dp);
                    queue.removeFirst();
                }
            }
        }
    }

    public static void main(String[] args) {
        String s = "pineapplepenapple";
        List<String> wordDict = new ArrayList<>();
        wordDict.add("apple");
        wordDict.add("pen");
        wordDict.add("applepen");
        wordDict.add("pine");
        wordDict.add("pineapple");
        Solution2 solution2 = new Solution2();
        List<String> res = solution2.wordBreak(s, wordDict);
        System.out.println(res);
    }
}
```



# å‚è€ƒèµ„æ–™ï¼š
ã€1ã€‘https://leetcode-cn.com/problems/word-break-ii/solution/dong-tai-gui-hua-hui-su-qiu-jie-ju-ti-zhi-python-d/

ã€2ã€‘https://leetcode-cn.com/problems/word-break/solution/dong-tai-gui-hua-python-dai-ma-by-liweiwei1419-2/

