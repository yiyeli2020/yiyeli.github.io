---

title: 572. å¦ä¸€ä¸ªæ ‘çš„å­æ ‘

date: 2021-03-29 20:55:12

categories: 2021å¹´3æœˆ

tags: [LeetCode, Tree]


---

ç»™å®šä¸¤ä¸ªéç©ºäºŒå‰æ ‘ s å’Œ tï¼Œæ£€éªŒÂ s ä¸­æ˜¯å¦åŒ…å«å’Œ t å…·æœ‰ç›¸åŒç»“æ„å’ŒèŠ‚ç‚¹å€¼çš„å­æ ‘ã€‚s çš„ä¸€ä¸ªå­æ ‘åŒ…æ‹¬ s çš„ä¸€ä¸ªèŠ‚ç‚¹å’Œè¿™ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰å­å­™ã€‚s ä¹Ÿå¯ä»¥çœ‹åšå®ƒè‡ªèº«çš„ä¸€æ£µå­æ ‘ã€‚

<!-- more -->


ç¤ºä¾‹ 1:

ç»™å®šçš„æ ‘ s:
    
         3
        / \
       4   5
      / \
     1   2

ç»™å®šçš„æ ‘ tï¼š
    
       4 
      / \
     1   2
    è¿”å› trueï¼Œå› ä¸º t ä¸ s çš„ä¸€ä¸ªå­æ ‘æ‹¥æœ‰ç›¸åŒçš„ç»“æ„å’ŒèŠ‚ç‚¹å€¼ã€‚

ç¤ºä¾‹ 2:

ç»™å®šçš„æ ‘ sï¼š

         3
        / \
       4   5
      / \
     1   2
        /
       0
ç»™å®šçš„æ ‘ tï¼š
    
       4
      / \
     1   2
    è¿”å› falseã€‚


# ğŸ“– æ–‡å­—é¢˜è§£

## æ–¹æ³•ä¸€ï¼šæ·±åº¦ä¼˜å…ˆæœç´¢æš´åŠ›åŒ¹é…

**æ€è·¯å’Œç®—æ³•**

è¿™æ˜¯ä¸€ç§æœ€æœ´ç´ çš„æ–¹æ³•â€”â€”æ·±åº¦ä¼˜å…ˆæœç´¢æšä¸¾ *s* ä¸­çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåˆ¤æ–­è¿™ä¸ªç‚¹çš„å­æ ‘æ˜¯å¦å’Œ *t* ç›¸ç­‰ã€‚å¦‚ä½•åˆ¤æ–­ä¸€ä¸ªèŠ‚ç‚¹çš„å­æ ‘æ˜¯å¦å’Œ *t* ç›¸ç­‰å‘¢ï¼Œæˆ‘ä»¬åˆéœ€è¦åšä¸€æ¬¡æ·±åº¦ä¼˜å…ˆæœç´¢æ¥æ£€æŸ¥ï¼Œå³è®©ä¸¤ä¸ªæŒ‡é’ˆä¸€å¼€å§‹å…ˆæŒ‡å‘è¯¥èŠ‚ç‚¹å’Œ *t* çš„æ ¹ï¼Œç„¶åã€ŒåŒæ­¥ç§»åŠ¨ã€ä¸¤æ ¹æŒ‡é’ˆæ¥ã€ŒåŒæ­¥éå†ã€è¿™ä¸¤æ£µæ ‘ï¼Œåˆ¤æ–­å¯¹åº”ä½ç½®æ˜¯å¦ç›¸ç­‰ã€‚

<details>
    <summary>æ·±åº¦ä¼˜å…ˆæœç´¢æš´åŠ›åŒ¹é…C++</summary>

```C++ [sol1-C++]
class Solution {
public:
    bool check(TreeNode *o, TreeNode *t) {
        if (!o && !t) {
            return true;
        }
        if ((o && !t) || (!o && t) || (o->val != t->val)) {
            return false;
        }
        return check(o->left, t->left) && check(o->right, t->right);
    }

    bool dfs(TreeNode *o, TreeNode *t) {
        if (!o) {
            return false;
        }
        return check(o, t) || dfs(o->left, t) || dfs(o->right, t);
    }

    bool isSubtree(TreeNode *s, TreeNode *t) {
        return dfs(s, t);
    }
};
```
</details>
<details>
    <summary>æ·±åº¦ä¼˜å…ˆæœç´¢æš´åŠ›åŒ¹é…Java</summary>

```Java [sol1-Java]
class Solution {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        return dfs(s, t);
    }

    public boolean dfs(TreeNode s, TreeNode t) {
        if (s == null) {
            return false;
        }
        return check(s, t) || dfs(s.left, t) || dfs(s.right, t);
    }

    public boolean check(TreeNode s, TreeNode t) {
        if (s == null && t == null) {
            return true;
        }
        if (s == null || t == null || s.val != t.val) {
            return false;
        }
        return check(s.left, t.left) && check(s.right, t.right);
    }
}
```
</details>
<details>
    <summary>æ·±åº¦ä¼˜å…ˆæœç´¢æš´åŠ›åŒ¹é…Golang</summary>

```golang [sol1-Golang]
func isSubtree(s *TreeNode, t *TreeNode) bool {
    if s == nil {
        return false
    }
    return check(s, t) || isSubtree(s.Left, t) || isSubtree(s.Right, t)
}

func check(a, b *TreeNode) bool {
    if a == nil && b == nil {
        return true
    }
    if a == nil || b == nil {
        return false
    }
    if a.Val == b.Val {
        return check(a.Left, b.Left) && check(a.Right, b.Right)
    }
    return false
}
```
</details>

## æ–¹æ³•äºŒï¼šæ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ä¸Šåšä¸²åŒ¹é…

**æ€è·¯å’Œç®—æ³•**

è¿™ä¸ªæ–¹æ³•éœ€è¦æˆ‘ä»¬å…ˆäº†è§£ä¸€ä¸ªã€Œå°å¥—è·¯ã€ï¼šä¸€æ£µå­æ ‘ä¸Šçš„ç‚¹åœ¨æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ï¼ˆå³å…ˆåºéå†ï¼‰ä¸­æ˜¯è¿ç»­çš„ã€‚äº†è§£äº†è¿™ä¸ªã€Œå°å¥—è·¯ã€ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šè§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹å‘å°±æ˜¯ï¼šæŠŠ *s* å’Œ *t* å…ˆè½¬æ¢æˆæ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ï¼Œç„¶åçœ‹ *t* çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—æ˜¯å¦æ˜¯ *s* çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—çš„ã€Œå­ä¸²ã€ã€‚

**è¿™æ ·åšæ­£ç¡®å—ï¼Ÿ** å‡è®¾ *s* ç”±ä¸¤ä¸ªç‚¹ç»„æˆï¼Œ*1* æ˜¯æ ¹ï¼Œ*2* æ˜¯ *1* çš„å·¦å­©å­ï¼›*t* ä¹Ÿç”±ä¸¤ä¸ªç‚¹ç»„æˆï¼Œ*1* æ˜¯æ ¹ï¼Œ*2* æ˜¯ *1* çš„å³å­©å­ã€‚è¿™æ ·ä¸€æ¥ *s* å’Œ *t* çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ç›¸åŒï¼Œå¯æ˜¯ *t* å¹¶ä¸æ˜¯ *s* çš„æŸä¸€æ£µå­æ ‘ã€‚ç”±æ­¤å¯è§ã€Œ*s* çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—åŒ…å« *t* çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ã€æ˜¯ã€Œ*t* æ˜¯ *s* å­æ ‘ã€çš„**å¿…è¦ä¸å……åˆ†æ¡ä»¶**ï¼Œæ‰€ä»¥å•çº¯è¿™æ ·åšæ˜¯ä¸æ­£ç¡®çš„ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥å¼•å…¥ä¸¤ä¸ªç©ºå€¼ `lNull` å’Œ `rNull`ï¼Œå½“ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å­©å­æˆ–è€…å³å­©å­ä¸ºç©ºçš„æ—¶å€™ï¼Œå°±æ’å…¥è¿™ä¸¤ä¸ªç©ºå€¼ï¼Œè¿™æ ·æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—å°±å”¯ä¸€å¯¹åº”ä¸€æ£µæ ‘ã€‚å¤„ç†å®Œä¹‹åï¼Œå°±å¯ä»¥é€šè¿‡åˆ¤æ–­ã€Œ*s* çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—åŒ…å« *t* çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ã€æ¥åˆ¤æ–­ç­”æ¡ˆã€‚

[fig1](https://assets.leetcode-cn.com/solution-static/572/572_fig1.png)

åœ¨åˆ¤æ–­ã€Œ*s* çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—åŒ…å« *t* çš„æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ã€çš„æ—¶å€™ï¼Œå¯ä»¥æš´åŠ›åŒ¹é…ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ KMP æˆ–è€… Rabin-Karp ç®—æ³•ï¼Œåœ¨ä½¿ç”¨Rabin-Karpç®—æ³•çš„æ—¶å€™ï¼Œè¦æ³¨æ„ä¸²ä¸­å¯èƒ½æœ‰è´Ÿå€¼ã€‚

è¿™é‡Œç»™å‡ºç”¨KMPåˆ¤æ–­çš„ä»£ç å®ç°ã€‚


<details>
<summary>æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ä¸Šåšä¸²åŒ¹é…C++</summary>


```C++ [sol2-C++]
class Solution {
public:
    vector <int> sOrder, tOrder;
    int maxElement, lNull, rNull;

    void getMaxElement(TreeNode *o) {
        if (!o) {
            return;
        }
        maxElement = max(maxElement, o->val);
        getMaxElement(o->left);
        getMaxElement(o->right);
    }

    void getDfsOrder(TreeNode *o, vector <int> &tar) {
        if (!o) {
            return;
        }
        tar.push_back(o->val);
        if (o->left) {
            getDfsOrder(o->left, tar);
        } else {
            tar.push_back(lNull);
        }
        if (o->right) {
            getDfsOrder(o->right, tar);
        } else {
            tar.push_back(rNull);
        }
    }

    bool kmp() {
        int sLen = sOrder.size(), tLen = tOrder.size();
        vector <int> fail(tOrder.size(), -1);
        for (int i = 1, j = -1; i < tLen; ++i) {
            while (j != -1 && tOrder[i] != tOrder[j + 1]) {
                j = fail[j];
            }
            if (tOrder[i] == tOrder[j + 1]) {
                ++j;
            }
            fail[i] = j;
        }
        for (int i = 0, j = -1; i < sLen; ++i) {
            while (j != -1 && sOrder[i] != tOrder[j + 1]) {
                j = fail[j];
            }
            if (sOrder[i] == tOrder[j + 1]) {
                ++j;
            }
            if (j == tLen - 1) {
                return true;
            }
        }
        return false;
    }

    bool isSubtree(TreeNode* s, TreeNode* t) {
        maxElement = INT_MIN;
        getMaxElement(s);
        getMaxElement(t);
        lNull = maxElement + 1;
        rNull = maxElement + 2;

        getDfsOrder(s, sOrder);
        getDfsOrder(t, tOrder);

        return kmp();
    }
};
```

</details>
<details>
<summary>æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ä¸Šåšä¸²åŒ¹é…Java</summary>

```Java [sol2-Java]
class Solution {
    List<Integer> sOrder = new ArrayList<Integer>();
    List<Integer> tOrder = new ArrayList<Integer>();
    int maxElement, lNull, rNull;

    public boolean isSubtree(TreeNode s, TreeNode t) {
        maxElement = Integer.MIN_VALUE;
        getMaxElement(s);
        getMaxElement(t);
        lNull = maxElement + 1;
        rNull = maxElement + 2;

        getDfsOrder(s, sOrder);
        getDfsOrder(t, tOrder);

        return kmp();
    }

    public void getMaxElement(TreeNode t) {
        if (t == null) {
            return;
        }
        maxElement = Math.max(maxElement, t.val);
        getMaxElement(t.left);
        getMaxElement(t.right);
    }

    public void getDfsOrder(TreeNode t, List<Integer> tar) {
        if (t == null) {
            return;
        }
        tar.add(t.val);
        if (t.left != null) {
            getDfsOrder(t.left, tar);
        } else {
            tar.add(lNull);
        }
        if (t.right != null) {
            getDfsOrder(t.right, tar);
        } else {
            tar.add(rNull);
        }
    }

    public boolean kmp() {
        int sLen = sOrder.size(), tLen = tOrder.size();
        int[] fail = new int[tOrder.size()];
        Arrays.fill(fail, -1);
        for (int i = 1, j = -1; i < tLen; ++i) {
            while (j != -1 && !(tOrder.get(i).equals(tOrder.get(j + 1)))) {
                j = fail[j];
            }
            if (tOrder.get(i).equals(tOrder.get(j + 1))) {
                ++j;
            }
            fail[i] = j;
        }
        for (int i = 0, j = -1; i < sLen; ++i) {
            while (j != -1 && !(sOrder.get(i).equals(tOrder.get(j + 1)))) {
                j = fail[j];
            }
            if (sOrder.get(i).equals(tOrder.get(j + 1))) {
                ++j;
            }
            if (j == tLen - 1) {
                return true;
            }
        }
        return false;
    }
}
```

</details>
<details>
<summary>æ·±åº¦ä¼˜å…ˆæœç´¢åºåˆ—ä¸Šåšä¸²åŒ¹é…Golang</summary>

```golang [sol2-Golang]
func isSubtree(s *TreeNode, t *TreeNode) bool {
    maxEle := math.MinInt32
    getMaxElement(s, &maxEle)
    getMaxElement(t, &maxEle)
    lNull := maxEle + 1;
    rNull := maxEle + 2;

    sl, tl := getDfsOrder(s, []int{}, lNull, rNull), getDfsOrder(t, []int{}, lNull, rNull)
    return kmp(sl, tl)
}

func kmp(s, t []int) bool {
    sLen, tLen := len(s), len(t)
    fail := make([]int, sLen)
    for i := 0; i < sLen; i++ {
        fail[i] = -1
    }
    for i, j := 1, -1; i < tLen; i++ {
        for j != -1 && t[i] != t[j+1] {
            j = fail[j]
        }
        if t[i] == t[j+1] {
            j++
        }
        fail[i] = j
    }

    for i, j := 0, -1; i < sLen; i++ {
        for j != -1 && s[i] != t[j+1] {
            j = fail[j]
        }
        if s[i] == t[j+1] {
            j++
        }
        if j == tLen - 1 {
            return true
        }
    }
    return false
}

func getDfsOrder(t *TreeNode, list []int, lNull, rNull int) []int {
    if t == nil {
        return list
    }
    list = append(list, t.Val)
    if t.Left != nil {
        list = getDfsOrder(t.Left, list, lNull, rNull)
    } else {
        list = append(list, lNull)
    }

    if t.Right != nil {
        list = getDfsOrder(t.Right, list, lNull, rNull)
    } else {
        list = append(list, rNull)
    }
    return list
} 

func getMaxElement(t *TreeNode, maxEle *int) {
    if t == nil {
        return
    }
    if t.Val > *maxEle {
        *maxEle = t.Val
    }
    getMaxElement(t.Left, maxEle)
    getMaxElement(t.Right, maxEle)
}
```

</details>


## æ–¹æ³•ä¸‰ï¼šæ ‘å“ˆå¸Œ

**æ€è·¯å’Œç®—æ³•**

è€ƒè™‘æŠŠæ¯ä¸ªå­æ ‘éƒ½æ˜ å°„æˆä¸€ä¸ªå”¯ä¸€çš„æ•°ï¼Œå¦‚æœ *t* å¯¹åº”çš„æ•°å­—å’Œ *s* ä¸­ä»»æ„ä¸€ä¸ªå­æ ‘æ˜ å°„çš„æ•°å­—ç›¸ç­‰ï¼Œåˆ™ *t* æ˜¯ *s* çš„æŸä¸€æ£µå­æ ‘ã€‚å¦‚ä½•æ˜ å°„å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥å®šä¹‰è¿™æ ·çš„å“ˆå¸Œå‡½æ•°ï¼š


<details>
<summary>æ ‘å“ˆå¸ŒC++</summary>

```C++ [sol3-C++]
class Solution {
public:
    static constexpr int MAX_N = 1000 + 5;
    static constexpr int MOD = int(1E9) + 7;

    bool vis[MAX_N];
    int p[MAX_N], tot;
    void getPrime() {
        vis[0] = vis[1] = 1; tot = 0;
        for (int i = 2; i < MAX_N; ++i) {
            if (!vis[i]) p[++tot] = i;
            for (int j = 1; j <= tot && i * p[j] < MAX_N; ++j) {
                vis[i * p[j]] = 1;
                if (i % p[j] == 0) break;
            }
        }
    }

    struct Status {
        int f, s; // f ä¸ºå“ˆå¸Œå€¼ | s ä¸ºå­æ ‘å¤§å°
        Status(int f_ = 0, int s_ = 0) 
            : f(f_), s(s_) {}
    };

    unordered_map <TreeNode *, Status> hS, hT;

    void dfs(TreeNode *o, unordered_map <TreeNode *, Status> &h) {
        h[o] = Status(o->val, 1);
        if (!o->left && !o->right) return;
        if (o->left) {
            dfs(o->left, h);
            h[o].s += h[o->left].s;
            h[o].f = (h[o].f + (31LL * h[o->left].f * p[h[o->left].s]) % MOD) % MOD;
        }
        if (o->right) {
            dfs(o->right, h);
            h[o].s += h[o->right].s;
            h[o].f = (h[o].f + (179LL * h[o->right].f * p[h[o->right].s]) % MOD) % MOD;
        }
    }

    bool isSubtree(TreeNode* s, TreeNode* t) {
        getPrime();
        dfs(s, hS);
        dfs(t, hT);

        int tHash = hT[t].f;
        for (const auto &[k, v]: hS) {
            if (v.f == tHash) {
                return true;
            }
        } 

        return false;
    }
};
```

</details>
<details>
<summary>æ ‘å“ˆå¸ŒJava</summary>

```Java [sol3-Java]
class Solution {
    static final int MAX_N = 1005;
    static final int MOD = 1000000007;
    boolean[] vis = new boolean[MAX_N];
    int[] p = new int[MAX_N];
    int tot;
    Map<TreeNode, int[]> hS = new HashMap<TreeNode, int[]>();
    Map<TreeNode, int[]> hT = new HashMap<TreeNode, int[]>();

    public boolean isSubtree(TreeNode s, TreeNode t) {
        getPrime();
        dfs(s, hS);
        dfs(t, hT);

        int tHash = hT.get(t)[0];
        for (Map.Entry<TreeNode, int[]> entry : hS.entrySet()) {
            if (entry.getValue()[0] == tHash) {
                return true;
            }
        }

        return false;
    }

    public void getPrime() {
        vis[0] = vis[1] = true;
        tot = 0;
        for (int i = 2; i < MAX_N; ++i) {
            if (!vis[i]) {
                p[++tot] = i;
            }
            for (int j = 1; j <= tot && i * p[j] < MAX_N; ++j) {
                vis[i * p[j]] = true;
                if (i % p[j] == 0) {
                    break;
                }
            }
        }
    }

    public void dfs(TreeNode o, Map<TreeNode, int[]> h) {
        h.put(o, new int[]{o.val, 1});
        if (o.left == null && o.right == null) {
            return;
        }
        if (o.left != null) {
            dfs(o.left, h);
            int[] val = h.get(o);
            val[1] += h.get(o.left)[1];
            val[0] = (int) ((val[0] + (31L * h.get(o.left)[0] * p[h.get(o.left)[1]]) % MOD) % MOD);
        }
        if (o.right != null) {
            dfs(o.right, h);
            int[] val = h.get(o);
            val[1] += h.get(o.right)[1];
            val[0] = (int) ((val[0] + (179L * h.get(o.right)[0] * p[h.get(o.right)[1]]) % MOD) % MOD);
        }
    }
}
```

</details>