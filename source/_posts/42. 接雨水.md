title: 42. æ¥é›¨æ°´

date: 2020-11-18 17:30:12

categories: 2020å¹´11æœˆ

tags: [Leetcode, Stack, Array, Two pointers]

---

ç»™å®š n ä¸ªéè´Ÿæ•´æ•°è¡¨ç¤ºæ¯ä¸ªå®½åº¦ä¸º 1 çš„æŸ±å­çš„é«˜åº¦å›¾ï¼Œè®¡ç®—æŒ‰æ­¤æ’åˆ—çš„æŸ±å­ï¼Œä¸‹é›¨ä¹‹åèƒ½æ¥å¤šå°‘é›¨æ°´ã€‚


<!-- more -->

 

ç¤ºä¾‹ 1ï¼š


    
    è¾“å…¥ï¼šheight = [0,1,0,2,1,0,1,3,2,1,2,1]
    è¾“å‡ºï¼š6
    è§£é‡Šï¼šä¸Šé¢æ˜¯ç”±æ•°ç»„ [0,1,0,2,1,0,1,3,2,1,2,1] è¡¨ç¤ºçš„é«˜åº¦å›¾ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥æ¥ 6 ä¸ªå•ä½çš„é›¨æ°´ï¼ˆè“è‰²éƒ¨åˆ†è¡¨ç¤ºé›¨æ°´ï¼‰ã€‚ 
ç¤ºä¾‹ 2ï¼š
    
    è¾“å…¥ï¼šheight = [4,2,0,3,2,5]
    è¾“å‡ºï¼š9
 

æç¤ºï¼š
    
    n == height.length
    0 <= n <= 3 * 104
    0 <= height[i] <= 105


# ğŸ“– æ–‡å­—é¢˜è§£

## æ–¹æ³• 1ï¼šæš´åŠ›

**ç›´è§‚æƒ³æ³•**

ç›´æ¥æŒ‰é—®é¢˜æè¿°è¿›è¡Œã€‚å¯¹äºæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬æ‰¾å‡ºä¸‹é›¨åæ°´èƒ½è¾¾åˆ°çš„æœ€é«˜ä½ç½®ï¼Œç­‰äºä¸¤è¾¹æœ€å¤§é«˜åº¦çš„è¾ƒå°å€¼å‡å»å½“å‰é«˜åº¦çš„å€¼ã€‚

**ç®—æ³•**

* åˆå§‹åŒ– *ans=0*
* ä»å·¦å‘å³æ‰«ææ•°ç»„ï¼š
  + åˆå§‹åŒ– max_left=0 å’Œ max_right=0
  + ä»å½“å‰å…ƒç´ å‘å·¦æ‰«æå¹¶æ›´æ–°ï¼š
    * max_left=max(max_left,height[j]) 
  + ä»å½“å‰å…ƒç´ å‘å³æ‰«æå¹¶æ›´æ–°ï¼š
    * max_right=max(max_right,hegiht[j])
  + å°†min(max_left,max_right)-height[i]ç´¯åŠ åˆ°ans

<details>
    <summary>æš´åŠ›C++</summary>

```C++ [Solution 1]
int trap(vector<int>& height)
{
    int ans = 0;
    int size = height.size();
    for (int i = 1; i < size - 1; i++) {
        int max_left = 0, max_right = 0;
        for (int j = i; j >= 0; j--) { //Search the left part for max bar size
            max_left = max(max_left, height[j]);
        }
        for (int j = i; j < size; j++) { //Search the right part for max bar size
            max_right = max(max_right, height[j]);
        }
        ans += min(max_left, max_right) - height[i];
    }
    return ans;
}
```

</details>
<details>
    <summary>æš´åŠ›Java</summary>


```Java [Solution 1]
public int trap(int[] height) {
    int ans = 0;
    int size = height.length;
    for (int i = 1; i < size - 1; i++) {
        int max_left = 0, max_right = 0;
        for (int j = i; j >= 0; j--) { //Search the left part for max bar size
            max_left = Math.max(max_left, height[j]);
        }
        for (int j = i; j < size; j++) { //Search the right part for max bar size
            max_right = Math.max(max_right, height[j]);
        }
        ans += Math.min(max_left, max_right) - height[i];
    }
    return ans;
}
```

</details>

**å¤æ‚æ€§åˆ†æ**

* æ—¶é—´å¤æ‚åº¦ï¼š *O(n^2)*ã€‚æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½éœ€è¦å‘å·¦å‘å³æ‰«æã€‚

* ç©ºé—´å¤æ‚åº¦ *O(1)* çš„é¢å¤–ç©ºé—´ã€‚
<br />
<br />
---

# æ–¹æ³• 2ï¼šåŠ¨æ€ç¼–ç¨‹

**ç›´è§‚æƒ³æ³•**

åœ¨æš´åŠ›æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬ä»…ä»…ä¸ºäº†æ‰¾åˆ°æœ€å¤§å€¼æ¯æ¬¡éƒ½è¦å‘å·¦å’Œå‘å³æ‰«æä¸€æ¬¡ã€‚ä½†æ˜¯æˆ‘ä»¬å¯ä»¥æå‰å­˜å‚¨è¿™ä¸ªå€¼ã€‚å› æ­¤ï¼Œå¯ä»¥é€šè¿‡åŠ¨æ€ç¼–ç¨‹è§£å†³ã€‚

è¿™ä¸ªæ¦‚å¿µå¯ä»¥è§ä¸‹å›¾è§£é‡Šï¼š

[trapping_rain_water.png](https://pic.leetcode-cn.com/53ab7a66023039ed4dce42b709b4997d2ba0089077912d39a0b31d3572a55d0b-trapping_rain_water.png)


**ç®—æ³•**

* æ‰¾åˆ°æ•°ç»„ä¸­ä»ä¸‹æ ‡ i åˆ°æœ€å·¦ç«¯æœ€é«˜çš„æ¡å½¢å—é«˜åº¦ left_maxã€‚
* æ‰¾åˆ°æ•°ç»„ä¸­ä»ä¸‹æ ‡ i åˆ°æœ€å³ç«¯æœ€é«˜çš„æ¡å½¢å—é«˜åº¦right_maxã€‚
* æ‰«ææ•°ç»„ height  å¹¶æ›´æ–°ç­”æ¡ˆï¼š
	+ ç´¯åŠ  min(max_left[i],max_right[i])-height[i] åˆ° *ans* ä¸Š

<details>
    <summary>åŠ¨æ€ç¼–ç¨‹C++</summary>

```C++ [Solution 1]
int trap(vector<int>& height)
{
    if (height == null)
        return 0;
    int ans = 0;
    int size = height.size();
    vector<int> left_max(size), right_max(size);
    left_max[0] = height[0];
    for (int i = 1; i < size; i++) {
        left_max[i] = max(height[i], left_max[i - 1]);
    }
    right_max[size - 1] = height[size - 1];
    for (int i = size - 2; i >= 0; i--) {
        right_max[i] = max(height[i], right_max[i + 1]);
    }
    for (int i = 1; i < size - 1; i++) {
        ans += min(left_max[i], right_max[i]) - height[i];
    }
    return ans;
}
```
</details>
<details>
    <summary>åŠ¨æ€ç¼–ç¨‹Java</summary>

```Java [Solution 1]
public int trap(int[] height) {
    if (height == null || height.length == 0)
        return 0;
    int ans = 0;
    int size = height.length;
    int[] left_max = new int[size];
    int[] right_max = new int[size];
    left_max[0] = height[0];
    for (int i = 1; i < size; i++) {
        left_max[i] = Math.max(height[i], left_max[i - 1]);
    }
    right_max[size - 1] = height[size - 1];
    for (int i = size - 2; i >= 0; i--) {
        right_max[i] = Math.max(height[i], right_max[i + 1]);
    }
    for (int i = 1; i < size - 1; i++) {
        ans += Math.min(left_max[i], right_max[i]) - height[i];
    }
    return ans;
}
```

</details>

**å¤æ‚æ€§åˆ†æ**

* æ—¶é—´å¤æ‚åº¦ï¼š*O(n)*ã€‚
	+ å­˜å‚¨æœ€å¤§é«˜åº¦æ•°ç»„ï¼Œéœ€è¦ä¸¤æ¬¡éå†ï¼Œæ¯æ¬¡ *O(n)* ã€‚
	+ æœ€ç»ˆä½¿ç”¨å­˜å‚¨çš„æ•°æ®æ›´æ–°ans ï¼Œ*O(n)*ã€‚

* ç©ºé—´å¤æ‚åº¦ï¼š*O(n)* é¢å¤–ç©ºé—´ã€‚
	+ å’Œæ–¹æ³• 1 ç›¸æ¯”ä½¿ç”¨äº†é¢å¤–çš„ *O(n)* ç©ºé—´ç”¨æ¥æ”¾ç½® left_max å’Œright_max æ•°ç»„ã€‚
<br />
<br />
---

# æ–¹æ³• 3ï¼šæ ˆçš„åº”ç”¨

**ç›´è§‚æƒ³æ³•**

æˆ‘ä»¬å¯ä»¥ä¸ç”¨åƒæ–¹æ³• 2 é‚£æ ·å­˜å‚¨æœ€å¤§é«˜åº¦ï¼Œè€Œæ˜¯ç”¨æ ˆæ¥è·Ÿè¸ªå¯èƒ½å‚¨æ°´çš„æœ€é•¿çš„æ¡å½¢å—ã€‚ä½¿ç”¨æ ˆå°±å¯ä»¥åœ¨ä¸€æ¬¡éå†å†…å®Œæˆè®¡ç®—ã€‚

æˆ‘ä»¬åœ¨éå†æ•°ç»„æ—¶ç»´æŠ¤ä¸€ä¸ªæ ˆã€‚å¦‚æœå½“å‰çš„æ¡å½¢å—å°äºæˆ–ç­‰äºæ ˆé¡¶çš„æ¡å½¢å—ï¼Œæˆ‘ä»¬å°†æ¡å½¢å—çš„ç´¢å¼•å…¥æ ˆï¼Œæ„æ€æ˜¯å½“å‰çš„æ¡å½¢å—è¢«æ ˆä¸­çš„å‰ä¸€ä¸ªæ¡å½¢å—ç•Œå®šã€‚å¦‚æœæˆ‘ä»¬å‘ç°ä¸€ä¸ªæ¡å½¢å—é•¿äºæ ˆé¡¶ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šæ ˆé¡¶çš„æ¡å½¢å—è¢«å½“å‰æ¡å½¢å—å’Œæ ˆçš„å‰ä¸€ä¸ªæ¡å½¢å—ç•Œå®šï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å¼¹å‡ºæ ˆé¡¶å…ƒç´ å¹¶ä¸”ç´¯åŠ ç­”æ¡ˆåˆ° ans  ã€‚

**ç®—æ³•**

* ä½¿ç”¨æ ˆæ¥å­˜å‚¨æ¡å½¢å—çš„ç´¢å¼•ä¸‹æ ‡ã€‚
* éå†æ•°ç»„ï¼š
	+ å½“æ ˆéç©ºä¸” height[current]>height[st.top()]
		* æ„å‘³ç€æ ˆä¸­å…ƒç´ å¯ä»¥è¢«å¼¹å‡ºã€‚å¼¹å‡ºæ ˆé¡¶å…ƒç´  top ã€‚
		* è®¡ç®—å½“å‰å…ƒç´ å’Œæ ˆé¡¶å…ƒç´ çš„è·ç¦»ï¼Œå‡†å¤‡è¿›è¡Œå¡«å……æ“ä½œ distance = current-st.top()-1
		* æ‰¾å‡ºç•Œå®šé«˜åº¦
		bounded_height=min(height[current],height[st.top()])-height[top]
		* å¾€ç­”æ¡ˆä¸­ç´¯åŠ ç§¯æ°´é‡ !ans+=distance*bounded_height
	+ å°†å½“å‰ç´¢å¼•ä¸‹æ ‡å…¥æ ˆ
	+ å°† current  ç§»åŠ¨åˆ°ä¸‹ä¸ªä½ç½®

<details>
    <summary>æ ˆçš„åº”ç”¨C++</summary>

```C++ [Solution 1]
int trap(vector<int>& height)
{
    int ans = 0, current = 0;
    stack<int> st;
    while (current < height.size()) {
        while (!st.empty() && height[current] > height[st.top()]) {
            int top = st.top();
            st.pop();
            if (st.empty())
                break;
            int distance = current - st.top() - 1;
            int bounded_height = min(height[current], height[st.top()]) - height[top];
            ans += distance * bounded_height;
        }
        st.push(current++);
    }
    return ans;
}
```
</details>
<details>
    <summary>æ ˆçš„åº”ç”¨Java</summary>

```Java [Solution 1]
public int trap(int[] height) {
    int ans = 0, current = 0;
    Deque<Integer> stack = new LinkedList<Integer>();
    while (current < height.length) {
        while (!stack.isEmpty() && height[current] > height[stack.peek()]) {
            int top = stack.pop();
            if (stack.isEmpty())
                break;
            int distance = current - stack.peek() - 1;
            int bounded_height = Math.min(height[current], height[stack.peek()]) - height[top];
            ans += distance * bounded_height;
        }
        stack.push(current++);
    }
    return ans;
}
```


</details>

**å¤æ‚æ€§åˆ†æ**

* æ—¶é—´å¤æ‚åº¦ï¼š*O(n)*ã€‚
	+ å•æ¬¡éå† *O(n)* ï¼Œæ¯ä¸ªæ¡å½¢å—æœ€å¤šè®¿é—®ä¸¤æ¬¡ï¼ˆç”±äºæ ˆçš„å¼¹å…¥å’Œå¼¹å‡ºï¼‰ï¼Œå¹¶ä¸”å¼¹å…¥å’Œå¼¹å‡ºæ ˆéƒ½æ˜¯ *O(1)* çš„ã€‚
* ç©ºé—´å¤æ‚åº¦ï¼š*O(n)*ã€‚ æ ˆæœ€å¤šåœ¨é˜¶æ¢¯å‹æˆ–å¹³å¦å‹æ¡å½¢å—ç»“æ„ä¸­å ç”¨ *O(n)* çš„ç©ºé—´ã€‚
<br />
<br />
---

# æ–¹æ³• 4ï¼š

**ç›´è§‚æƒ³æ³•**

è§[^1]

<details>
    <summary>ä½¿ç”¨åŒæŒ‡é’ˆC++</summary>


```C++ [Solution 1]
int trap(vector<int>& height)
{
    int left = 0, right = height.size() - 1;
    int ans = 0;
    int left_max = 0, right_max = 0;
    while (left < right) {
        if (height[left] < height[right]) {
            height[left] >= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);
            ++left;
        }
        else {
            height[right] >= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);
            --right;
        }
    }
    return ans;
}
```
</details>
<details>
    <summary>ä½¿ç”¨åŒæŒ‡é’ˆJava</summary>

```Java [Solution 1]
public int trap(int[] height) {
    int left = 0, right = height.length - 1;
    int ans = 0;
    int left_max = 0, right_max = 0;
    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] >= left_max) {
                left_max = height[left];
            } else {
                ans += (left_max - height[left]);
            }
            ++left;
        } else {
            if (height[right] >= right_max) {
                right_max = height[right];
            } else {
                ans += (right_max - height[right]);
            }
            --right;
        }
    }
    return ans;
}
```


</details>

**å¤æ‚æ€§åˆ†æ**

* æ—¶é—´å¤æ‚åº¦ï¼š*O(n)*ã€‚å•æ¬¡éå†çš„æ—¶é—´*O(n)*ã€‚
* ç©ºé—´å¤æ‚åº¦ï¼š*O(1)* çš„é¢å¤–ç©ºé—´ã€‚left, right, left_max  å’Œ right_maxåªéœ€è¦å¸¸æ•°çš„ç©ºé—´ã€‚


[^1]:https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/