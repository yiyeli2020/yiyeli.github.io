---

title: 29. ä¸¤æ•°ç›¸é™¤

date: 2021-10-18 19:12:12

categories: 2021å¹´10æœˆ

tags: [LeetCode, Math, Bit Manipulation]


---

ç»™å®šä¸¤ä¸ªæ•´æ•° a å’Œ b ï¼Œæ±‚å®ƒä»¬çš„é™¤æ³•çš„å•† a/b ï¼Œè¦æ±‚ä¸å¾—ä½¿ç”¨ä¹˜å· '*'ã€é™¤å· '/' ä»¥åŠæ±‚ä½™ç¬¦å· '%'ã€‚

<!-- more -->

[TOC]

æ³¨æ„ï¼š

æ•´æ•°é™¤æ³•çš„ç»“æœåº”å½“æˆªå»ï¼ˆtruncateï¼‰å…¶å°æ•°éƒ¨åˆ†ï¼Œä¾‹å¦‚ï¼štruncate(8.345) = 8Â ä»¥åŠÂ truncate(-2.7335) = -2
å‡è®¾æˆ‘ä»¬çš„ç¯å¢ƒåªèƒ½å­˜å‚¨ 32 ä½æœ‰ç¬¦å·æ•´æ•°ï¼Œå…¶æ•°å€¼èŒƒå›´æ˜¯ [âˆ’231,Â 231âˆ’1]ã€‚æœ¬é¢˜ä¸­ï¼Œå¦‚æœé™¤æ³•ç»“æœæº¢å‡ºï¼Œåˆ™è¿”å› 231Â âˆ’ 1


ç¤ºä¾‹ 1ï¼š
    
    è¾“å…¥ï¼ša = 15, b = 2
    è¾“å‡ºï¼š7
    è§£é‡Šï¼š15/2 = truncate(7.5) = 7
ç¤ºä¾‹ 2ï¼š

    è¾“å…¥ï¼ša = 7, b = -3
    
    è¾“å‡ºï¼š-2
    è§£é‡Šï¼š7/-3 = truncate(-2.33333..) = -2
ç¤ºä¾‹ 3ï¼š

    è¾“å…¥ï¼ša = 0, b = 1
    è¾“å‡ºï¼š0
ç¤ºä¾‹ 4ï¼š

    è¾“å…¥ï¼ša = 1, b = 1
    è¾“å‡ºï¼š1


æç¤º:
    
    -2^31Â <= a, b <= 2^31Â - 1
    b != 0

# ğŸ“– æ–‡å­—é¢˜è§£
## å‰è¨€

ç”±äºé¢˜ç›®è§„å®šäº†ã€Œåªèƒ½å­˜å‚¨ *32* ä½æ•´æ•°ã€ï¼Œæœ¬é¢˜è§£çš„æ­£æ–‡éƒ¨åˆ†å’Œä»£ç ä¸­éƒ½ä¸ä¼šä½¿ç”¨ä»»ä½• *64* ä½æ•´æ•°ã€‚**è¯šç„¶ï¼Œä½¿ç”¨ *64* ä½æ•´æ•°å¯ä»¥æå¤§åœ°æ–¹ä¾¿æˆ‘ä»¬çš„ç¼–ç ï¼Œä½†è¿™æ˜¯è¿åé¢˜ç›®è§„åˆ™çš„ã€‚**

å¦‚æœé™¤æ³•ç»“æœæº¢å‡ºï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦è¿”å› *2^{31} - 1* ä½œä¸ºç­”æ¡ˆã€‚å› æ­¤åœ¨ç¼–ç ä¹‹å‰ï¼Œæˆ‘ä»¬å¯ä»¥é¦–å…ˆå¯¹äºæº¢å‡ºæˆ–è€…å®¹æ˜“å‡ºé”™çš„è¾¹ç•Œæƒ…å†µè¿›è¡Œè®¨è®ºï¼š

- å½“è¢«é™¤æ•°ä¸º *32* ä½æœ‰ç¬¦å·æ•´æ•°çš„æœ€å°å€¼ *-2^{31}* æ—¶ï¼š

    - å¦‚æœé™¤æ•°ä¸º *1*ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å›ç­”æ¡ˆ *-2^{31}*ï¼›
    - å¦‚æœé™¤æ•°ä¸º *-1*ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸º *2^{31}*ï¼Œäº§ç”Ÿäº†æº¢å‡ºã€‚æ­¤æ—¶æˆ‘ä»¬éœ€è¦è¿”å› *2^{31} - 1*ã€‚

- å½“é™¤æ•°ä¸º *32* ä½æœ‰ç¬¦å·æ•´æ•°çš„æœ€å°å€¼ *-2^{31}* æ—¶ï¼š

    - å¦‚æœè¢«é™¤æ•°åŒæ ·ä¸º *-2^{31}*ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å›ç­”æ¡ˆ *1*ï¼›
    - å¯¹äºå…¶ä½™çš„æƒ…å†µï¼Œæˆ‘ä»¬è¿”å›ç­”æ¡ˆ *0*ã€‚

- å½“è¢«é™¤æ•°ä¸º *0* æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å›ç­”æ¡ˆ *0*ã€‚

å¯¹äºä¸€èˆ¬çš„æƒ…å†µï¼Œæ ¹æ®é™¤æ•°å’Œè¢«é™¤æ•°çš„ç¬¦å·ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘ *4* ç§ä¸åŒçš„å¯èƒ½æ€§ã€‚å› æ­¤ï¼Œä¸ºäº†æ–¹ä¾¿ç¼–ç ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¢«é™¤æ•°æˆ–è€…é™¤æ•°å–ç›¸åæ•°ï¼Œä½¿å¾—å®ƒä»¬ç¬¦å·ç›¸åŒã€‚

å¦‚æœæˆ‘ä»¬å°†è¢«é™¤æ•°å’Œé™¤æ•°éƒ½å˜ä¸ºæ­£æ•°ï¼Œé‚£ä¹ˆå¯èƒ½ä¼šå¯¼è‡´æº¢å‡ºã€‚ä¾‹å¦‚å½“è¢«é™¤æ•°ä¸º *-2^{31}* æ—¶ï¼Œå®ƒçš„ç›¸åæ•° *2^{31}* äº§ç”Ÿäº†æº¢å‡ºã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘å°†è¢«é™¤æ•°å’Œé™¤æ•°éƒ½å˜ä¸ºè´Ÿæ•°ï¼Œè¿™æ ·å°±ä¸ä¼šæœ‰æº¢å‡ºçš„é—®é¢˜ï¼Œåœ¨ç¼–ç æ—¶åªéœ€è¦è€ƒè™‘ *1* ç§æƒ…å†µäº†ã€‚

å¦‚æœæˆ‘ä»¬å°†è¢«é™¤æ•°å’Œé™¤æ•°çš„å…¶ä¸­ï¼ˆæ°å¥½ï¼‰ä¸€ä¸ªå˜ä¸ºäº†æ­£æ•°ï¼Œé‚£ä¹ˆåœ¨è¿”å›ç­”æ¡ˆä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å¯¹ç­”æ¡ˆä¹Ÿå–ç›¸åæ•°ã€‚


## æ–¹æ³•ä¸€ï¼šäºŒåˆ†æŸ¥æ‰¾

**æ€è·¯ä¸ç®—æ³•**

æ ¹æ®ã€Œå‰è¨€ã€éƒ¨åˆ†çš„è®¨è®ºï¼Œæˆ‘ä»¬è®°è¢«é™¤æ•°ä¸º *X*ï¼Œé™¤æ•°ä¸º *Y*ï¼Œå¹¶ä¸” *X* å’Œ *Y* éƒ½æ˜¯è´Ÿæ•°ã€‚æˆ‘ä»¬éœ€è¦æ‰¾å‡º *X/Y* çš„ç»“æœ *Z*ã€‚*Z* ä¸€å®šæ˜¯æ­£æ•°æˆ– *0*ã€‚

æ ¹æ®é™¤æ³•ä»¥åŠä½™æ•°çš„å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶æ”¹æˆä¹˜æ³•çš„ç­‰ä»·å½¢å¼

**ç»†èŠ‚**

ç”±äºæˆ‘ä»¬åªèƒ½ä½¿ç”¨ *32* ä½æ•´æ•°ï¼Œå› æ­¤äºŒåˆ†æŸ¥æ‰¾ä¸­ä¼šæœ‰å¾ˆå¤šç»†èŠ‚ã€‚

é¦–å…ˆï¼ŒäºŒåˆ†æŸ¥æ‰¾çš„ä¸‹ç•Œä¸º *1*ï¼Œä¸Šç•Œä¸º *2^{31} - 1*ã€‚å”¯ä¸€å¯èƒ½å‡ºç°çš„ç­”æ¡ˆä¸º *2^{31}* çš„æƒ…å†µå·²ç»è¢«æˆ‘ä»¬åœ¨ã€Œå‰è¨€ã€éƒ¨åˆ†è¿›è¡Œäº†ç‰¹æ®Šå¤„ç†ï¼Œå› æ­¤ç­”æ¡ˆçš„æœ€å¤§å€¼ä¸º *2^{31} - 1*ã€‚å¦‚æœäºŒåˆ†æŸ¥æ‰¾å¤±è´¥ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸€å®šä¸º *0*ã€‚

åœ¨å®ç°ã€Œå¿«é€Ÿä¹˜ã€æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨åŠ æ³•è¿ç®—ï¼Œç„¶è€Œè¾ƒå¤§çš„ *Z* ä¹Ÿä¼šå¯¼è‡´åŠ æ³•è¿ç®—æº¢å‡ºã€‚ä¾‹å¦‚æˆ‘ä»¬è¦åˆ¤æ–­ *A + B* æ˜¯å¦å°äº *C* æ—¶ï¼ˆå…¶ä¸­ *A, B, C* å‡ä¸ºè´Ÿæ•°ï¼‰ï¼Œ*A + B* å¯èƒ½ä¼šäº§ç”Ÿæº¢å‡ºï¼Œå› æ­¤æˆ‘ä»¬å¿…é¡»å°†åˆ¤æ–­æ”¹ä¸º *A < C - B* æ˜¯å¦æˆç«‹ã€‚ç”±äºä»»æ„ä¸¤ä¸ªè´Ÿæ•°çš„å·®ä¸€å®šåœ¨ *[-2^{31} + 1, 2^{31} - 1]* èŒƒå›´å†…ï¼Œè¿™æ ·å°±ä¸ä¼šäº§ç”Ÿæº¢å‡ºã€‚

è¯»è€…å¯ä»¥é˜…è¯»ä¸‹é¢çš„ä»£ç å’Œæ³¨é‡Šï¼Œç†è§£å¦‚ä½•é¿å…ä½¿ç”¨ä¹˜æ³•å’Œé™¤æ³•ï¼Œä»¥åŠæ­£ç¡®å¤„ç†æº¢å‡ºé—®é¢˜ã€‚[^1][^2]

**ä»£ç **
<details>
    <summary>C++</summary>
    
```C++ [sol1-C++]
class Solution {
public:
    int divide(int dividend, int divisor) {
        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (dividend == INT_MIN) {
            if (divisor == 1) {
                return INT_MIN;
            }
            if (divisor == -1) {
                return INT_MAX;
            }
        }
        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (divisor == INT_MIN) {
            return dividend == INT_MIN ? 1 : 0;
        }
        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if (dividend == 0) {
            return 0;
        }
        
        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾
        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
        bool rev = false;
        if (dividend > 0) {
            dividend = -dividend;
            rev = !rev;
        }
        if (divisor > 0) {
            divisor = -divisor;
            rev = !rev;
        }

        // å¿«é€Ÿä¹˜
        auto quickAdd = [](int y, int z, int x) {
            // x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°
            // éœ€è¦åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹
            int result = 0, add = y;
            while (z) {
                if (z & 1) {
                    // éœ€è¦ä¿è¯ result + add >= x
                    if (result < x - add) {
                        return false;
                    }
                    result += add;
                }
                if (z != 1) {
                    // éœ€è¦ä¿è¯ add + add >= x
                    if (add < x - add) {
                        return false;
                    }
                    add += add;
                }
                // ä¸èƒ½ä½¿ç”¨é™¤æ³•
                z >>= 1;
            }
            return true;
        };
        
        int left = 1, right = INT_MAX, ans = 0;
        while (left <= right) {
            // æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•
            int mid = left + ((right - left) >> 1);
            bool check = quickAdd(divisor, mid, dividend);
            if (check) {
                ans = mid;
                // æ³¨æ„æº¢å‡º
                if (mid == INT_MAX) {
                    break;
                }
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }

        return rev ? -ans : ans;
    }
};
```
</details>
<details>
    <summary>Java</summary>
    
```Java [sol1-Java]
class Solution {
    public int divide(int dividend, int divisor) {
        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (dividend == Integer.MIN_VALUE) {
            if (divisor == 1) {
                return Integer.MIN_VALUE;
            }
            if (divisor == -1) {
                return Integer.MAX_VALUE;
            }
        }
        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (divisor == Integer.MIN_VALUE) {
            return dividend == Integer.MIN_VALUE ? 1 : 0;
        }
        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if (dividend == 0) {
            return 0;
        }
        
        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾
        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
        boolean rev = false;
        if (dividend > 0) {
            dividend = -dividend;
            rev = !rev;
        }
        if (divisor > 0) {
            divisor = -divisor;
            rev = !rev;
        }
        
        int left = 1, right = Integer.MAX_VALUE, ans = 0;
        while (left <= right) {
            // æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•
            int mid = left + ((right - left) >> 1);
            boolean check = quickAdd(divisor, mid, dividend);
            if (check) {
                ans = mid;
                // æ³¨æ„æº¢å‡º
                if (mid == Integer.MAX_VALUE) {
                    break;
                }
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return rev ? -ans : ans;
    }

    // å¿«é€Ÿä¹˜
    public boolean quickAdd(int y, int z, int x) {
        // x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°
        // éœ€è¦åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹
        int result = 0, add = y;
        while (z != 0) {
            if ((z & 1) != 0) {
                // éœ€è¦ä¿è¯ result + add >= x
                if (result < x - add) {
                    return false;
                }
                result += add;
            }
            if (z != 1) {
                // éœ€è¦ä¿è¯ add + add >= x
                if (add < x - add) {
                    return false;
                }
                add += add;
            }
            // ä¸èƒ½ä½¿ç”¨é™¤æ³•
            z >>= 1;
        }
        return true;
    }
}
```
</details>
<details>
    <summary>C#</summary>
    
```C# [sol1-C#]
public class Solution {
    public int Divide(int dividend, int divisor) {
        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (dividend == int.MinValue) {
            if (divisor == 1) {
                return int.MinValue;
            }
            if (divisor == -1) {
                return int.MaxValue;
            }
        }
        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (divisor == int.MinValue) {
            return dividend == int.MinValue ? 1 : 0;
        }
        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if (dividend == 0) {
            return 0;
        }
        
        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾
        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
        bool rev = false;
        if (dividend > 0) {
            dividend = -dividend;
            rev = !rev;
        }
        if (divisor > 0) {
            divisor = -divisor;
            rev = !rev;
        }
        
        int left = 1, right = int.MaxValue, ans = 0;
        while (left <= right) {
            // æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•
            int mid = left + ((right - left) >> 1);
            bool check = quickAdd(divisor, mid, dividend);
            if (check) {
                ans = mid;
                // æ³¨æ„æº¢å‡º
                if (mid == int.MaxValue) {
                    break;
                }
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return rev ? -ans : ans;
    }

    // å¿«é€Ÿä¹˜
    public bool quickAdd(int y, int z, int x) {
        // x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°
        // éœ€è¦åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹
        int result = 0, add = y;
        while (z != 0) {
            if ((z & 1) != 0) {
                // éœ€è¦ä¿è¯ result + add >= x
                if (result < x - add) {
                    return false;
                }
                result += add;
            }
            if (z != 1) {
                // éœ€è¦ä¿è¯ add + add >= x
                if (add < x - add) {
                    return false;
                }
                add += add;
            }
            // ä¸èƒ½ä½¿ç”¨é™¤æ³•
            z >>= 1;
        }
        return true;
    }
}
```
</details>
<details>
    <summary>Python</summary>
    
```Python [sol1-Python3]
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        INT_MIN, INT_MAX = -2**31, 2**31 - 1

        # è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if dividend == INT_MIN:
            if divisor == 1:
                return INT_MIN
            if divisor == -1:
                return INT_MAX
        
        # è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if divisor == INT_MIN:
            return 1 if dividend == INT_MIN else 0
        # è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if dividend == 0:
            return 0
        
        # ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾
        # å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
        rev = False
        if dividend > 0:
            dividend = -dividend
            rev = not rev
        if divisor > 0:
            divisor = -divisor
            rev = not rev

        # å¿«é€Ÿä¹˜
        def quickAdd(y: int, z: int, x: int) -> bool:
            # x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°
            # éœ€è¦åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹
            result, add = 0, y
            while z > 0:
                if (z & 1) == 1:
                    # éœ€è¦ä¿è¯ result + add >= x
                    if result < x - add:
                        return False
                    result += add
                if z != 1:
                    # éœ€è¦ä¿è¯ add + add >= x
                    if add < x - add:
                        return False
                    add += add
                # ä¸èƒ½ä½¿ç”¨é™¤æ³•
                z >>= 1
            return True
        
        left, right, ans = 1, INT_MAX, 0
        while left <= right:
            # æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•
            mid = left + ((right - left) >> 1)
            check = quickAdd(divisor, mid, dividend)
            if check:
                ans = mid
                # æ³¨æ„æº¢å‡º
                if mid == INT_MAX:
                    break
                left = mid + 1
            else:
                right = mid - 1

        return -ans if rev else ans
```
</details>
<details>
    <summary>Golang</summary>
    
```go [sol1-Golang]
// å¿«é€Ÿä¹˜
// x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°
// åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹
func quickAdd(y, z, x int) bool {
    for result, add := 0, y; z > 0; z >>= 1 { // ä¸èƒ½ä½¿ç”¨é™¤æ³•
        if z&1 > 0 {
            // éœ€è¦ä¿è¯ result + add >= x
            if result < x-add {
                return false
            }
            result += add
        }
        if z != 1 {
            // éœ€è¦ä¿è¯ add + add >= x
            if add < x-add {
                return false
            }
            add += add
        }
    }
    return true
}

func divide(dividend, divisor int) int {
    if dividend == math.MinInt32 { // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if divisor == 1 {
            return math.MinInt32
        }
        if divisor == -1 {
            return math.MaxInt32
        }
    }
    if divisor == math.MinInt32 { // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if dividend == math.MinInt32 {
            return 1
        }
        return 0
    }
    if dividend == 0 { // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        return 0
    }

    // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾
    // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
    rev := false
    if dividend > 0 {
        dividend = -dividend
        rev = !rev
    }
    if divisor > 0 {
        divisor = -divisor
        rev = !rev
    }

    ans := 0
    left, right := 1, math.MaxInt32
    for left <= right {
        mid := left + (right-left)>>1 // æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•
        if quickAdd(divisor, mid, dividend) {
            ans = mid
            if mid == math.MaxInt32 { // æ³¨æ„æº¢å‡º
                break
            }
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    if rev {
        return -ans
    }
    return ans
}
```
</details>
<details>
    <summary>JavaScript</summary>
    

```JavaScript [sol1-JavaScript]
var divide = function(dividend, divisor) {
    const MAX_VALUE = 2 ** 31 - 1, MIN_VALUE = -(2 ** 31);
    // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
    if (dividend === MIN_VALUE) {
        if (divisor === 1) {
            return MIN_VALUE;
        }
        if (divisor === -1) {
            return MAX_VALUE;
        }
    }
    // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
    if (divisor === MIN_VALUE) {
        return dividend === MIN_VALUE ? 1 : 0;
    }
    // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
    if (dividend === 0) {
        return 0;
    }
    
    // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾
    // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
    let rev = false;
    if (dividend > 0) {
        dividend = -dividend;
        rev = !rev;
    }
    if (divisor > 0) {
        divisor = -divisor;
        rev = !rev;
    }
    
    let left = 1, right = MAX_VALUE, ans = 0;
    while (left <= right) {
        // æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•
        const mid = left + ((right - left) >> 1);
        const check = quickAdd(divisor, mid, dividend);
        if (check) {
            ans = mid;
            // æ³¨æ„æº¢å‡º
            if (mid === MAX_VALUE) {
                break;
            }
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return rev ? -ans : ans;
}

// å¿«é€Ÿä¹˜
const quickAdd = (y, z, x) => {
    // x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°
    // éœ€è¦åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹
    let result = 0, add = y;
    while (z !== 0) {
        if ((z & 1) !== 0) {
            // éœ€è¦ä¿è¯ result + add >= x
            if (result < x - add) {
                return false;
            }
            result += add;
        }
        if (z !== 1) {
            // éœ€è¦ä¿è¯ add + add >= x
            if (add < x - add) {
                return false;
            }
            add += add;
        }
        // ä¸èƒ½ä½¿ç”¨é™¤æ³•
        z >>= 1;
    }
    return true;
};
```

</details>


## æ–¹æ³•äºŒï¼šç±»äºŒåˆ†æŸ¥æ‰¾

**æ€è·¯ä¸ç®—æ³•**[^1]

**ä»£ç **

<details>
    <summary>C++</summary>
    
```C++ [sol2-C++]
class Solution {
public:
    int divide(int dividend, int divisor) {
        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (dividend == INT_MIN) {
            if (divisor == 1) {
                return INT_MIN;
            }
            if (divisor == -1) {
                return INT_MAX;
            }
        }
        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (divisor == INT_MIN) {
            return dividend == INT_MIN ? 1 : 0;
        }
        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if (dividend == 0) {
            return 0;
        }
        
        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨ç±»äºŒåˆ†æŸ¥æ‰¾
        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
        bool rev = false;
        if (dividend > 0) {
            dividend = -dividend;
            rev = !rev;
        }
        if (divisor > 0) {
            divisor = -divisor;
            rev = !rev;
        }

        vector<int> candidates = {divisor};
        // æ³¨æ„æº¢å‡º
        while (candidates.back() >= dividend - candidates.back()) {
            candidates.push_back(candidates.back() + candidates.back());
        }
        int ans = 0;
        for (int i = candidates.size() - 1; i >= 0; --i) {
            if (candidates[i] >= dividend) {
                ans += (1 << i);
                dividend -= candidates[i];
            }
        }

        return rev ? -ans : ans;
    }
};
```
</details>
<details>
    <summary>Java</summary>
   
```Java [sol2-Java]
class Solution {
    public int divide(int dividend, int divisor) {
        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (dividend == Integer.MIN_VALUE) {
            if (divisor == 1) {
                return Integer.MIN_VALUE;
            }
            if (divisor == -1) {
                return Integer.MAX_VALUE;
            }
        }
        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (divisor == Integer.MIN_VALUE) {
            return dividend == Integer.MIN_VALUE ? 1 : 0;
        }
        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if (dividend == 0) {
            return 0;
        }
        
        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨ç±»äºŒåˆ†æŸ¥æ‰¾
        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
        boolean rev = false;
        if (dividend > 0) {
            dividend = -dividend;
            rev = !rev;
        }
        if (divisor > 0) {
            divisor = -divisor;
            rev = !rev;
        }

        List<Integer> candidates = new ArrayList<Integer>();
        candidates.add(divisor);
        int index = 0;
        // æ³¨æ„æº¢å‡º
        while (candidates.get(index) >= dividend - candidates.get(index)) {
            candidates.add(candidates.get(index) + candidates.get(index));
            ++index;
        }
        int ans = 0;
        for (int i = candidates.size() - 1; i >= 0; --i) {
            if (candidates.get(i) >= dividend) {
                ans += 1 << i;
                dividend -= candidates.get(i);
            }
        }

        return rev ? -ans : ans;
    }
}
```
</details>
<details>
    <summary>C#</summary>
   
```C# [sol2-C#]
public class Solution {
    public int Divide(int dividend, int divisor) {
        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (dividend == int.MinValue) {
            if (divisor == 1) {
                return int.MinValue;
            }
            if (divisor == -1) {
                return int.MaxValue;
            }
        }
        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (divisor == int.MinValue) {
            return dividend == int.MinValue ? 1 : 0;
        }
        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if (dividend == 0) {
            return 0;
        }
        
        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨ç±»äºŒåˆ†æŸ¥æ‰¾
        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
        bool rev = false;
        if (dividend > 0) {
            dividend = -dividend;
            rev = !rev;
        }
        if (divisor > 0) {
            divisor = -divisor;
            rev = !rev;
        }

        IList<int> candidates = new List<int>();
        candidates.Add(divisor);
        int index = 0;
        // æ³¨æ„æº¢å‡º
        while (candidates[index] >= dividend - candidates[index]) {
            candidates.Add(candidates[index] + candidates[index]);
            ++index;
        }
        int ans = 0;
        for (int i = candidates.Count - 1; i >= 0; --i) {
            if (candidates[i] >= dividend) {
                ans += 1 << i;
                dividend -= candidates[i];
            }
        }

        return rev ? -ans : ans;
    }
}
```
</details>
<details>
    <summary>Python3</summary>
   
```Python [sol2-Python3]
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        INT_MIN, INT_MAX = -2**31, 2**31 - 1

        # è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if dividend == INT_MIN:
            if divisor == 1:
                return INT_MIN
            if divisor == -1:
                return INT_MAX
        
        # è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if divisor == INT_MIN:
            return 1 if dividend == INT_MIN else 0
        # è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if dividend == 0:
            return 0
        
        # ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨ç±»äºŒåˆ†æŸ¥æ‰¾
        # å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
        rev = False
        if dividend > 0:
            dividend = -dividend
            rev = not rev
        if divisor > 0:
            divisor = -divisor
            rev = not rev
        
        candidates = [divisor]
        # æ³¨æ„æº¢å‡º
        while candidates[-1] >= dividend - candidates[-1]:
            candidates.append(candidates[-1] + candidates[-1])
        
        ans = 0
        for i in range(len(candidates) - 1, -1, -1):
            if candidates[i] >= dividend:
                ans += (1 << i)
                dividend -= candidates[i]

        return -ans if rev else ans
```
</details>
<details>
    <summary>Golang</summary>
   
```go [sol2-Golang]
func divide(dividend, divisor int) int {
    if dividend == math.MinInt32 { // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if divisor == 1 {
            return math.MinInt32
        }
        if divisor == -1 {
            return math.MaxInt32
        }
    }
    if divisor == math.MinInt32 { // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if dividend == math.MinInt32 {
            return 1
        }
        return 0
    }
    if dividend == 0 { // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        return 0
    }

    // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾
    // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
    rev := false
    if dividend > 0 {
        dividend = -dividend
        rev = !rev
    }
    if divisor > 0 {
        divisor = -divisor
        rev = !rev
    }

    candidates := []int{divisor}
    for y := divisor; y >= dividend-y; { // æ³¨æ„æº¢å‡º
        y += y
        candidates = append(candidates, y)
    }

    ans := 0
    for i := len(candidates) - 1; i >= 0; i-- {
        if candidates[i] >= dividend {
            ans |= 1 << i
            dividend -= candidates[i]
        }
    }
    if rev {
        return -ans
    }
    return ans
}
```
</details>
<details>
    <summary>JavaScript</summary>
   
```JavaScript [sol2-JavaScript]
var divide = function(dividend, divisor) {
    const MAX_VALUE = 2 ** 31 - 1, MIN_VALUE = -(2 ** 31);
    // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
    if (dividend === MIN_VALUE) {
        if (divisor === 1) {
            return MIN_VALUE;
        }
        if (divisor === -1) {
            return MAX_VALUE;
        }
    }
    // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
    if (divisor === MIN_VALUE) {
        return dividend === MIN_VALUE ? 1 : 0;
    }
    // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
    if (dividend === 0) {
        return 0;
    }
    
    // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨ç±»äºŒåˆ†æŸ¥æ‰¾
    // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
    let rev = false;
    if (dividend > 0) {
        dividend = -dividend;
        rev = !rev;
    }
    if (divisor > 0) {
        divisor = -divisor;
        rev = !rev;
    }

    const candidates = [divisor];
    let index = 0;
    // æ³¨æ„æº¢å‡º
    while (candidates[index] >= dividend - candidates[index]) {
        candidates.push(candidates[index] + candidates[index]);
        ++index;
    }
    let ans = 0;
    for (let i = candidates.length - 1; i >= 0; --i) {
        if (candidates[i] >= dividend) {
            ans += 1 << i;
            dividend -= candidates[i];
        }
    }

    return rev ? -ans : ans;
};
```
</details>

[^1]:https://leetcode-cn.com/problems/divide-two-integers/solution/liang-shu-xiang-chu-by-leetcode-solution-5hic/

[^2]:https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/