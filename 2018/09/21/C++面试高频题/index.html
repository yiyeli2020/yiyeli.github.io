<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>C++面试高频题 | Yiye Li</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="整理一下互联网公司语言基础（C++）面试高频题">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面试高频题">
<meta property="og:url" content="http://yoursite.com/2018/09/21/C++%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/index.html">
<meta property="og:site_name" content="Yiye Li">
<meta property="og:description" content="整理一下互联网公司语言基础（C++）面试高频题">
<meta property="og:locale">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/0071ouepgy1fv5pefakcgj30as088my3.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/0071ouepgy1fv5tyr1p07j30h20by41b.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/0071ouepgy1fv5ua8ciphj30i90ahgns.jpg">
<meta property="article:published_time" content="2018-09-21T09:12:13.000Z">
<meta property="article:modified_time" content="2019-07-18T04:07:23.000Z">
<meta property="article:author" content="Yiye Li">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/0071ouepgy1fv5pefakcgj30as088my3.jpg">
  
    <link rel="alternative" href="/atom.xml" title="Yiye Li" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
<meta name="generator" content="Hexo 6.0.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate"></a></h1>
        </hgroup>

        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=KBoeHhgdGBEQHhBoWVkGS0dF" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/liyiye012" title="github">github</a>
                            
                                <a class="fl linkedin" target="_blank" href="https://www.linkedin.com/in/yiye-li-864b3a99/" title="linkedin">linkedin</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Algorithm/" style="font-size: 11.92px;">Algorithm</a> <a href="/tags/Array/" style="font-size: 19.23px;">Array</a> <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/Backtracking/" style="font-size: 16.92px;">Backtracking</a> <a href="/tags/Binary-Indexed-Tree/" style="font-size: 10px;">Binary Indexed Tree</a> <a href="/tags/Binary-Search/" style="font-size: 16.92px;">Binary Search</a> <a href="/tags/Binary-Search-Tree/" style="font-size: 10px;">Binary Search Tree</a> <a href="/tags/Binary-Tree/" style="font-size: 10.77px;">Binary Tree</a> <a href="/tags/BinaryTree/" style="font-size: 10.38px;">BinaryTree</a> <a href="/tags/Bit-Manipulation/" style="font-size: 16.92px;">Bit Manipulation</a> <a href="/tags/Brainteaser/" style="font-size: 10.38px;">Brainteaser</a> <a href="/tags/Bread-first-Search/" style="font-size: 10.38px;">Bread-first Search</a> <a href="/tags/Breadth-First-Search/" style="font-size: 11.15px;">Breadth-First Search</a> <a href="/tags/Breadth-first-Search/" style="font-size: 15.38px;">Breadth-first Search</a> <a href="/tags/C/" style="font-size: 14.62px;">C++</a> <a href="/tags/Cache/" style="font-size: 10px;">Cache</a> <a href="/tags/Cassandra/" style="font-size: 10px;">Cassandra</a> <a href="/tags/Coding-Interviews/" style="font-size: 11.92px;">Coding Interviews</a> <a href="/tags/Collection/" style="font-size: 10px;">Collection</a> <a href="/tags/Combinatorics/" style="font-size: 10px;">Combinatorics</a> <a href="/tags/Computer-Network/" style="font-size: 10px;">Computer Network</a> <a href="/tags/Concurrency/" style="font-size: 13.85px;">Concurrency</a> <a href="/tags/Consistency/" style="font-size: 10px;">Consistency</a> <a href="/tags/Counting/" style="font-size: 10.38px;">Counting</a> <a href="/tags/Cracking-the-Coding-Interview/" style="font-size: 10.38px;">Cracking the Coding Interview</a> <a href="/tags/DFS/" style="font-size: 10px;">DFS</a> <a href="/tags/Data-Structure/" style="font-size: 10px;">Data Structure</a> <a href="/tags/Database/" style="font-size: 16.15px;">Database</a> <a href="/tags/Database%EF%BC%8CMySQL/" style="font-size: 13.08px;">Database，MySQL</a> <a href="/tags/Depth-First-Search/" style="font-size: 11.15px;">Depth-First Search</a> <a href="/tags/Depth-first-Search/" style="font-size: 16.15px;">Depth-first Search</a> <a href="/tags/Depth-first-search/" style="font-size: 10px;">Depth-first search</a> <a href="/tags/Design/" style="font-size: 13.46px;">Design</a> <a href="/tags/Design-Pattern%EF%BC%8CJava/" style="font-size: 11.54px;">Design Pattern，Java</a> <a href="/tags/Divide-and-Conque/" style="font-size: 10px;">Divide and Conque</a> <a href="/tags/Divide-and-Conquer/" style="font-size: 11.92px;">Divide and Conquer</a> <a href="/tags/Division/" style="font-size: 10px;">Division</a> <a href="/tags/Dynamic-Programming/" style="font-size: 18.46px;">Dynamic Programming</a> <a href="/tags/Dynammic-Programming/" style="font-size: 11.15px;">Dynammic Programming</a> <a href="/tags/Encryption/" style="font-size: 10px;">Encryption</a> <a href="/tags/Git/" style="font-size: 11.54px;">Git</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Google/" style="font-size: 10px;">Google</a> <a href="/tags/Grafana/" style="font-size: 10px;">Grafana</a> <a href="/tags/Graph/" style="font-size: 11.92px;">Graph</a> <a href="/tags/Greedy/" style="font-size: 13.08px;">Greedy</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/Hash-Function/" style="font-size: 10px;">Hash Function</a> <a href="/tags/Hash-Table/" style="font-size: 18.08px;">Hash Table</a> <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a> <a href="/tags/Hbase/" style="font-size: 10px;">Hbase</a> <a href="/tags/Heap/" style="font-size: 13.46px;">Heap</a> <a href="/tags/Hexo/" style="font-size: 11.54px;">Hexo</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 18.85px;">Java</a> <a href="/tags/KMP-Algorithm/" style="font-size: 10.77px;">KMP Algorithm</a> <a href="/tags/Kafka/" style="font-size: 10px;">Kafka</a> <a href="/tags/Kickstart/" style="font-size: 10px;">Kickstart</a> <a href="/tags/Latex/" style="font-size: 10px;">Latex</a> <a href="/tags/LeetCode/" style="font-size: 19.62px;">LeetCode</a> <a href="/tags/Leetcode/" style="font-size: 20px;">Leetcode</a> <a href="/tags/LinkList/" style="font-size: 10px;">LinkList</a> <a href="/tags/Linked-List/" style="font-size: 15.77px;">Linked List</a> <a href="/tags/Linux/" style="font-size: 11.54px;">Linux</a> <a href="/tags/Log/" style="font-size: 10px;">Log</a> <a href="/tags/Math/" style="font-size: 17.31px;">Math</a> <a href="/tags/Matrix/" style="font-size: 11.15px;">Matrix</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Max-Heap/" style="font-size: 10px;">Max Heap</a> <a href="/tags/Memoization/" style="font-size: 11.15px;">Memoization</a> <a href="/tags/Microservice/" style="font-size: 10px;">Microservice</a> <a href="/tags/Minimax/" style="font-size: 10px;">Minimax</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/Monotonic-Stack/" style="font-size: 12.31px;">Monotonic Stack</a> <a href="/tags/MySQL/" style="font-size: 14.23px;">MySQL</a> <a href="/tags/NIO/" style="font-size: 10px;">NIO</a> <a href="/tags/Netty/" style="font-size: 10px;">Netty</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a> <a href="/tags/Note/" style="font-size: 10px;">Note</a> <a href="/tags/Operating-System/" style="font-size: 10.38px;">Operating System</a> <a href="/tags/Ordered-Map/" style="font-size: 10px;">Ordered Map</a> <a href="/tags/Prefix-Sum/" style="font-size: 11.15px;">Prefix Sum</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/RPC/" style="font-size: 10px;">RPC</a> <a href="/tags/Recursion/" style="font-size: 12.31px;">Recursion</a> <a href="/tags/Recursive/" style="font-size: 10px;">Recursive</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/Scala/" style="font-size: 11.54px;">Scala</a> <a href="/tags/Segment-Tree/" style="font-size: 10px;">Segment Tree</a> <a href="/tags/Shell/" style="font-size: 10.38px;">Shell</a> <a href="/tags/Simulation/" style="font-size: 10.38px;">Simulation</a> <a href="/tags/Sliding-Window/" style="font-size: 15px;">Sliding Window</a> <a href="/tags/Sort/" style="font-size: 13.46px;">Sort</a> <a href="/tags/Spark/" style="font-size: 10px;">Spark</a> <a href="/tags/Spring/" style="font-size: 10.77px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 11.92px;">SpringBoot</a> <a href="/tags/Stack/" style="font-size: 16.15px;">Stack</a> <a href="/tags/Storm/" style="font-size: 10px;">Storm</a> <a href="/tags/String/" style="font-size: 17.69px;">String</a> <a href="/tags/String-Matching/" style="font-size: 11.15px;">String Matching</a> <a href="/tags/Suffix-Array/" style="font-size: 10px;">Suffix Array</a> <a href="/tags/TCPIP/" style="font-size: 10px;">TCPIP</a> <a href="/tags/Template/" style="font-size: 10.38px;">Template</a> <a href="/tags/TensorFlow/" style="font-size: 10px;">TensorFlow</a> <a href="/tags/Topological-Sort/" style="font-size: 10px;">Topological Sort</a> <a href="/tags/Topological-sort/" style="font-size: 10.77px;">Topological sort</a> <a href="/tags/Tree/" style="font-size: 16.54px;">Tree</a> <a href="/tags/TreeSet/" style="font-size: 10px;">TreeSet</a> <a href="/tags/Trie/" style="font-size: 12.31px;">Trie</a> <a href="/tags/Two-Pointers/" style="font-size: 16.15px;">Two Pointers</a> <a href="/tags/Two-pointers/" style="font-size: 10px;">Two pointers</a> <a href="/tags/Union-Find/" style="font-size: 12.69px;">Union Find</a> <a href="/tags/Virtual-function/" style="font-size: 10px;">Virtual function</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/Wechat/" style="font-size: 10px;">Wechat</a> <a href="/tags/YARN/" style="font-size: 10px;">YARN</a> <a href="/tags/Zookeeper/" style="font-size: 10.38px;">Zookeeper</a> <a href="/tags/blog/" style="font-size: 11.15px;">blog</a> <a href="/tags/fstream/" style="font-size: 10px;">fstream</a> <a href="/tags/heap/" style="font-size: 10px;">heap</a> <a href="/tags/sizeof/" style="font-size: 10px;">sizeof</a> <a href="/tags/stdin/" style="font-size: 10px;">stdin</a> <a href="/tags/vector/" style="font-size: 10px;">vector</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" style="font-size: 10px;">最短路</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://liyiye012.github.io/">name</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">日拱一卒，功不唐捐</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=KBoeHhgdGBEQHhBoWVkGS0dF" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/liyiye012" title="github">github</a>
                    
                        <a class="linkedin" target="_blank" href="https://www.linkedin.com/in/yiye-li-864b3a99/" title="linkedin">linkedin</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-C++面试高频题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/09/21/C++%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/" class="article-date">
      <time datetime="2018-09-21T09:12:13.000Z" itemprop="datePublished">2018-09-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++面试高频题
    </h1>
  

        
      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/2018%E5%B9%B49%E6%9C%88/">2018年9月</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>整理一下互联网公司语言基础（C++）面试高频题</p>
<span id="more"></span>


<p>##（1） 指针和引用的区别</p>
<h3 id="联系"><a href="#联系" class="headerlink" title="联系:"></a>联系:</h3><h4 id="a"><a href="#a" class="headerlink" title="a."></a>a.</h4><p>指针和引用本质上都是地址的概念,引用在内部其实是用const指针来实现的.</p>
<h4 id="b"><a href="#b" class="headerlink" title="b."></a>b.</h4><p>给函数传递参数的时候,一级指针和引用作为函数参数的时候可以达到相同的效果.</p>
<h4 id="c"><a href="#c" class="headerlink" title="c."></a>c.</h4><p>指针的大部分效果都可以通过引用来实现。</p>
<h4 id="d"><a href="#d" class="headerlink" title="d."></a>d.</h4><p>二级指针作为参数的时候就是希望在函数的内部修改指针的指向.这个时候利用指针的引用可以达到同样的效果.</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h3><h4 id="a-1"><a href="#a-1" class="headerlink" title="a."></a>a.</h4><p>定义引用的时候必须初始化,定义指针的时候可以不初始化.</p>
<h4 id="b-1"><a href="#b-1" class="headerlink" title="b."></a>b.</h4><p>引用不能引用空,但是指针可以指向空.</p>
<h4 id="c-1"><a href="#c-1" class="headerlink" title="c."></a>c.</h4><p>引用的关系一旦确定,就无法改变;引用永远指向的是用来对它初始化的对象;而非常属性的指针是可以改变指向的.</p>
<h4 id="d-1"><a href="#d-1" class="headerlink" title="d."></a>d.</h4><p>指针是一个实体变量,在32位操作系统上面都是4个字节.而引用只是一个别名,其大小和其应用的对象的类型有关系.</p>
<h4 id="e"><a href="#e" class="headerlink" title="e."></a>e.</h4><p>有指向指针的指针,但是没有引用引用的引用;因为引用一旦建立,它就表示初始化它的对象.</p>
<h4 id="f"><a href="#f" class="headerlink" title="f."></a>f.</h4><p>有引用指针的引用,但是没有指向引用的指针；</p>
<h4 id="g"><a href="#g" class="headerlink" title="g."></a>g.</h4><p>有指针数组,但是没有引用数组,但是有数组的引用.</p>
<h3 id="参考答案2："><a href="#参考答案2：" class="headerlink" title="参考答案2："></a>参考答案2：</h3><h4 id="1"><a href="#1" class="headerlink" title="1)"></a>1)</h4><p>指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2)"></a>2)</h4><p>引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）</p>
<h4 id="3"><a href="#3" class="headerlink" title="3)"></a>3)</h4><p>有多级指针，但是没有多级引用，只能有一级引用。</p>
<h4 id="4"><a href="#4" class="headerlink" title="4)"></a>4)</h4><p>指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）</p>
<h4 id="5"><a href="#5" class="headerlink" title="5)"></a>5)</h4><p>sizeof 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。</p>
<h4 id="6"><a href="#6" class="headerlink" title="6)"></a>6)</h4><p>引用访问一个变量是直接访问，而指针访问一个变量是间接访问。</p>
<h4 id="7"><a href="#7" class="headerlink" title="7)"></a>7)</h4><p>使用指针前最好做类型检查，防止野指针的出现；</p>
<h4 id="8"><a href="#8" class="headerlink" title="8)"></a>8)</h4><p>引用底层是通过指针实现的；</p>
<h4 id="9"><a href="#9" class="headerlink" title="9)"></a>9)</h4><p>作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。</p>
<p>下面是一段代码非常的全面:</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
void foo(int a[3])/*这个地方传递的是数组的首地址*/
&#123;
     cout &lt;&lt; sizeof(a)/sizeof(a[0]) &lt;&lt; endl;
&#125;
void bar(int (&amp;a)[3])/*这里传参的时候就是数组的整体*/
&#123;
     cout &lt;&lt; sizeof(a)/sizeof(a[0]) &lt;&lt; endl;
&#125;
int main(void)
&#123;
     int a;
     int* p = &amp;a;
     int** pp = &amp;p;/*存在指向指针的指针*/
     int&amp; r  = a;
     int&amp;&amp; rr = r;/*error没有引用引用的引用*/
     int*&amp;  rp = p; /*有引用指针的引用(指针引用)*/
     int&amp;* pr = &amp;r; /*没有指向引用的指针(引用指针)*/
     int x, y, z;
     int* pa[] = &#123;&amp;x,&amp;y,&amp;z&#125;;/*指针数组*/
     int&amp; ra[] = &#123;x,y,z&#125;;/*引用数组是不存在的因为引用不是一个实体*/
     int arr[3] = &#123;0&#125;;
     int (&amp;ar)[3] = arr;/*数组引用(先近后远,先右后左)*/
     foo(arr);/*这里传递的是数组的第一个元素的首地址*/
     cout &lt;&lt; sizeof(arr)/sizeof(arr[0]) &lt;&lt; endl;
     /*这里的数组名代表的是真个数组*/
     int (*parr)[3] = &amp;arr;/*对数组名取地址得到的是一个数组指针
                             这个时候arr代表的是数组的整体;*/
     bar(arr);/*这里传递的就是数组的整体*/
     return 0;
&#125;
</code></pre>
<p>##（2） 堆和栈的区别</p>
<h4 id="a-管理方式不同"><a href="#a-管理方式不同" class="headerlink" title="a.管理方式不同:"></a>a.管理方式不同:</h4><p>栈是由编译器自动分配和释放,使用方便;而对于堆来说,分配和释放都必须由程序员来手动完成,不易管理,容易造成内存泄漏和内存碎片.</p>
<h4 id="b-可用内存空间不同"><a href="#b-可用内存空间不同" class="headerlink" title="b.可用内存空间不同:"></a>b.可用内存空间不同:</h4><p>对于栈来说,它可用的内存空间比较小;而对于堆来说它可以使用的空间比栈要大的多.</p>
<h4 id="c-能否产生碎片不同"><a href="#c-能否产生碎片不同" class="headerlink" title="c.能否产生碎片不同:"></a>c.能否产生碎片不同:</h4><p>由于栈采用的是后进先出的机制,所以栈空间没有内存碎片的产生;而对于堆来说,由于频繁的使用new&#x2F;delete势必会造成内存空间分配的不连续,从而造成大量的碎片,使程序的效率降低.</p>
<h4 id="d-生长方向不同"><a href="#d-生长方向不同" class="headerlink" title="d.生长方向不同:"></a>d.生长方向不同:</h4><p>对于堆来说,它一般是向上的;即是向着地址增加的方向增长;对于栈来说,它一般是向下的,即向着地址减小的方向增长.</p>
<h4 id="e-分配的方式不同"><a href="#e-分配的方式不同" class="headerlink" title="e.分配的方式不同:"></a>e.分配的方式不同:</h4><p>对于堆来说,它只能是动态分配的;而对于栈来说,它分为静态分配和动态分配;静态分配由编译器来进行管理,而动态分配的栈和堆也是不一样的,动态分配的栈由编译器进行释放,无需我们程序员来释放.</p>
<h4 id="f-分配的效率不同"><a href="#f-分配的效率不同" class="headerlink" title="f.分配的效率不同:"></a>f.分配的效率不同:</h4><p>栈是机器系统提供的数据结构,计算机会在底层对栈提供支持:为栈分配专门的寄存器.压栈和出栈都由专门的指令进行.因此它的效率会很高;而堆则是由c&#x2F;c++库函数实现的,机制是非常的负责的;例如要分配一块内存的时候,库函数会利用特定的算法在堆内存中搜索可用大小的内存空间;如果没有足够大的内存空间,就会调用系统功能去增加数据段的内存空间.这样才能得到足够大的可用的内存空间,因此堆内存的分配的效率比栈要低得多.</p>
<p>##（3） new和delete是如何实现的，new 与 malloc的异同处</p>
<h4 id="a-运算符和库函数的区别"><a href="#a-运算符和库函数的区别" class="headerlink" title="a.运算符和库函数的区别"></a>a.运算符和库函数的区别</h4><p>new&#x2F;delete是运算符,只能在C++中使用,它可以重载;mallloc&#x2F;free是C的标准库函数,在C&#x2F;C++中都可以使用.</p>
<h4 id="b-2"><a href="#b-2" class="headerlink" title="b."></a>b.</h4><p>对于非内部的数据类型的对象而言,光用malloc&#x2F;free是无法满足动态对象的要求的.对象在创建的时候需要执行构造函数,对象在消亡之前需要执行析构函数.而molloc&#x2F;free是库函数而不是运算符,不在编译器的控制范围之内,编译器不能将执行构造函数和析构函数的任务强加给malloc&#x2F;free.因此C++需要一个能够完成动态分配内存和初始化的new,以及一个能够完成清理和释放内存的运算符delete.</p>
<h4 id="c-2"><a href="#c-2" class="headerlink" title="c."></a>c.</h4><p>new的返回值是指定类型的指针,可以自动的计算所需要分配的内存大小.而malloc的返回值是一个void类型的指针,我们在使用的时候要进行强制类型转换,并且分配的大小也要程序员手动的计算.</p>
<h4 id="d-2"><a href="#d-2" class="headerlink" title="d."></a>d.</h4><p>new&#x2F;delete完全覆盖了malloc&#x2F;free的功能,只所以还要保留malloc&#x2F;free,是因为我们的C++程序有时要调用用C编写的而C中又没有new&#x2F;delete,只能使用malloc&#x2F;free.<br>##（4） C和C++的区别</p>
<p>C&#x2F;C++的联系：</p>
<p>C++是C的超集，兼容大部分C的语法的结构；<br>联系嘛我只能想到这个，毕竟cplusplus嘛！<br>C&#x2F;C++区别：</p>
<p>第一点就应该想到C是面向过程的语言，而C++是面向对象的语言</p>
<p>C和C++动态管理内存的方法不一样，C是使用malloc&#x2F;free函数，而C++除此之外还有new&#x2F;delete关键字；（关于malooc&#x2F;free与new&#x2F;delete的不同又可以说一大堆，最后的扩展_1部分列出十大区别）；</p>
<p>接下来就不得不谈到C中的struct和C++的类，C++的类是C所没有的，但是C中的struct是可以在C++中正常使用的，并且C++对struct进行了进一步的扩展，使struct在C++中可以和class一样当做类使用，而唯一和class不同的地方在于struct的成员默认访问修饰符是public,而class默认的是private;</p>
<p>C++支持函数重载，而C不支持函数重载，而C++支持重载的依仗就在于C++的名字修饰与C不同，例如在C++中函数int fun(int ,int)经过名字修饰之后变为 _fun_int_int ,而C是<br>_fun，一般是这样的，所以C++才会支持不同的参数调用不同的函数；</p>
<p>C++中有引用，而C没有；这样就不得不提一下引用和指针的区别;</p>
<p>当然还有C++全部变量的默认链接属性是外链接，而C是内连接；</p>
<p>C 中用const修饰的变量不可以用在定义数组时的大小，但是C++用const修饰的变量可以（如果不进行&amp;,解引用的操作的话，是存放在符号表的，不开辟内存）；</p>
<p>当然还有局部变量的声明规则不同，多态，C++特有输入输出流之类的，很多，下面就不再列出来了；</p>
<p>##（5） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</p>
<p>通常，我们聊到Java，第一印象“面向对象”，“没有指针，编写效率高，执行效率较低”。更深入、专业一点就谈论 “java内存自动回收(GC垃圾回收机制)，多线程编程”。**<br>java的三大特性是封装、继承和多态。**</p>
<p>总结如下：</p>
<p>1、 JAVA的应用在高层，C++在中间件和底层</p>
<p>2、 JAVA离不开业务逻辑，而C++可以离开业务为JAVA们服务</p>
<p>3、 java语言给开发人员提供了更为简洁的语法；取消了指针带来更高的代码质量；完全面向对象，独特的运行机制是其具有天然的可移植性。</p>
<p>4、 java 是运行在JVM上的，之所以说它的可移植性强，是因为jvm可以安装到任何的系统</p>
<p>5、 c++不是不能在其他系统运行，而是c++在不同的系统上运行，需要不同的编码（这一点不如java，只编写一次代码，到处运行）。java程序一般都是生成字节码，在JVM里面运行得到结果。</p>
<p>6、 java 在web 应用上具有c++ 无可比拟的优势</p>
<p>7、 java在桌面程序上不如c++实用，C++可以直接编译成exe文件，指针是c++的优势，可以直接对内存的操作，但同时具有危险性 。（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）。</p>
<p>8、 垃圾回收机制的区别。c++用析构函数回收垃圾，java自动回收（GC算法）,写C和C++程序时一定要注意内存的申请和释放。</p>
<p>9、 java 丰富的插件是java 发展如此迅速的原因<br>10、 java 很大的沿袭了c++的一些实用结构<br>11、 对于底层程序的编程以及控制方面的编程，c++很灵活，因为有句柄的存在。</p>
<p>Java并不仅仅是C++语言的一个变种，它们在某些本质问题上有根本的不同：</p>
<p>(1)Java比C++程序可靠性更高。有人曾估计每50行C++程序中至少有一个BUG。姑且不去讨论这个数字是否夸张，但是任何一个C++程序员都不得不承认C++语言在提供强大的功能的同时也提高了程序含BUG的可能性。Java语言通过改变语言的特性大大提高了程序的可靠性。</p>
<p>(2)Java语言不需要程序对内存进行分配和回收。Java丢弃了C++ 中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，并提供了自动的废料收集，在Java语言中，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题。</p>
<p>(3)Java语言中没有指针的概念，引入了真正的数组。不同于C++中利用指针实现的“伪数组”，Java引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在c++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题。</p>
<p>(4)Java用接口(Interface)技术取代C++程序中的多继承性。接口与多继承有同样的功能，但是省却了多继承在实现和维护上的复杂性。</p>
<h2 id="（6）-Struct和class的联系和区别"><a href="#（6）-Struct和class的联系和区别" class="headerlink" title="（6） Struct和class的联系和区别"></a>（6） Struct和class的联系和区别</h2><h3 id="联系-1"><a href="#联系-1" class="headerlink" title="联系"></a>联系</h3><p>1，定义和使用非常相似<br>2，两者都是container类型，这表示它们可以包含其他数据类型作为成员。</p>
<p>3，两者都拥有成员，包括：构造函数、方法、属性、字段、常量、枚举类型、事件、以及事件处理函数。</p>
<p>4，两者的成员都有其各自的存取范围。例如，可以将某一个成员声明为Public，而将另一个成员声明为Private。</p>
<p>5，两者都可以实现接口。</p>
<p>6，两者都可以公开一个默认属性，然而前提是这个属性至少要取得一个自变量。</p>
<p>7，两者都可以声明和触发事件，而且两者都可以声明委托（Delegate）。</p>
<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p>1，结构是实值类型（Value Types），而类则是引用类型（Reference Types）。</p>
<p>2，结构使用栈存储（Stack Allocation），而类使用堆存储（Heap Allocation）。</p>
<p>3，所有结构成员默认都是Public，而类的变量和常量数则默认位Private，不过其他类成员默认都是Public。</p>
<p>4，结构成员不能被声明位Protected，而类成员可以。</p>
<p>5，结构变量声明不能指定初始值、使用New关键字货对数组进行初始化，但是类变量声明可以。</p>
<p>6，结构不能声明默认的构造函数，也就是不拥有参数的非共享构造函数，但是类则无此限制。</p>
<p>7，二者都可以拥有共享构造函数，结构的共享构造函数不能带有参数，但是类的共享构造函数则可以带或者不带参数。</p>
<p>8，结构不允许声明析构函数（Destructor），类则无此限制。</p>
<p>9，结构的实例（Instance）声明，不允许对包含的变量进行初始化设定，类则可以在声明类的实例时，同时进行变量初始化。</p>
<p>10，结构是隐式继承自ValueType类，而且不能继承任何其他类型，类则可以继续自ValueType以外的任何类。</p>
<p>11，结构是无法被继承的，类则可以。</p>
<p>12，结构永远不会终止，因此CLR不会在任何结构上调用Finalize方法。类则是由内存回收进程加以终止，当内存回收进程检测到没有任何作用的类时，它就会调用类的Finalize方法。</p>
<p>13，结构不需要构造函数，类则需要构造函数。</p>
<p>14，结构只能在一种情况下使用非共享构造函数，那就是非共享构造函数会接受参数。但是类则无此限制，它可以使用带参数或不带参数的非共享构造函数。</p>
<p>14，每一个结构都具有无参数的隐含公共构造函数，此构造函数会将结构的所有成员初始化为其默认值。不需要重新定义这个行为。</p>
<p>在“实例和变量”层面上，由于结构是数值类型的，因此每一个结构变量会永远的绑定到结构实例上。然而类是引用类型的，而且对象变量可引用不同的类实例，在此方面的区别，会对使用将结构和类造成如下的影响：</p>
<p>15，结构变量会隐式的使用结构的无参数构造函数来初始化成员，这就意味语句 Struct S &#x3D; new Struct（）。</p>
<p>16，当您将一个结构变量赋值给另一个，或者将结构实例传递到程序变量时，所有变量成员的值会复制到新的结构中。当您将一个对象变量赋值给另一个，或者将对象变量传递给程序时，则只是复制指针。</p>
<p>17，您可以将Null值赋值给结构变量，但是该实例会一直与该变量保持关联。虽然变量成员会因此赋值而重新初始化，但是您还是可以调用变量的方法并访问其数据成员。相反的，如果您将对象变量设定为Null，您就会中断它与任何类型实例的关联，而且除非您再将另一个实例赋值给它，否则无法通过变量访问任何成员。</p>
<p>18，您可以在不同时间将不同的类的实例赋值给同一个对象变量，而且在同一时间可有好几个对象变量引用相同的类实例，如果您对类成员值做了改变，则其他指向相同实例的对象变量也会发生改变。然而，结构成员则会封装在他们自己的实例中，变更结构成员值并不会对其他任何结构变量的成员造成影响，甚至也不会影响相同结构声明的其他实例。</p>
<p>19，两个结构必须以成员对成员的比较方式来执行相等比较。两个对象变量可以使用Equals方法来加以比较。Equals会判断两个变量是否指向相同的实例。</p>
<h2 id="（7）-define-和const的区别（编译阶段、安全性、内存占用等）"><a href="#（7）-define-和const的区别（编译阶段、安全性、内存占用等）" class="headerlink" title="（7） define 和const的区别（编译阶段、安全性、内存占用等）"></a>（7） define 和const的区别（编译阶段、安全性、内存占用等）</h2><h3 id="1-编译器处理方式不同。"><a href="#1-编译器处理方式不同。" class="headerlink" title="(1) 编译器处理方式不同。"></a>(1) 编译器处理方式不同。</h3><p>define宏是在预处理阶段展开，生命周期止于编译期。只是一个常数、一个命令中的参数，没有实际的存在。#define常量存在于程序的代码段。const常量是编译运行阶段使用，const常量存在于程序的数据段.</p>
<h3 id="2-类型和安全检查不同。"><a href="#2-类型和安全检查不同。" class="headerlink" title="(2)类型和安全检查不同。"></a>(2)类型和安全检查不同。</h3><p>define宏没有类型，不做任何类型检查，仅仅是展开。const常量有具体的类型，在编译阶段会执行类型检查。</p>
<h3 id="3-存储方式不同。"><a href="#3-存储方式不同。" class="headerlink" title="(3)存储方式不同。"></a>(3)存储方式不同。</h3><p>define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。const常量会在内存中分配(可以是堆中也可以是栈中)</p>
<h2 id="（8）-在C-中const和static的用法（定义，用途）"><a href="#（8）-在C-中const和static的用法（定义，用途）" class="headerlink" title="（8） 在C++中const和static的用法（定义，用途）"></a>（8） 在C++中const和static的用法（定义，用途）</h2><h3 id="static关键字至少有下列n个作用："><a href="#static关键字至少有下列n个作用：" class="headerlink" title="static关键字至少有下列n个作用："></a>static关键字至少有下列n个作用：</h3><h4 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h4><p>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；</p>
<h4 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）</h4><p>在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；</p>
<h4 id="（3）"><a href="#（3）" class="headerlink" title="（3）"></a>（3）</h4><p>在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；</p>
<h4 id="（4）"><a href="#（4）" class="headerlink" title="（4）"></a>（4）</h4><p>在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；</p>
<h4 id="（5）"><a href="#（5）" class="headerlink" title="（5）"></a>（5）</h4><p>在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。</p>
<h3 id="const关键字至少有下列n个作用："><a href="#const关键字至少有下列n个作用：" class="headerlink" title="const关键字至少有下列n个作用："></a>const关键字至少有下列n个作用：</h3><h4 id="（1）-1"><a href="#（1）-1" class="headerlink" title="（1）"></a>（1）</h4><p>欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；</p>
<h4 id="（2）-1"><a href="#（2）-1" class="headerlink" title="（2）"></a>（2）</h4><p>对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；</p>
<h4 id="（3）-1"><a href="#（3）-1" class="headerlink" title="（3）"></a>（3）</h4><p>在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</p>
<h4 id="（4）-1"><a href="#（4）-1" class="headerlink" title="（4）"></a>（4）</h4><p>对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；</p>
<h4 id="（5）-1"><a href="#（5）-1" class="headerlink" title="（5）"></a>（5）</h4><p>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：<br>const classA operator*(const classA&amp; a1,const classA&amp; a2);<br>　　operator*的返回结果必须是一个const对象。如果不是，这样的变态代码也不会编译出错：</p>
<p>classA a, b, c;<br>(a * b) &#x3D; c; &#x2F;&#x2F; 对a*b的结果赋值<br>　　操作(a * b) &#x3D; c显然不符合编程者的初衷，也没有任何意义。</p>
<h2 id="（9）-const和static在类中使用的注意事项（定义、初始化和使用）"><a href="#（9）-const和static在类中使用的注意事项（定义、初始化和使用）" class="headerlink" title="（9） const和static在类中使用的注意事项（定义、初始化和使用）"></a>（9） const和static在类中使用的注意事项（定义、初始化和使用）</h2><h2 id="（10）-C-中的const类成员函数（用法和意义）"><a href="#（10）-C-中的const类成员函数（用法和意义）" class="headerlink" title="（10） C++中的const类成员函数（用法和意义）"></a>（10） C++中的const类成员函数（用法和意义）</h2><p>常量成员函数声明：如：int get() const;</p>
<h3 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h3><p>1.常量成员函数不修改对象。<br>2.常量成员函数在定义和声明中都应加const限定<br>3.非常量成员函数不能被常量成员函数调用，但构造函数和析构函数除外。<br>4.常量（const对象）对象只能调用常量成员函数。（const对象的数据成员在对象寿命周期内不能改变，因此其只能调用常量成员函数）。</p>
<h3 id="意义："><a href="#意义：" class="headerlink" title="意义："></a>意义：</h3><p>1.使成员函数的意义更加清楚，将成员函数分修改对象和不修改对象两类。<br>2.增加程序的健壮性，常量成员函数企图修改数据成员或调用非常量成员函数，编译器会指出错误。</p>
<h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>对于X类型的非常量成员函数而言，其this指针的类型是 X * const，该指针自身是常量；但是对于X类型的常量成员函数而言，其this指针的类型是const X * const，是一个常量指针。</p>
<h2 id="（11）-计算下面几个类的大小："><a href="#（11）-计算下面几个类的大小：" class="headerlink" title="（11） 计算下面几个类的大小："></a>（11） 计算下面几个类的大小：</h2><pre><code>class A &#123;&#125;;: sizeof(A) = 1;
class A &#123; virtual Fun()&#123;&#125; &#125;;: sizeof(A) = 4(32位机器)/8(64位机器);
class A &#123; static int a; &#125;;: sizeof(A) = 1;
class A &#123; int a; &#125;;: sizeof(A) = 4;
class A &#123; static int a; int b; &#125;;: sizeof(A) = 4;
</code></pre>
<p>（12） 给一个代码，求输出结果</p>
<pre><code>class A
&#123;
public:
A(int x)&#123;&#125;
&#125;
</code></pre>
<p>问：A a &#x3D; 1;是否正确, 如果正确, 那么它调用了哪些函数？<br>这类题目更常见的是在基类和子类有不同实现方法。（虚函数相关，栗子很多，不多说了）</p>
<h2 id="（13）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"><a href="#（13）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等" class="headerlink" title="（13） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"></a>（13） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</h2><h2 id="（14）-STL源码中的hash表的实现"><a href="#（14）-STL源码中的hash表的实现" class="headerlink" title="（14） STL源码中的hash表的实现"></a>（14） STL源码中的hash表的实现</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/c602273091/article/details/54798805">https://blog.csdn.net/c602273091/article/details/54798805</a><br>哈希表（Hash table，也叫散列表）， 是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>哈希表hash table(key，value) 的做法其实很简单，就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。</p>
<p>而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。</p>
<p>哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。 哈希表又叫做散列表，分为“开散列” 和“闭散列”。</p>
<p>我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一 个元素“分类”，然后将这个元素存储在相应“类”所对应的地方。</p>
<p>但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。后面我们将看到一种解决“冲突”的简便做法。 总的来说，“直接定址”与“解决冲突”是哈希表的两大特点。</p>
<p>哈希函数构造<br>就是映射函数构造，看某个元素具体属于哪一个类别。<br>除余法： 选择一个适当的正整数 p ，令 h(k ) &#x3D; k mod p ，这里， p 如果选取的是比较大的素数，效果比较好。而且此法非常容易实现，因此是最常用的方法。最直观的一种，上图使用的就是这种散列法，公式：<br>index &#x3D; value % 16<br>学过汇编的都知道，求模数其实是通过一个除法运算得到的，所以叫“除法散列法”。</p>
<p>平方散列法<br>求index是非常频繁的操作，而乘法的运算要比除法来得省时（对现在的CPU来说，估计我们感觉不出来），所以我们考虑把除法换成乘法和一个位移操作。公式：<br>index &#x3D; (value * value) &gt;&gt; 28 （ 右移，除以2^28。记法：左移变大，是乘。右移变小，是除）</p>
<p>数字选择法： 如果关键字的位数比较多，超过长整型范围而无法直接运算，可以选择其中数字分布比较均匀的若干位，所组成的新的值作为关键字或者直接作为函数值。</p>
<p>斐波那契（Fibonacci）散列法：平方散列法的缺点是显而易见的，所以我们能不能找出一个理想的乘数，而不是拿value本身当作乘数呢？答案是肯定的。<br>1，对于16位整数而言，这个乘数是40503<br>2，对于32位整数而言，这个乘数是2654435769<br>3，对于64位整数而言，这个乘数是11400714819323198485<br>这几个“理想乘数”是如何得出来的呢？这跟一个法则有关，叫黄金分割法则，而描述黄金分割法则的最经典表达式无疑就是著名的斐波那契数列，即如此形式的序列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233,377, 610， 987, 1597, 2584, 4181, 6765, 10946，…。另外，斐波那契数列的值和太阳系八大行星的轨道半径的比例出奇吻合。<br>对我们常见的32位整数而言，公式：<br>index &#x3D; (value * 2654435769) &gt;&gt; 28</p>
<p>冲突处理<br>线性重新散列技术易于实现且可以较好的达到目的。令数组元素个数为 S ，则当 h(k) 已经存储了元素的时候，依次探查 (h(k)+i) mod S , i&#x3D;1,2,3…… ，直到找到空的存储单元为止（或者从头到尾扫描一圈仍未发现空单元，这就是哈希表已经满了，发生了错误。当然这是可以通过扩大数组范围避免的）。</p>
<h2 id="（15）-STL中unordered-map和map的区别"><a href="#（15）-STL中unordered-map和map的区别" class="headerlink" title="（15） STL中unordered_map和map的区别"></a>（15） STL中unordered_map和map的区别</h2><h3 id="内部实现机理"><a href="#内部实现机理" class="headerlink" title="内部实现机理"></a>内部实现机理</h3><h4 id="map："><a href="#map：" class="headerlink" title="map："></a>map：</h4><p>map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。</p>
<h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map:"></a>unordered_map:</h4><p>unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的</p>
<h3 id="优缺点以及适用处"><a href="#优缺点以及适用处" class="headerlink" title="优缺点以及适用处"></a>优缺点以及适用处</h3><h4 id="map-优点："><a href="#map-优点：" class="headerlink" title="map 优点："></a>map 优点：</h4><p>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作<br>红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</p>
<h4 id="map-缺点："><a href="#map-缺点：" class="headerlink" title="map 缺点："></a>map 缺点：</h4><p>空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红&#x2F;黑性质，使得每一个节点都占用大量的空间<br>适用处，对于那些有顺序要求的问题，用map会更高效一些</p>
<h4 id="unordered-map-优点："><a href="#unordered-map-优点：" class="headerlink" title="unordered_map 优点："></a>unordered_map 优点：</h4><p>因为内部实现了哈希表，因此其查找速度非常的快</p>
<h4 id="unordered-map-缺点："><a href="#unordered-map-缺点：" class="headerlink" title="unordered_map 缺点："></a>unordered_map 缺点：</h4><p>哈希表的建立比较耗费时间<br>适用处，对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>
<h2 id="（16）-STL中vector的实现"><a href="#（16）-STL中vector的实现" class="headerlink" title="（16） STL中vector的实现"></a>（16） STL中vector的实现</h2><h3 id="一、vector的定义"><a href="#一、vector的定义" class="headerlink" title="一、vector的定义"></a>一、vector的定义</h3><pre><code>template&lt;class _Ty,class _Ax&gt;
class vector:public _Vector_val&lt;_Ty,_Ax&gt;&#123;
public:
    /******/
protected:
    pointer _Myfirst;//pointer to beginning of array
    pointer _Mylast;//pointer to current end of sequence
    pointer _Myend;//pointer to end of array
&#125;;
</code></pre>
<p>示意图如下：<br><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fv5pefakcgj30as088my3.jpg" alt="image"></p>
<p>两个关键大小：<br>大小：size&#x3D;_Mylast - _Myfirst；<br>容量：capacity&#x3D;_Myend - _Myfirst；<br>分别对应于resize()、reserve()两个函数。<br>size表示vector中已有元素的个数，容量表示vector最多可存储的元素的个数；为了降低二次分配时的成本，vector实际配置的大小可能比客户需求的更大一些，以备将来扩充，这就是容量的概念。即capacity&gt;&#x3D;size，当等于时，容器此时已满，若再要加入新的元素时，就要重新进行内存分配，整个vector的数据都要移动到新内存。二次分配成本较高，在实际操作时，应尽量预留一定空间，避免二次分配。</p>
<h3 id="二、构造与析构"><a href="#二、构造与析构" class="headerlink" title="二、构造与析构"></a>二、构造与析构</h3><h3 id="1、构造"><a href="#1、构造" class="headerlink" title="1、构造"></a>1、构造</h3><p>vector的构造函数主要有以下几种：</p>
<pre><code>vector(): _Mybase()&#123;
    //construct empty vector
    _Buy(0);
&#125;
explicit vector(size_type _Count): _Mybase()&#123;
    //construct from _Count * _Ty()
    _Construct_n(_Count, _Ty());
&#125;
vector(size_type _Count,const _Ty&amp; _Val): _Mybase()&#123;
    //construct from _Count * _Val
    _Construct_n(_Count,_Val);
&#125;
vector(const _Myt&amp; _Right) : _Mybase(_Right._Alval)&#123;
    //construct by copying _Right
    if(_Buy(_Right.size()))
        _Mylast=_Ucopy(_Right.begin(),_Right.end(),_Myfirst);
&#125;
</code></pre>
<p>vector优异性能的秘诀之一，就是配置比其所容纳的元素所需更多的内存，一般在使用vector之前，就先预留足够空间，以避免二次分配，这样可以使vector的性能达到最佳。因此元素个数_Count是个远比元素值 _Val重要的参数，因此当构造一个vector时，首要参数一定是元素个数。<br>由上各构造函数可知，基本上所有构造函数都是基于_Construct _n() 的</p>
<pre><code>bool _Buy(size_type _Capacity)&#123;
    //allocate array with _Capacity elements
    _Myfirst=0,_Mylast=0,_Myend=0;
    if(_Capacity==0)// _Count为0时直接返回
        return (false);
    else&#123;
        //nonempty array,allocate storage
        _Myfirst=this-&gt;_Alval.allocate(_Capacity);//分配内存，并更新成员变量
        _Mylast=_Myfirst;
        _Myend=_Myfirst+_Capacity;
    &#125;
    return (true);
&#125;
void _Construct_n(size_type _Count,const _Ty&amp; _Val)&#123;
    //构造含有_Count个值为_Val的元素的容器
    if(_Buy(_Count))
        _Mylast= _Ufill(_Myfirst,_Count,_Val);
&#125;
</code></pre>
<h3 id="2、析构"><a href="#2、析构" class="headerlink" title="2、析构"></a>2、析构</h3><p>vector的析构函数很简单，就是先销毁所有已存在的元素，然后释放所有内存</p>
<pre><code>void _Tidy()
    &#123;   // free all storage
    if (_Myfirst != 0)
        &#123;   // something to free, destroy and deallocate it
        _Destroy(_Myfirst, _Mylast);
        this-&gt;_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
        &#125;
    _Myfirst = 0, _Mylast = 0, _Myend = 0;
    &#125;
</code></pre>
<h3 id="三、插入和删除元素"><a href="#三、插入和删除元素" class="headerlink" title="三、插入和删除元素"></a>三、插入和删除元素</h3><p>vector的插入和删除元素是通过push_ back () 、 pop_back()两个接口来实现的，他们的内部实现也非常简单</p>
<pre><code>void push_back(const _Ty&amp; _Val)
    &#123;   // insert element at end
    if (size() &lt; capacity())
        _Mylast = _Ufill(_Mylast, 1, _Val);
    else
        insert(end(), _Val);    //空间不足时，就会触发内存的二次分配
    &#125;

void pop_back()
    &#123;   // erase element at end
    if (!empty())
        &#123;   // erase last element
        _Destroy(_Mylast - 1, _Mylast);
        --_Mylast;
        &#125;
    &#125;
</code></pre>
<p>当没有备用空间时候，push_back将调用insert进行扩容。将内存扩充原来2倍，然后将原数据复制过来，然后释放掉原数据，最后调整三个迭代器的数值_Myfirst,_Mylast,_Myend。所以扩容之后，指向原vector的迭代器会失效，必须重新调用成员函数获取才可以，所以使用迭代器最好时时刻刻重新获取，否则可能引发错误。</p>
<pre><code>template &lt;class T, class Alloc&gt;
void vector&lt;T, Alloc&gt;::insert(iterator position, const T&amp; x) &#123;
  if (_Mylast != _Myend) &#123;//还有备用空间
    construct(_Mylast, *(_Mylast - 1));//
    ++_Mylast;
    T x_copy = x;
    copy_backward(position, _Mylast - 2, _Mylast - 1);
    *position = x_copy;//调整迭代器指向
  &#125;
  else &#123;//没有备用空间
    const size_type old_size = size();
    const size_type len = old_size != 0 ? 2 * old_size : 1;
    /*
        如果原大小为0，则为1，否则扩大为2倍。    
    */
    iterator new_start = data_allocator::allocate(len);//分配,并返回首部迭代器
    iterator new_finish = new_start;
    __STL_TRY &#123;
      new_finish = uninitialized_copy(_Myfirst, position, new_start);//将原来数据拷贝到new_start，并返回尾部迭代器
      construct(new_finish, x);//在尾部构造新元素
      ++new_finish;//新的尾部加1

      new_finish = uninitialized_copy(position, _Mylast, new_finish);//这句话没有任何用。
    &#125;
    destroy(begin(), end());//析构
    deallocate();//释放原来vector内存空间

    //迭代器调整
    _Myfirst = new_start;
    _Mylast = new_finish;
    _Myend = new_start + len;
  &#125;
&#125;
</code></pre>
<h3 id="四、其他接口"><a href="#四、其他接口" class="headerlink" title="四、其他接口"></a>四、其他接口</h3><h3 id="1、reserve-操作"><a href="#1、reserve-操作" class="headerlink" title="1、reserve()操作"></a>1、reserve()操作</h3><p>之前提到过reserve（Count） 函数主要是预留Count大小的空间，对应的是容器的容量，目的是保证（_Myend - _Myfirst）&gt;&#x3D;Count。只有当空间不足时，才会操作，即重新分配一块内存，将原有元素拷贝到新内存，并销毁原有内存</p>
<pre><code>void reserve(size_type _Count)
    &#123;   // determine new minimum length of allocated storage
    if (capacity() &lt; _Count)
        &#123;   // not enough room, reallocate
        pointer _Ptr = this-&gt;_Alval.allocate(_Count);
        _Umove(begin(), end(), _Ptr);
        size_type _Size = size();
        if (_Myfirst != 0)
            &#123;   // destroy and deallocate old array
            _Destroy(_Myfirst, _Mylast);
            this-&gt;_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
            &#125;
        _Myend = _Ptr + _Count;
        _Mylast = _Ptr + _Size;
        _Myfirst = _Ptr;
        &#125;
    &#125;
</code></pre>
<h3 id="2、resize-操作"><a href="#2、resize-操作" class="headerlink" title="2、resize()操作"></a>2、resize()操作</h3><p>resize（Count） 函数主要是用于改变size的，也就是改变vector的大小，最终改变的是（_Mylast - _Myfirst）的值，当size &lt; Count时,就插入元素，当size &gt;Count时，就擦除元素。</p>
<pre><code>void resize(size_type _Newsize, _Ty _Val)
    &#123;   // determine new length, padding with _Val elements as needed
    if (size() &lt; _Newsize)
        _Insert_n(end(), _Newsize - size(), _Val);
    else if (_Newsize &lt; size())
        erase(begin() + _Newsize, end());
    &#125;
</code></pre>
<h3 id="3、-Insert-n-操作"><a href="#3、-Insert-n-操作" class="headerlink" title="3、_Insert_n()操作"></a>3、_Insert_n()操作</h3><p>resize()操作和insert()操作都会利用到_Insert_n()这个函数，这个函数非常重要，也比其他函数稍微复杂一点<br>虽然_Insert_n(_where, _Count, _Val ) 函数比较长，但是操作都非常简单，主要可以分为以下几种情况：</p>
<p>1、_Count &#x3D;&#x3D; 0，不需要插入，直接返回</p>
<p>2、max_size() - size() &lt; _Count，超过系统设置的最大容量，会溢出，造成Xlen（）异常</p>
<p>3、_Capacity &lt; size() + _Count，vector的容量不足以插入Count个元素，需要进行二次分配，扩大vector的容量。 在VS下，vector容量会扩大50%，即 _Capacity &#x3D; _Capacity + _Capacity &#x2F; 2;<br>若仍不足，则 _Capacity &#x3D; size() + _Count;</p>
<pre><code> else if (_Capacity &lt; size() + _Count)
        &#123;   // not enough room, reallocate
        _Capacity = max_size() - _Capacity / 2 &lt; _Capacity
            ? 0 : _Capacity + _Capacity / 2;    // try to grow by 50%
        if (_Capacity &lt; size() + _Count)
            _Capacity = size() + _Count;
        pointer _Newvec = this-&gt;_Alval.allocate(_Capacity);
        pointer _Ptr = _Newvec;
        _Ptr = _Umove(_Myfirst, _VEC_ITER_BASE(_Where),_Newvec);    // copy prefix
        _Ptr = _Ufill(_Ptr, _Count, _Val);  // add new stuff
        _Umove(_VEC_ITER_BASE(_Where), _Mylast, _Ptr);  // copy suffix
        //内存释放与变量更新
        &#125;
</code></pre>
<p>这种情况下，数据从原始容器移动到新分配内存时是从前到后移动的<br>这里写图片描述<br><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fv5tyr1p07j30h20by41b.jpg" alt="image"><br>4、空间足够，且被插入元素的位置比较靠近_Mylast,即已有元素的尾部</p>
<p>这种情况下不需要再次进行内存分配，且数据是从后往前操作的。首先是将where~last向后移动，为待插入数据预留Count大小的空间，然后从_Mylast处开始填充，然后将从where处开始填充剩余元素</p>
<pre><code>else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) &lt; _Count)
        &#123;   // new stuff spills off end
        _Umove(_VEC_ITER_BASE(_Where), _Mylast,
            _VEC_ITER_BASE(_Where) + _Count);   // copy suffix
        _Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
            _Val);  // insert new stuff off end
        _Mylast += _Count;
        std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
            _Val);  // insert up to old end
        &#125;
</code></pre>
<p>5、空间足够，但插入的位置比较靠前<br>            {   &#x2F;&#x2F; new stuff can all be assigned<br>            _Ty _Tmp &#x3D; _Val;    &#x2F;&#x2F; in case _Val is in sequence</p>
<pre><code>        pointer _Oldend = _Mylast;
        _Mylast = _Umove(_Oldend - _Count, _Oldend,
            _Mylast);   // copy suffix
        _STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
            _Oldend);   // copy hole
        std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
            _Tmp);  // insert into hole
        &#125;
</code></pre>
<h3 id="4、erase-操作"><a href="#4、erase-操作" class="headerlink" title="4、erase()操作"></a>4、erase()操作</h3><pre><code>iterator erase(const_iterator _First_arg,
    const_iterator _Last_arg)
    &#123;   // erase [_First, _Last)
    iterator _First = _Make_iter(_First_arg);
    iterator _Last = _Make_iter(_Last_arg);

    if (_First != _Last)
        &#123;   // worth doing, copy down over hole
        pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
            _VEC_ITER_BASE(_First));

        _Destroy(_Ptr, _Mylast);
        _Mylast = _Ptr;
        &#125;
    return (_First);
    &#125;
</code></pre>
<p>主要操作就是将后半部分的有效元素向前拷贝，并将后面空间的无效元素析构，并更新_Mylast变量<br>这里写图片描述<br><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fv5ua8ciphj30i90ahgns.jpg" alt="image"></p>
<h3 id="5、assign-操作"><a href="#5、assign-操作" class="headerlink" title="5、assign()操作"></a>5、assign()操作</h3><p>assign()操作最终都会调用到下面的函数，主要操作是首先擦除容器中已有的全部元素，在从头开始插入Count个Val元素</p>
<pre><code>void _Assign_n(size_type _Count, const _Ty&amp; _Val)
    &#123;   // assign _Count * _Val
    _Ty _Tmp = _Val;    // in case _Val is in sequence
    erase(begin(), end());
    insert(begin(), _Count, _Tmp);
    &#125;
</code></pre>
<h2 id="（17）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。"><a href="#（17）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。" class="headerlink" title="（17） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。"></a>（17） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</h2><p>vector使用注意事项：</p>
<p>（1）max_size函数返回的是vector中的内存分配器allocator能够分配的最大内存空间，即vector所能管控的最大序列长度，注意和capacity的区别。</p>
<p>（2）resize重新调整大小，既可以减小也可以增加size（数组的有效长度），但是内存并不一定减小。</p>
<p>（3）insert是在所指的元素之前进行插入，erase返回的迭代器指向被最后删除的元素的下一个元素。</p>
<p>（4）注意插入和删除元素后迭代器失效的问题。</p>
<p>（5）当预先知道所需的存储空间时，可以使用reserve预先分配内存。</p>
<p>（6）vector对象作为一个高效的栈使用时，应该让容器保持一定的预留存储空间，频繁的重新分配内存会影响栈的性能，可以使用reserve预分配内存，使用push_back、pop_back和back插入、删除和读取最后一个元素。</p>
<p>（7）clear只是保证了析构所有的元素，即size()&#x3D;0，但并不保证释放所有的存储空间，即capacity不一定等于0，可以使用如下方式释放所有内存：</p>
<pre><code>       vec.swap(vector&lt;T&gt;());
</code></pre>
<p>在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。</p>
<p>如果在程序中频繁进行这种操作，还是比较消耗性能的。</p>
<h2 id="（18）-C-中的重载和重写的区别："><a href="#（18）-C-中的重载和重写的区别：" class="headerlink" title="（18） C++中的重载和重写的区别："></a>（18） C++中的重载和重写的区别：</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zx3517288/article/details/48976097">https://blog.csdn.net/zx3517288/article/details/48976097</a><br>重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</p>
<p>示例：</p>
<pre><code>class A&#123;
public:
  void test(int i);
  void test(double i);//overload
  void test(int i, double j);//overload
  void test(double i, int j);//overload
  int test(int i);         //错误，非重载。注意重载不关心函数返回类型。
&#125;;
</code></pre>
<p>重写(覆盖)：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。</p>
<p>示例：</p>
<pre><code>#include&lt;iostream&gt;

using namespace std;

class Base
&#123;
public:
    virtual void fun(int i)&#123; cout &lt;&lt; &quot;Base::fun(int) : &quot; &lt;&lt; i &lt;&lt; endl;&#125;
&#125;;

class Derived : public Base
&#123;
public:
    virtual void fun(int i)&#123; cout &lt;&lt; &quot;Derived::fun(int) : &quot; &lt;&lt; i &lt;&lt; endl;&#125;
&#125;;
int main()
&#123;
    Base b;
    Base * pb = new Derived();
    pb-&gt;fun(3);//Derived::fun(int)

    system(&quot;pause&quot;);
    return 0;
</code></pre>
<p>重载和重写的区别：</p>
<p>（1）范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。</p>
<p>（2）参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。</p>
<p>（3）virtual的区别：重写的基类必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。</p>
<p>隐藏和重写，重载的区别：</p>
<p>（1）与重载范围不同：隐藏函数和被隐藏函数在不同类中。</p>
<p>（2）参数的区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。<br>示例</p>
<h2 id="（19）-C-内存管理（热门问题）"><a href="#（19）-C-内存管理（热门问题）" class="headerlink" title="（19） C ++内存管理（热门问题）"></a>（19） C ++内存管理（热门问题）</h2><p>内存分配方式<br>（1）从静态存储区域分配。内存在程序编译的时候就已经分配好了（已经编址）这些内存在程序的整个运行期间都存在，如全局变量，static变量<br>（2）在堆栈上分配。在函数执行期间，函数内局部变量（包括形参）的存储单元都创建在堆栈上，函数结束时这些存储单元都会自动释放（堆栈清退）。堆栈内存分配运算内置于处理器的指令集中，效率很高，并且一般不存在失败的危险，但是分配的内存容量有限，可能出现堆栈溢出。<br>（3）从堆或者自由存储空间上分配，亦称动态内存分配。程序在运行期间用malloc()或new申请任意数量的内存，程序猿自己掌握释放内存的恰当时机（使用free()或delete)动态内存的生存期由程序猿决定，使用非常灵活，但也最容易产生问题。<br>一般的原则是：如果使用堆栈存储和静态存储就能满足应用要求，就不要使用动态存储。因为在堆栈上动态分配内存需要很可观的额外开销：<br>应用程序将调用操作系统中内存管理模块的堆管理器，搜索其中是否有符合要求的连续字节内存块。特别是在经过多次动态分配后，对会出现大量的闲散内存碎片，此时需要首先将碎片合并，然后才能分配成功，在这种情况下动态分配需要很长时间<br>如果动态分配失败，需要检查返回值或者捕获异常，这也需要额外开销。<br>动态创建的对象可能被删除多次，甚至在删除后还会继续使用，或者根本就不会被删除，于是出现运行时错误或程序“吃”内存的对象<br>常见的内存错误及其对策<br>内存分配未成功，却使用了它<br>内存分配成功，但是尚未初始化就使用它<br>内存分配成功并且已经初始化，但操作越过了内存的边界<br>忘记了释放内存或者只释放了部分内存，因此造成内存泄漏。（含有这种错误的函数每调用一次就丢失一块内存）比如无意中修改了指向动态数组的指针，致使释放出错，或者使用了错误的动态数组释放语法。<br>（5）释放了内存却还在继续使用它。<br>程序中的对象调用关系过于复杂，实在难以搞清楚某个对象（重新设计数据结构，从根本上解决对象管理的混乱局面）<br>函数的return语句写错了，注意不要返回指向“栈内存”的指针或者引用，因为该内存在函数结束时被自动释放<br>使用free（）或delete释放了内存后，没有将指针设置为NULL，产生野指针<br>多次释放同一块内存<br>用malloc或new申请内存之后，应该立即检查指针值是否为NULL或者进行异常处理，以防止使用值为NULL的指针<br>不要忘记初始化指针，数组和动态内存，防止将未初始化的内存作为右值使用<br>避免数组或指针的下标越界，特别要当心的是++或者–操作<br>用free或者delete释放了内存之后，立即将指针设置为NULL，防止产生野指针</p>
<h3 id="1-一般一个c-x2F-c-程序编译的时候内存布局如下-地址从低到高的顺序"><a href="#1-一般一个c-x2F-c-程序编译的时候内存布局如下-地址从低到高的顺序" class="headerlink" title="(1)一般一个c&#x2F;c++程序编译的时候内存布局如下(地址从低到高的顺序)"></a>(1)一般一个c&#x2F;c++程序编译的时候内存布局如下(地址从低到高的顺序)</h3><h4 id="a-代码区"><a href="#a-代码区" class="headerlink" title="a.代码区:"></a>a.代码区:</h4><p>存放程序的二进制代码.</p>
<h4 id="b-常量区"><a href="#b-常量区" class="headerlink" title="b.常量区:"></a>b.常量区:</h4><p>这个区和代码区的距离很近,主要存放一些非局部常量值和字符串字面值,一般不允许修改,程序结束由系统释放;具有常属性并且初始化的全局和静态变量也放在这个区.</p>
<h4 id="c-数据区"><a href="#c-数据区" class="headerlink" title="c.数据区:"></a>c.数据区:</h4><p>赋过初值的且不具有常属性的静态和全局变量在数据区.它和BSS段统称为静态区;程序结束后由系统释放;</p>
<h4 id="d-BSS段"><a href="#d-BSS段" class="headerlink" title="d.BSS段:"></a>d.BSS段:</h4><p>没有初始化的静态和全局变量;进程一旦被加载这个区所有的数据都被清0;</p>
<h4 id="e-堆区"><a href="#e-堆区" class="headerlink" title="e.堆区:"></a>e.堆区:</h4><p>   动态分配的内存;由程序员分配和释放,程序结束的时候如果没有释放,则由OS回收;</p>
<h4 id="f-栈区"><a href="#f-栈区" class="headerlink" title="f.栈区:"></a>f.栈区:</h4><p>   由编译器自动分配和释放,不使用的时候会自动的释放.主要用来存放非静态的局部变量,函数的参数和返回值, 临时变量等.</p>
<h4 id="g-命令行参数和环境变量区"><a href="#g-命令行参数和环境变量区" class="headerlink" title="g.命令行参数和环境变量区;"></a>g.命令行参数和环境变量区;</h4><p>下面是对应一段经典的代码:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;  //unix下的头文件
const int const_global = 10; //常全局变量
int init_global = 10;        //初始化的全局变量
int uninit_global;           //未初始化的全局变量

int main(int argc,char * argv[])
&#123;
    const static int const_static = 10;//常属性的静态变量，不可以被赋值，初始化
    static int init_static = 10;    //初始化静态变量
    static int uninit_static;       //未初始化静态变量
    const int const_local = 10;    // 常属性的局部变量
    int  prev_local = 1;//前局部变量
    int  next_local = 5;//后局部变量
    int* prev_heap = malloc(sizeof(int));//前面分配的堆变量
    int* next_heap = malloc(sizeof(int));//后面分配的堆变量
    const char* literal = &quot;literal&quot;;      //字符串字面值，字面值常量
    extern char** environ;               // 环境变量

    printf(&quot;----地址最高断命令行参数和环境变量-------\n&quot;);
    printf(&quot;        环境变量:%p\n&quot;,environ);
    printf(&quot;      命令行参数:%p\n&quot;,argv);
    printf(&quot;---------------栈区-----------------------\n&quot;);
    printf(&quot;      常局部变量:%p\n&quot;,&amp;const_local);
    printf(&quot;      前局部变量:%p\n&quot;,&amp;prev_local);
    printf(&quot;      后局部变量:%p\n&quot;,&amp;next_local);
    printf(&quot;--------------------堆--------------------\n&quot;);
    printf(&quot;        前堆变量:%p\n&quot;,prev_heap);
    printf(&quot;        后堆变量:%p\n&quot;,next_heap);
    printf(&quot;--------------------BSS--------------------\n&quot;);
    printf(&quot;未初始化全局变量:%p\n&quot;,&amp;uninit_global);
    printf(&quot;未初始化静态变量:%p\n&quot;,&amp;uninit_static);
    printf(&quot;----------------数据------------------------\n&quot;);
    printf(&quot;  初始化全局变量:%p\n&quot;,&amp;init_static);
    printf(&quot;  初始化全局变量:%p\n&quot;,&amp;init_global);
    printf(&quot;----------------代码区----------------------\n&quot;);
    printf(&quot;     常静态变量:%p\n&quot;,&amp;const_static);
    printf(&quot;     字面值常量:%p\n&quot;,&amp;literal);
    printf(&quot;     常全局变量:%p\n&quot;,&amp;const_global);
    printf(&quot;           函数:%p\n&quot;,main);
    return 0;
&#125;
</code></pre>
<h3 id="2-从上面可以看出c-x2F-c-的内存分配方式主要有三种"><a href="#2-从上面可以看出c-x2F-c-的内存分配方式主要有三种" class="headerlink" title="(2)从上面可以看出c&#x2F;c++的内存分配方式主要有三种"></a>(2)从上面可以看出c&#x2F;c++的内存分配方式主要有三种</h3><h4 id="a-从静态存储区域分配"><a href="#a-从静态存储区域分配" class="headerlink" title="a.从静态存储区域分配:"></a>a.从静态存储区域分配:</h4><p>   内存在程序编译时已经分配好,这块内存在程序的整个运行期间都存在.速度快,不容易出错.因为由系统会善后.</p>
<h4 id="b-在栈上分配内存"><a href="#b-在栈上分配内存" class="headerlink" title="b.在栈上分配内存:"></a>b.在栈上分配内存:</h4><p>   在执行函数的时候,函数内非静态局部变量的存储单元都是在栈上创建,函数执行结束的时候这些存储单元自动被释放.栈内存分配内置于处理器的指令集中,效率很高但是分配的内容有限.</p>
<h4 id="c-从堆中分配内存"><a href="#c-从堆中分配内存" class="headerlink" title="c.从堆中分配内存:"></a>c.从堆中分配内存:</h4><p>即是动态分配内存.程序在运行的时候使用malloc&#x2F;new申请任意大小的内存,程序员自己负责在何时用free&#x2F;delete释放内存.动态内存的生存期由程序员决定,使用非常的灵活.如果在堆上分配了内存,就有责任去回收它,否则运行程序会出现内存泄漏,另外频繁的分配和释放不同大小的堆空间将会产生堆内碎片.不易管理;</p>
<h2 id="（20）-介绍面向对象的三大特性，并且举例说明每一个。"><a href="#（20）-介绍面向对象的三大特性，并且举例说明每一个。" class="headerlink" title="（20） 介绍面向对象的三大特性，并且举例说明每一个。"></a>（20） 介绍面向对象的三大特性，并且举例说明每一个。</h2><h3 id="1-封装"><a href="#1-封装" class="headerlink" title="(1)封装:"></a>(1)封装:</h3><p>将客观事物封装成抽象的类,并且设计者可以对类的成员进行访问控制权限控制. 这样一方面可以做到数据的隐藏,保护数据安全;另一方面,封装可以修改类的内部实现而不用修改调用了该类的用户的代码.同时封装还有利于代码的 方便复用；</p>
<h3 id="2-继承"><a href="#2-继承" class="headerlink" title="(2)继承:"></a>(2)继承:</h3><h4 id="a-2"><a href="#a-2" class="headerlink" title="a."></a>a.</h4><p>继承具有这样一种功能,它可以使用现有类的所有功能；并且可以在不重新编写原有类的情况下对类的功能进行扩展.继承的过程是一般到特殊的过程,即是它们是is-a的关系;基类或父类是一般,而子类或派生类是基类的特殊表现;要实现继承可以通过继承和组合来实现;</p>
<h4 id="b-3"><a href="#b-3" class="headerlink" title="b."></a>b.</h4><p>广义上的继承分成三大类:实现继承:使用基类的属性和方法而无需额外编码的能力;接口继承:接口继承是指仅使用基类的属性和方法的名称,而具体的实现子类必须自己完成的能力;可视继承:子窗体(类)使用父窗体(类)的外观和实现代码的能力;</p>
<h3 id="3-多态"><a href="#3-多态" class="headerlink" title="(3)多态:"></a>(3)多态:</h3><h4 id="a-3"><a href="#a-3" class="headerlink" title="a."></a>a.</h4><p>多态的实现分成两种,一种是编译时的多态,主要是通过函数重载和运算符重</p>
<p>另外一种是运行时多态,主要是通过函数覆盖来实现的,它需要满足3个条件:基类函数必须是虚函数,并且基类的指针或引用指向子类的时候,当子类中对原有的虚函数进行重新定义之后形成一个更加严格的重载版本的时候,就会形成多态;它是通过动态联编实现的;</p>
<h4 id="b-4"><a href="#b-4" class="headerlink" title="b."></a>b.</h4><p>运行时的多态可以让基类的指针或引用指向不同的对象的时候表现出来不同的特性;</p>
<h2 id="（21）-多态的实现（和下个问题一起回答）"><a href="#（21）-多态的实现（和下个问题一起回答）" class="headerlink" title="（21） 多态的实现（和下个问题一起回答）"></a>（21） 多态的实现（和下个问题一起回答）</h2><p> 首先，什么是多态，什么又是虚函数呢？先来看看维基百科对多态的解释：</p>
<p>“多态（英语：polymorphism），是指计算机程序运行时，相同的消息可能会送给多个不同的类别之对象，而系统可依据对象所属类别，引发对应类别的方法，而有不同的行为。简单来说，所谓多态意指相同的消息给予不同的对象会引发不同的动作称之。”其实更简单地来说，就是“在用父类指针调用函数时，实际调用的是指针指向的实际类型（子类）的成员函数”。多态性使得程序调用的函数是在运行时动态确定的，而不是在编译时静态确定的。而虚函数则是加了virtual修饰词的类的成员函数。</p>
<h3 id="c-的多态性就是通过晚绑定技术来实现的。"><a href="#c-的多态性就是通过晚绑定技术来实现的。" class="headerlink" title="c++的多态性就是通过晚绑定技术来实现的。"></a>c++的多态性就是通过晚绑定技术来实现的。</h3><p>　　c++的多态性用一句话概括就是:在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</p>
<h2 id="（22）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"><a href="#（22）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）" class="headerlink" title="（22） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"></a>（22） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</h2><p>每一个拥有virtual function的类实例化对象时，都会额外申请一块内存存储虚函数表存储所有虚函数地址，并在对象某个位置存储一个vptr指针指向该表起始地址。这个指针具体放在什么位置，虚函数表怎么组织，怎么索引各个虚函数，这些都是编译器在编译期间决定的，在不同编译环境下不见得相同。</p>
<p>虚函数在c++中的实现机制就是用虚表和虚指针，但是具体是怎样的呢？从more effecive c++其中一篇文章里面可以知道：是每个类用了一个虚表，每个类的对象用了一个虚指针。</p>
<pre><code>class A
&#123;
public:
    virtual void f();
    virtual void g();
private:
    int a
&#125;;

class B : public A
&#123;
public:
    void g();
private:
    int b;
&#125;;

//A，B的实现省略
</code></pre>
<p>因为A有virtual void f（），和g（），所以编译器为A类准备了一个虚表vtableA，内容如下：</p>
<pre><code>A::f 的地址
A::g 的地址
</code></pre>
<p>B因为继承了A，所以编译器也为B准备了一个虚表vtableB，内容如下：</p>
<pre><code>A::f 的地址
B::g 的地址
</code></pre>
<p>注意：因为B::ｇ是重写了的，所以B的虚表的g放的是B::g的入口地址，但是f是从上面的A继承下来的，所以f的地址是A::f的入口地址。</p>
<p>然后某处有语句 B bB;的时候，编译器分配空间时，除了A的int a，B的成员int b；以外，还分配了一个虚指针vptr，指向B的虚表vtableB，bB的布局如下：</p>
<pre><code>vptr ： 指向B的虚表vtableB
int a： 继承A的成员
int b： B成员
</code></pre>
<p>当如下语句的时候：</p>
<pre><code>A *pa = &amp;bB;
</code></pre>
<p>pa的结构就是A的布局（就是说用pa只能访问的到bB对象的前两项，访问不到第三项int b）</p>
<p>那么pa-&gt;g()中，编译器知道的是，g是一个声明为virtual的成员函数，而且其入口地址放在表格（无论是vtalbeA表还是vtalbeB表）的第2项，那么编译器编译这条语句的时候就如是转换：</p>
<pre><code>call *(pa-&gt;vptr)[1]（C语言的数组索引从0开始）。
</code></pre>
<p>这一项放的是B：：g()的入口地址，则就实现了多态。（注意bB的vptr指向的是B的虚表vtableB）</p>
<p>另外要注意的是，如上的实现并不是唯一的，C++标准只要求用这种机制实现多态，至于虚指针vptr到底放在一个对象布局的哪里，标准没有要求，每个编译器自己决定。以上的结果是根据g++ 4.3.4经过反汇编分析出来的。</p>
<h2 id="（23）-实现编译器处理虚函数表应该如何处理"><a href="#（23）-实现编译器处理虚函数表应该如何处理" class="headerlink" title="（23） 实现编译器处理虚函数表应该如何处理"></a>（23） 实现编译器处理虚函数表应该如何处理</h2><h2 id="（24）-析构函数一般写成虚函数的原因"><a href="#（24）-析构函数一般写成虚函数的原因" class="headerlink" title="（24） 析构函数一般写成虚函数的原因"></a>（24） 析构函数一般写成虚函数的原因</h2><p><strong>构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。</strong>下面我们来看看为什么。</p>
<p>那么为什么析构函数推荐最好设置为虚函数呢？当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当时是希望可以调用派生类的析构函数对新定义的成员也进行析构啦。</p>
<p>所以，析构函数推荐最好设置为虚函数是为了当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。<br>当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。</p>
<h2 id="（25）-构造函数为什么一般不定义为虚函数"><a href="#（25）-构造函数为什么一般不定义为虚函数" class="headerlink" title="（25） 构造函数为什么一般不定义为虚函数"></a>（25） 构造函数为什么一般不定义为虚函数</h2><p>首先，我们已经知道虚函数的实现则是通过对象内存中的虚函数表指针vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。那么在构造函数完成之前，vptr是没有值的，也就无法通过vptr找到作为虚函数的构造函数所在的代码区，所以构造函数只能作为普通函数存放在类所指定的代码区中。</p>
<p>子类构造时各个初始化步骤的调用顺序<br>构造顺序：</p>
<pre><code>1．构造子类构造函数的参数
2．子类调用基类构造函数
3．基类设置vptr
4．基类初始化列表内容进行构造
5.基类函数体调用
6.子类设置vptr
7.子类初始化列表内容进行构造
8.子类构造函数体调用
（注意一点，初始化列表内的数据不按书写顺序，而是按类内部的定义顺序）
析构的顺序恰好相反，所以也不要在析构函数中调用虚函数，那样也是没有意义的。
</code></pre>
<h2 id="（26）-构造函数或者析构函数中调用虚函数会怎样"><a href="#（26）-构造函数或者析构函数中调用虚函数会怎样" class="headerlink" title="（26） 构造函数或者析构函数中调用虚函数会怎样"></a>（26） 构造函数或者析构函数中调用虚函数会怎样</h2><p>对于构造函数和析构函数与虚函数的关系我们也可以从另一方面来理解。通常是如例子中base *a&#x3D;new(A)这样创建一个对象时调用构造函数，此时我们是在new函数中直接指定类名字的，当然会直接调用对应类的构造函数，不会出现基类类型实际指向子类的情况出现。而调用析构函数通常是针对对象的操作，如delete(a)，此时我们当然希望可以调用到a实际指向的类型（类A）的析构函数，故需要设置为虚函数。</p>
<pre><code>class ClxBase
&#123;
public:
    ClxBase() &#123;&#125;;
    virtual ~ClxBase() &#123;&#125;;

    virtual void DoSomething() &#123; cout &lt;&lt; &quot;Do something in class ClxBase!&quot; &lt;&lt; endl; &#125;;
&#125;;

class ClxDerived : public ClxBase
&#123;
public:
    ClxDerived() &#123;&#125;;
    ~ClxDerived() &#123; cout &lt;&lt; &quot;Output from the destructor of class ClxDerived!&quot; &lt;&lt; endl; &#125;;

    void DoSomething() &#123; cout &lt;&lt; &quot;Do something in class ClxDerived!&quot; &lt;&lt; endl; &#125;;
&#125;;

ClxBase *pTest = new ClxDerived;
pTest-&gt;DoSomething();
delete pTest;
</code></pre>
<p> 输出结果是：</p>
<pre><code>Do something in class ClxDerived!
Output from the destructor of class ClxDerived!
</code></pre>
<p>而如果去掉基类中析构函数的virtual关键字输出则变成</p>
<pre><code>Do something in class ClxDerived!
Output from the destructor of class ClxDerived!
</code></pre>
<p>也就是说，类ClxDerived的析构函数根本没有被调用！一般情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。我想所有的C++程序员都知道这样的危险性。当然，如果在析构函数中做了其他工作的话，那你的所有努力也都是白费力气。</p>
<h2 id="（27）-纯虚函数"><a href="#（27）-纯虚函数" class="headerlink" title="（27） 纯虚函数"></a>（27） 纯虚函数</h2><p><strong>C++纯虚函数</strong></p>
<h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p>　纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“&#x3D;0”</p>
<pre><code>　virtual void funtion1()=0
</code></pre>
<h3 id="二、引入原因"><a href="#二、引入原因" class="headerlink" title="二、引入原因"></a>二、引入原因</h3><p>1、为了方便使用多态特性<br>我们常常需要在基类中定义虚拟函数。</p>
<p>2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</p>
<p>为了解决上述问题，引入了纯虚函数的概念，<strong>将函数定义为纯虚函数（方法：virtual ReturnType Function()&#x3D; 0;）</strong>，则编译器要求在派生类中必须予以重写以实现多态性。<strong>同时含有纯虚拟函数的类称为抽象类，它不能生成对象。</strong>这样就很好地解决了上述两个问题。<br>声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。<br>纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。<br>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</p>
<p>纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p>
<h3 id="抽象类的介绍"><a href="#抽象类的介绍" class="headerlink" title="抽象类的介绍"></a>抽象类的介绍</h3><p>抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。<br>（1）抽象类的定义：  称带有纯虚函数的类为抽象类。</p>
<p>（2）抽象类的作用：<br>抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</p>
<p>（3）使用抽象类时注意：<br>•   抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。<br>•   抽象类是不能定义对象的。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1、<strong>纯虚函数声明如下： virtual void funtion1()&#x3D;0;</strong> 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。</p>
<p>2、虚函数声明如下：virtual ReturnType FunctionName(Parameter)；虚函数必须实现，如果不实现，编译器将报错，错误提示为：<br>error LNK****: unresolved external symbol “public: virtual void __thiscall ClassName::virtualFunctionName(void)”</p>
<p>3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。</p>
<p>4、实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。</p>
<p>5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。</p>
<p>6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。</p>
<p>7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。</p>
<p>8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。</p>
<p>有纯虚函数的类是抽象类，不能生成对象，只能派生。他派生的类的纯虚函数没有被改写，那么，它的派生类还是个抽象类。<br>定义纯虚函数就是为了让基类不可实例化化<br>因为实例化这样的抽象数据结构本身并没有意义。<br>或者给出实现也没有意义</p>
<p>实际上我个人认为纯虚函数的引入，是出于两个目的<br>1、为了安全，因为避免任何需要明确但是因为不小心而导致的未知的结果，提醒子类去做应做的实现。<br>2、为了效率，不是程序执行的效率，而是为了编码的效率。</p>
<h2 id="（28）-静态绑定和动态绑定的介绍"><a href="#（28）-静态绑定和动态绑定的介绍" class="headerlink" title="（28） 静态绑定和动态绑定的介绍"></a>（28） 静态绑定和动态绑定的介绍</h2><p>静态绑定：编译时绑定，通过对象调用<br>动态绑定：运行时绑定，通过地址实现</p>
<p>只有采用“指针-&gt;函数()”或“引用变量.函数()”的方式调用C++类中的虚函数才会执行动态绑定。对于C++中的非虚函数，因为其不具备动态绑定的特征，所以不管采用什么样的方式调用，都不会执行动态绑定。<br>即所谓动态绑定，就是基类的指针或引用有可能指向不同的派生类对象，对于非虚函数，执行时实际调用该函数的对象类型即为该指针或引用的静态类型（基类类型）；而对于虚函数，执行时实际调用该函数的对象类型为该指针或引用所指对象的实际类型</p>
<h2 id="（29）-引用是否能实现动态绑定，为什么引用可以实现"><a href="#（29）-引用是否能实现动态绑定，为什么引用可以实现" class="headerlink" title="（29） 引用是否能实现动态绑定，为什么引用可以实现"></a>（29） 引用是否能实现动态绑定，为什么引用可以实现</h2><p>可以实现，因为对象的类型是确定的，在编译期就确定了<br>指针或引用是在运行期根据他们绑定的具体对象确定。<br>引用和指针的静态类型和动态类型可以不一样。</p>
<p>静态类型：变量声明时的类型或表达式生成的类型。编译时已经知道。</p>
<p>动态类型：变量或表达式表示的内存的对象的类型。</p>
<h2 id="（30）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"><a href="#（30）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）" class="headerlink" title="（30） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"></a>（30） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h2><p>深浅拷贝的区别：<br>    浅拷贝是将原始对象中的数据型字段拷贝到新对象中去，将引用型字段的“引用”复制到新对象中去，不把“引用的对象”复制进去，所以原始对象和新对象引用同一对象，新对象中的引用型字段发生变化会导致原始对象中的对应字段也发生变化。<br>    深拷贝是在引用方面不同，深拷贝就是创建一个新的和原始字段的内容相同的字段，是两个一样大的数据段，所以两者的引用是不同的，之后的新对象中的引用型字段发生改变，不会引起原始对象中的字段发生改变。<br>C++类在定义时，系统会提供一个默认的拷贝构造函数，这个函数属于迁拷贝，当使用该类定义对象时赋值，如：类 A &#x3D; B，就要用到它。一般来说系统提供的默认拷贝函数是不能满足需求的，我们一般要自己编写拷贝构造函数。而拷贝构造函数的定义方法如下：</p>
<pre><code>class 类名

&#123;

    类名(const 类名 &amp;对象名);    // 函数定义

&#125;
</code></pre>
<p>2<br>拷贝构造函数分为浅拷贝和深拷贝两种，浅拷贝和深拷贝主要区别就是复制指针时是否重新创建内存空间。</p>
<p>如果没有没有创建内存只赋值地址为浅拷贝，创建新内存把值全部拷贝一份就是深拷贝。</p>
<p>浅拷贝在类里面有指针成员的情况下只会复制指针的地址，会导致两个成员指针指向同一块内存，这样在要是分别delete释放时就会出现问题，因此需要用深拷贝。先看看下面的例子：</p>
<p>3<br>例子中建立了两个猫对象，b创建时调用拷贝构造函数拷贝了名字，然后a被delete掉，再调用b的Say()方法。如果使用默认的浅拷贝拷贝构造函数将会无法输出正确的名字，所以需要定义自己的拷贝构造函数。另外值得一提的是拷贝构造函数不是赋值运算符&#x3D;号，如果对象已经创建在用&#x3D;号复制，需要重载&#x3D;号运算符函数。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27011361/article/details/79518057">https://blog.csdn.net/qq_27011361/article/details/79518057</a></p>
<h2 id="（31）-对象复用的了解，零拷贝的了解"><a href="#（31）-对象复用的了解，零拷贝的了解" class="headerlink" title="（31） 对象复用的了解，零拷贝的了解"></a>（31） 对象复用的了解，零拷贝的了解</h2><p>对象池：对象池通过对象复用的方式来避免重复创建对象，它会事先创建一定数量的对象放到池中，当用户需要创建对象的时候，直接从对象池中获取即可，用完对象之后再放回到对象池中，以便复用。</p>
<p>适用性：类的实例可重用。类的实例化过程开销较大。类的实例化的频率较高。</p>
<p>零拷贝：emplace_back</p>
<h2 id="（32）-介绍C-所有的构造函数"><a href="#（32）-介绍C-所有的构造函数" class="headerlink" title="（32） 介绍C++所有的构造函数"></a>（32） 介绍C++所有的构造函数</h2><h3 id="一、-构造函数是干什么的"><a href="#一、-构造函数是干什么的" class="headerlink" title="一、 构造函数是干什么的"></a>一、 构造函数是干什么的</h3><pre><code>/*   类对象被创建时，编译系统对象分配内存空间，并自动调用该构造函数-&gt;由构造函数完成成员的初始化工作
     eg: Counter c1;

     编译系统为对象c1的每个数据成员(m_value)分配内存空间，并调用构造函数Counter( )自动地初始化对象，初始化之后c1的m_value值设置为0

     故：构造函数的作用：初始化对象的数据成员。*/

      class Counter
       &#123;
      public:       // 类Counter的构造函数，以类名作为函数名，无返回类型
      Counter()&#123;
      m_value = 0;
      &#125;

      private:
      int m_value;  // 类私有的数据成员
      &#125;
</code></pre>
<h3 id="二、-构造函数的种类"><a href="#二、-构造函数的种类" class="headerlink" title="二、 构造函数的种类"></a>二、 构造函数的种类</h3><pre><code>#include &lt;iostream&gt;
using namespace std;

class Complex
&#123;
private :
    double m_real;
    double m_imag;

public:

//*无参数构造函数

// 如果创建一个类你没有写任何构造函数,则系统会自动生成默认的无参构造函数，函数为空，什么都不做
// 只要你写了一个下面的某一种构造函数，系统就不会再自动生成这样一个默认的构造函数，如果希望有一个这样的无参构造函数，则需要自己显示地写出来

    Complex(void)
    &#123;   m_real = 0.0;
        m_imag = 0.0;
    &#125;

//*一般构造函数（也称重载构造函数）

//一般构造函数可以有各种参数形式,一个类可以有多个一般构造函数，前提是参数的个数或者类型不同（基于c++的重载函数原理）

//例如：你还可以写一个 Complex(int num)的构造函数出来，创建对象时根据传入的参数不同调用不同的构造函数

    Complex(double real, double imag)
    &#123;   m_real = real;
        m_imag = imag;
    &#125;

//*复制构造函数（也称为拷贝构造函数）

//复制构造函数参数为类对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象，一般在函数中会将已存在对象的数据成员的值复制一份到新创建的对象中

//若没有显示的写复制构造函数，则系统会默认创建一个复制构造函数，但当类中有指针成员时，由系统默认创建该复制构造函数会存在风险，具体原因在有关 “浅拷贝”、“深拷贝”的文章中论述

    Complex(const Complex &amp; c)
    &#123;   // 将对象c中的数据成员值复制过来
        m_real = c.m_real;
        m_imag = c.m_imag;
    &#125;

//*类型转换构造函数，根据一个指定的类型的对象创建一个本类的对象，需要注意的一点是，这个其实就是一般的构造函数，但是对于出现这种单参数的构造函数，C++会默认将参数对应的类型转换为该类类型，

//有时候这种隐私的转换是我们所不想要的，所以需要使用explicit来限制这种转换。

//例如：下面将根据一个double类型的对象创建了一个Complex对象

    Complex(double r)
    &#123;   m_real = r;
        m_imag = 0.0;
    &#125;

// 等号运算符重载（也叫赋值构造函数）

// 注意，这个类似复制构造函数，将=右边的本类对象的值复制给等号左边的对象，它不属于构造函数，等号左右两边的对象必须已经被创建。

// 若没有显示的写 =运算符重载，则系统也会创建一个默认的=运算符重载，只做一些基本的拷贝工作

    Complex &amp;operator=(const Complex &amp;rhs )

    &#123;   // 首先检测等号右边的是否就是左边的对象本身，若是本对象本身,则直接返回
        if ( this == &amp;rhs )
        &#123;   return *this;
        &#125;

        // 复制等号右边的成员到左边的对象中
        this-&gt;m_real = rhs.m_real;
        this-&gt;m_imag = rhs.m_imag;

        // 把等号左边的对象再次传出,目的是为了支持连等 eg:a=b=c 系统首先运行 b=c 然后运行 a=(b=c的返回值,这里应该是复制c值后的b对象)
        return *this;
    &#125;
&#125;;
</code></pre>
<h3 id="三、使用上面定义的类对象来说明各个构造函数的用法："><a href="#三、使用上面定义的类对象来说明各个构造函数的用法：" class="headerlink" title="三、使用上面定义的类对象来说明各个构造函数的用法："></a>三、使用上面定义的类对象来说明各个构造函数的用法：</h3><pre><code>int main()
&#123;   
    // 调用了无参构造函数，数据成员初值被赋值为0.0
    Complex c1,c2;

    // 调用一般构造函数，数据成员初值分别被赋为指定值
    Complex c3(1.0,2.5);

    // 当然，也可以使用下面的形式
    // Complex c3 = Complex(1.0,2.5);

    //  把c3的数据成员的值赋值给事先被创建的对象c1
    //  由于c1已经事先被创建，故此处不会调用任何构造函数
    //  只会调用 = 号运算符重载函数
    c1 = c3;  

    //  调用类型转换构造函数
    //  系统首先调用类型转换构造函数，将5.2创建为一个本类的临时对象，然后调用等号运算符重载，将该临时对象赋值给c2
    c2 = 5.2;  

    // 调用拷贝构造函数( 有下面两种调用方式)

    Complex c5(c3);
    Complex c4 = c3;

    // 注意和 =运算符重载的区分,这里等号左边的对象不是事先已经创建，故需要调用拷贝构造函数，参数为c2
    // 这一点特别重要，这儿是初始化，不是赋值。
    // 其实这儿就涉及了C++中的两种初始化的方式：复制初始化和赋值初始化。
    // 其中c5采用的是复制初始化，而c4采用的是赋值初始化，这两种方式都是要调用拷贝构造函数的。

&#125;
</code></pre>
<h2 id="（33）-什么情况下会调用拷贝构造函数（三种情况）"><a href="#（33）-什么情况下会调用拷贝构造函数（三种情况）" class="headerlink" title="（33） 什么情况下会调用拷贝构造函数（三种情况）"></a>（33） 什么情况下会调用拷贝构造函数（三种情况）</h2><p>（1）用类的一个对象去初始化另一个对象时</p>
<p>（2）当函数的形参是类的对象时（也就是值传递时），如果是引用传递则不会调用</p>
<p>（3）当函数的返回值是类的对象或引用时</p>
<p>简单示例：</p>
<pre><code>#include &lt;iostream&gt;  
using namespace std;  

class A  
&#123;  
private:  
    int a;  
public:  
    A(int i)&#123;a=i;&#125;  //内联的构造函数  
    A(A &amp;aa);  
    int geta()&#123;return a;&#125;  
&#125;;  

A::A(A &amp;aa)     //拷贝构造函数  
&#123;  
    a=aa.a;  
    cout&lt;&lt;&quot;拷贝构造函数执行！&quot;&lt;&lt;endl;  
&#125;  

int get_a(A aa)     //参数是对象，是值传递，会调用拷贝构造函数  
&#123;  
    return aa.geta();  
&#125;  

int get_a_1(A &amp;aa)  //如果参数是引用类型，本身就是引用传递，所以不会调用拷贝构造函数  
&#123;  
    return aa.geta();  
&#125;  

A get_A()       //返回值是对象类型，会调用拷贝构造函数。会调用拷贝构造函数，因为函数体内生成的对象aa是临时的，离开这个函数就消失了。所有会调用拷贝构造函数复制一份。  
&#123;  
    A aa(1);  
    return aa;  
&#125;  

A&amp; get_A_1()    //会调用拷贝构造函数，因为函数体内生成的对象aa是临时的，离开这个函数就消失了。所有会调用拷贝构造函数复制一份。  
&#123;  
    A aa(1);  
    return aa;  
&#125;  

int _tmain(int argc, _TCHAR* argv[])  
&#123;  
    A a1(1);  
    A b1(a1);           //用a1初始化b1，调用拷贝构造函数  
    A c1=a1;            //用a1初始化c1，调用拷贝构造函数  

    int i=get_a(a1);        //函数形参是类的对象，调用拷贝构造函数  
    int j=get_a_1(a1);      //函数形参类型是引用，不调用拷贝构造函数  

    A d1=get_A();       //调用拷贝构造函数  
    A e1=get_A_1();     //调用拷贝构造函数  

    return 0;  
&#125;  
</code></pre>
<h2 id="（34）-结构体内存对齐方式和为什么要进行内存对齐？"><a href="#（34）-结构体内存对齐方式和为什么要进行内存对齐？" class="headerlink" title="（34） 结构体内存对齐方式和为什么要进行内存对齐？"></a>（34） 结构体内存对齐方式和为什么要进行内存对齐？</h2><p>１:数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在32位机为４字节,则要从４的整数倍地址开始存储。</p>
<p>２:结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)</p>
<p>３:收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍.不足的要补齐.</p>
<p>4:在代码前加一句#pragma pack(1),告诉编译器,所有的对齐都按照1的整数倍对齐,换句话说就是没有对齐规则.如果#pragma pack (n)中指定的n大于结构体中最大成员的size，则其不起作用，结构体仍然按照size最大的成员进行对界</p>
<p>struct结构体变量大小等于结构体中的各个成员变量所占内存大小总和，union共用体变量大小等于共用体结构中占用内存最大的成员的内存大小。</p>
<p>首先先明白概念：<br>数据类型，指固定内存大小的别名，如int类型为4个字节内存。<br>变量，一段连续存储空间的别名。这段连续存储空间的大小，即变量的大小，由定义该变量的数据类型决定，即该数据类型代表的固定内存大小。数据类型，是变量的模板。</p>
<h2 id="（35）-内存泄露的定义，如何检测与避免？"><a href="#（35）-内存泄露的定义，如何检测与避免？" class="headerlink" title="（35） 内存泄露的定义，如何检测与避免？"></a>（35） 内存泄露的定义，如何检测与避免？</h2><p>申请的堆没有被释放，该内存不能在被利用。</p>
<h2 id="（36）-手写实现智能指针类（34-37我没遇见过）"><a href="#（36）-手写实现智能指针类（34-37我没遇见过）" class="headerlink" title="（36） 手写实现智能指针类（34-37我没遇见过）"></a>（36） 手写实现智能指针类（34-37我没遇见过）</h2><h2 id="（37）-调试程序的方法"><a href="#（37）-调试程序的方法" class="headerlink" title="（37） 调试程序的方法"></a>（37） 调试程序的方法</h2><h2 id="（38）-遇到coredump要怎么调试"><a href="#（38）-遇到coredump要怎么调试" class="headerlink" title="（38） 遇到coredump要怎么调试"></a>（38） 遇到coredump要怎么调试</h2><h2 id="（39）-内存检查工具的了解"><a href="#（39）-内存检查工具的了解" class="headerlink" title="（39） 内存检查工具的了解"></a>（39） 内存检查工具的了解</h2><h2 id="（40）-模板的用法与适用场景"><a href="#（40）-模板的用法与适用场景" class="headerlink" title="（40） 模板的用法与适用场景"></a>（40） 模板的用法与适用场景</h2><h3 id="（1）函数模板"><a href="#（1）函数模板" class="headerlink" title="（1）函数模板"></a>（1）函数模板</h3><p>函数模板能够用来创建一个通用的函数。以支持多种不同的形參。避免重载函数的函数体反复设计。</p>
<p>它的最大特点是把函数使用的数据类型作为參数。</p>
<p>函数模板的声明形式为：</p>
<pre><code>template&lt;typename（或class) T&gt;
&lt;返回类型&gt;&lt;函数名&gt;(參数表)
&#123;
    函数体
&#125;
</code></pre>
<p>当中，template是定义模板函数的关键字；template后面的尖括号不能省略；typename（或class)是声明数据类型參数标识符的关键字。用以说明它后面的标识符是数据类型标识符。这样，在以后定义的这个函数中，凡希望依据实參数据类型来确定数据类型的变量，都能够用数据类型參数标识符来说明，从而使这个变量能够适应不同的数据类型。</p>
<p>比如：</p>
<pre><code>template&lt;typename（或class) T&gt;
T fuc(T x, T y)
&#123;
    T x;
    //……
&#125;
</code></pre>
<p>函数模板仅仅是声明了一个函数的描写叙述即模板。不是一个能够直接运行的函数，仅仅有依据实际情况用实參的数据类型取代类型參数标识符之后，才干产生真正的函数。</p>
<h3 id="（2）模板函数："><a href="#（2）模板函数：" class="headerlink" title="（2）模板函数："></a>（2）模板函数：</h3><p>模板函数的生成就是将函数模板的类型形參实例化的过程。</p>
<p>比如：</p>
<pre><code> double d;
     int a;
     fuc(d,a);
</code></pre>
<p>则系统将用实參d的数据类型double去取代函数模板中的T生成函数：</p>
<pre><code>double fuc(double x,int y)
&#123;
    double x;
    //……
&#125;
</code></pre>
<h2 id="（41）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"><a href="#（41）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？" class="headerlink" title="（41） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"></a>（41） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</h2><p>概念：以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式，对成员进行初始化。</p>
<p>效率：构造函数之前执行默认初始化。而成员初始化列表，可以立即初始化，所以更快些。</p>
<p>成员是const对象和引用必须初始化。</p>
<h2 id="（42）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"><a href="#（42）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）" class="headerlink" title="（42） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"></a>（42） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</h2><p>C++11：C++11包括大量的新特性：包括lambda表达式，类型推导关键字auto、decltype，和模板的大量改进。</p>
<h3 id="新的关键字"><a href="#新的关键字" class="headerlink" title="新的关键字"></a>新的关键字</h3><h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>C++11中引入auto第一种作用是为了自动类型推导</p>
<p>auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作</p>
<p>auto实际上实在编译时对变量进行了类型推导，所以不会对程序的运行效率造成不良影响</p>
<p>另外，似乎auto并不会影响编译速度，因为编译时本来也要右侧推导然后判断与左侧是否匹配。</p>
<pre><code>auto a; // 错误，auto是通过初始化表达式进行类型推导，如果没有初始化表达式，就无法确定a的类型  
auto i = 1;  
auto d = 1.0;  
auto str = &quot;Hello World&quot;;  
auto ch = &#39;A&#39;;  
auto func = less&lt;int&gt;();  
vector&lt;int&gt; iv;  
auto ite = iv.begin();  
auto p = new foo() // 对自定义类型进行类型推导
</code></pre>
<p>auto不光有以上的应用，它在模板中也是大显身手，比如下例这个加工产品的例子中，如果不使用auto就必须声明Product这一模板参数：</p>
<pre><code>template &lt;typename Product, typename Creator&gt;  
void processProduct(const Creator&amp; creator) &#123;  
    Product* val = creator.makeObject();  
    // do somthing with val  
&#125;         
</code></pre>
<p>如果使用auto，则可以这样写：</p>
<pre><code>template &lt;typename Creator&gt;  
void processProduct(const Creator&amp; creator) &#123;  
    auto val = creator.makeObject();  
    // do somthing with val  
&#125;
</code></pre>
<p>抛弃了麻烦的模板参数，整个代码变得更加正解了。</p>
<h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4><p>decltype实际上有点像auto的反函数，auto可以让你声明一个变量，而decltype则可以从一个变量或表达式中得到类型，有实例如下：</p>
<pre><code>int x = 3;  
decltype(x) y = x;
</code></pre>
<p>有人会问，decltype的实用之处在哪里呢，我们接着上边的例子继续说下去，如果上文中的加工产品的例子中我们想把产品作为返回值该怎么办呢？我们可以这样写：</p>
<pre><code>template &lt;typename Creator&gt;  
auto processProduct(const Creator&amp; creator) -&gt; decltype(creator.makeObject()) &#123;  
    auto val = creator.makeObject();  
    // do somthing with val  
&#125;
nullptr
</code></pre>
<p>nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，</p>
<pre><code>void F(int a)&#123;  
    cout&lt;&lt;a&lt;&lt;endl;  
&#125;  

void F(int *p)&#123;  
    assert(p != NULL);  

    cout&lt;&lt; p &lt;&lt;endl;  
&#125;  

int main()&#123;  

    int *p = nullptr;  
    int *q = NULL;  
    bool equal = ( p == q ); // equal的值为true，说明p和q都是空指针  
    int a = nullptr; // 编译失败，nullptr不能转型为int  
    F(0); // 在C++98中编译失败，有二义性；在C++11中调用F（int）  
    F(nullptr);  

    return 0;  
&#125;
</code></pre>
<h3 id="序列for循环"><a href="#序列for循环" class="headerlink" title="序列for循环"></a>序列for循环</h3><p>在C++中for循环可以使用类似java的简化的for循环，可以用于遍历数组，容器，string以及由begin和end函数定义的序列（即有Iterator），示例代码如下：</p>
<pre><code>map&lt;string, int&gt; m&#123;&#123;"a", 1&#125;, &#123;"b", 2&#125;, &#123;"c", 3&#125;&#125;;  
for (auto p : m)&#123;  
    cout&lt;&lt;p.first&lt;&lt;&quot; : &quot;&lt;&lt;p.second&lt;&lt;endl;  
&#125;
</code></pre>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>lambda表达式类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：</p>
<pre><code>[函数对象参数]（操作符重载函数参数）-&gt;返回值类型&#123;函数体&#125;

vector&lt;int&gt; iv&#123;5, 4, 3, 2, 1&#125;;  
int a = 2, b = 1;  

for_each(iv.begin(), iv.end(), [b](int &amp;x)&#123;cout&lt;&lt;(x + b)&lt;&lt;endl;&#125;); // (1)  

for_each(iv.begin(), iv.end(), [=](int &amp;x)&#123;x *= (a + b);&#125;);     // (2)  

for_each(iv.begin(), iv.end(), [=](int &amp;x)-&gt;int&#123;return x * (a + b);&#125;);// (3)
</code></pre>
<p>[]内的参数指的是Lambda表达式可以取得的全局变量。(1)函数中的b就是指函数可以得到在Lambda表达式外的全局变量，如果在[]中传入&#x3D;的话，即是可以取得所有的外部变量，如（2）和（3）Lambda表达式<br>()内的参数是每次调用函数时传入的参数。<br>-&gt;后加上的是Lambda表达式返回值的类型，如（3）中返回了一个int类型的变量</p>
<h3 id="变长参数的模板"><a href="#变长参数的模板" class="headerlink" title="变长参数的模板"></a>变长参数的模板</h3><p>我们在C++中都用过pair，pair可以使用make_pair构造，构造一个包含两种不同类型的数据的容器。比如，如下代码：</p>
<pre><code>auto p = make_pair(1, &quot;C++ 11&quot;);
由于在C++11中引入了变长参数模板，所以发明了新的数据类型：tuple，tuple是一个N元组，可以传入1个， 2个甚至多个不同类型的数据

auto t1 = make_tuple(1, 2.0, &quot;C++ 11&quot;);  
auto t2 = make_tuple(1, 2.0, &quot;C++ 11&quot;, &#123;1, 0, 2&#125;);
</code></pre>
<p>这样就避免了从前的pair中嵌套pair的丑陋做法，使得代码更加整洁</p>
<p>另一个经常见到的例子是Print函数，在C语言中printf可以传入多个参数，在C++11中，我们可以用变长参数模板实现更简洁的Print</p>
<pre><code>template&lt;typename head, typename... tail&gt;  
void Print(Head head, typename... tail) &#123;  
    cout&lt;&lt; head &lt;&lt;endl;  
    Print(tail...);  
&#125;
</code></pre>
<p>Print中可以传入多个不同种类的参数，如下：</p>
<p>Print(1, 1.0, “C++11”);</p>
<h3 id="更加优雅的初始化方法"><a href="#更加优雅的初始化方法" class="headerlink" title="更加优雅的初始化方法"></a>更加优雅的初始化方法</h3><p>在引入C++11之前，只有数组能使用初始化列表，其他容器想要使用初始化列表，只能用以下方法：</p>
<pre><code>int arr[3] = &#123;1, 2, 3&#125;  
vector&lt;int&gt; v(arr, arr + 3);
</code></pre>
<p>在C++11中，我们可以使用以下语法来进行替换：</p>
<pre><code>int arr[3]&#123;1, 2, 3&#125;;  
vector&lt;int&gt; iv&#123;1, 2, 3&#125;;  
map&lt;int, string&gt;&#123;&#123;1, "a"&#125;, &#123;2, "b"&#125;&#125;;  
string str&#123;&quot;Hello World&quot;&#125;;
</code></pre>
<h3 id="C-14：C-14的主要特性可以分为三个领域：Lambda函数、constexpr和类型推导。"><a href="#C-14：C-14的主要特性可以分为三个领域：Lambda函数、constexpr和类型推导。" class="headerlink" title="C++14：C++14的主要特性可以分为三个领域：Lambda函数、constexpr和类型推导。"></a>C++14：C++14的主要特性可以分为三个领域：Lambda函数、constexpr和类型推导。</h3><h3 id="Lambda函数"><a href="#Lambda函数" class="headerlink" title="Lambda函数"></a>Lambda函数</h3><p>C++14的泛型Lambda使编写如下语句成为可能：</p>
<pre><code>auto lambda = [](auto x, auto y) &#123;return x + y;&#125;;
</code></pre>
<p>而另一方面，C++11要求Lambda参数使用具体的类型声明，比如：</p>
<pre><code>auto lambda = [](int x, int y) &#123;return x + y;&#125;;
</code></pre>
<p>此外，新标准中的std::move函数可用于捕获Lambda表达式中的变量，这是通过移动对象而非复制或引用对象实现的：</p>
<pre><code>std::unique_ptr ptr(new int(10));
auto lambda = [value = std::move(ptr)] &#123;return *value;&#125;;
</code></pre>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>在C++11中，使用constexpr声明的函数可以在编译时执行，生成一个值，用在需要常量表达式的地方，比如作为初始化模板的整形参数。C++11的constexpr函数只能包含一个表达式，C++14放松了这些限制，支持诸如if 和switch等条件语句，支持循环，其中包括基于区间（range）的for 循环。</p>
<h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>C++11仅支持Lambda函数的类型推导，C++14对其加以扩展，支持所有函数的返回类型推导：</p>
<pre><code>auto DeducedReturnTypeFunction();
</code></pre>
<p>因为C++14是强类型语言，有些限制需要考虑：</p>
<p>如果一个函数的实现中有多个返回语句，这些语句一定要推导出同样的类型。<br>返回类型推导可以用在前向声明中，但是在使用它们之前，翻译单元中必须能够得到函数定义。<br>返回类型推导可以用在递归函数中，但是递归调用必须以至少一个返回语句作为先导，以便编译器推导出返回类型。<br>C++14带来的另一个类型推导方面的改进是decltype(auto)语法，它支持使用与auto同样的机制计算给定表达式的类型。auto和 decltype在C++11中就已经出现了，但是它们在推导类型时使用了不同的机制，这可能会产生不同的结果。</p>
<p>C++14中的其他改变包括可以声明变量模板，支持使用0b或0B前缀来声明二进制字面常量。InfoQ已经介绍过C++14中可能破坏C++11程序的其他小型修改。</p>
<h2 id="（43）-C-的调用惯例（简单一点C-函数调用的压栈过程）"><a href="#（43）-C-的调用惯例（简单一点C-函数调用的压栈过程）" class="headerlink" title="（43） C++的调用惯例（简单一点C++函数调用的压栈过程）"></a>（43） C++的调用惯例（简单一点C++函数调用的压栈过程）</h2><h2 id="（44）-C-的四种强制转换"><a href="#（44）-C-的四种强制转换" class="headerlink" title="（44） C++的四种强制转换"></a>（44） C++的四种强制转换</h2><p>C语言中的强制类型转换可以随意的转换我们想要的类型了,格式如下</p>
<pre><code>(类型) 变量名;
</code></pre>
<p>为什么c++还要引入新的4种类型转换呢?</p>
<p>  这是因为新的类型转换控制符可以很好的控制类型转换的过程,允许控制各种类型不同的转换.</p>
<p>  还有一点好处是C++的类型转换控制符能告诉程序员或读者我们这个转换的目的是什么,我们<br> 只要看一下代码的类型转换控制符,就能明白我们想要达到什么样的目的.</p>
<h3 id="1-static-cast-lt-T-gt-content-静态转换-在编译期间处理"><a href="#1-static-cast-lt-T-gt-content-静态转换-在编译期间处理" class="headerlink" title="1)static_cast &lt;T*&gt; (content)  静态转换.在编译期间处理"></a>1)static_cast &lt;T*&gt; (content)  静态转换.在编译期间处理</h3><p>   它主要用于C++中内置的基本数据类型之间的转换.但是没有运行时类型的检测来保证转换的安全性.</p>
<p>   为什么需要static_cast类型的转换?</p>
<h4 id="a-用于基类和子类之间的指针或引用的转换。"><a href="#a-用于基类和子类之间的指针或引用的转换。" class="headerlink" title="a.用于基类和子类之间的指针或引用的转换。"></a>a.用于基类和子类之间的指针或引用的转换。</h4><p>这种转换把子类的指针或引用转换为基类表示是安全的;进行下行转换,把基类的指针或引用转换为子类表示时,由于没有进行动态类型检测,所以是不安全的;</p>
<h4 id="b-把void类型的指针转换成目标类型的指针-不安全"><a href="#b-把void类型的指针转换成目标类型的指针-不安全" class="headerlink" title="b.把void类型的指针转换成目标类型的指针(不安全)."></a>b.把void类型的指针转换成目标类型的指针(不安全).</h4><h4 id="c-用于内置的基本的数据类型之间的转换"><a href="#c-用于内置的基本的数据类型之间的转换" class="headerlink" title="c.用于内置的基本的数据类型之间的转换."></a>c.用于内置的基本的数据类型之间的转换.</h4><h4 id="d-把任何类型的表达式转换成void类型的"><a href="#d-把任何类型的表达式转换成void类型的" class="headerlink" title="d.把任何类型的表达式转换成void类型的."></a>d.把任何类型的表达式转换成void类型的.</h4><p>   注意:static_cast不会转换掉content的const,volatile,__unaligned属性</p>
<h3 id="2-static-const-lt-T-gt-content-去常转换-编译时执行"><a href="#2-static-const-lt-T-gt-content-去常转换-编译时执行" class="headerlink" title="2)static_const&lt;T*&gt;(content):去常转换;编译时执行;"></a>2)static_const&lt;T*&gt;(content):去常转换;编译时执行;</h3><p>  它主要作用同一个类型之间的去常和添加常属性之间的转换.不能用做不同的类型之间的转换.</p>
<p>  它可以把一个不是常属性的转换成常属性的,同时它也可以对一个本是常属性的类型进行去常.</p>
<h3 id="3-dynamic-cast-lt-T-gt-content-动态类型转换-也是向下安全转型-是在运行的时候执行"><a href="#3-dynamic-cast-lt-T-gt-content-动态类型转换-也是向下安全转型-是在运行的时候执行" class="headerlink" title="3)dynamic_cast&lt;T*&gt;(content) 动态类型转换;也是向下安全转型;是在运行的时候执行;"></a>3)dynamic_cast&lt;T*&gt;(content) 动态类型转换;也是向下安全转型;是在运行的时候执行;</h3><p>   通常用于基类和派生类之间的转换.转换时会进行类型安全检查。</p>
<h4 id="a-4"><a href="#a-4" class="headerlink" title="a."></a>a.</h4><p>不能用于内置的基本数据类型之间的转换.</p>
<h4 id="b-5"><a href="#b-5" class="headerlink" title="b."></a>b.</h4><p>dynamic_cast转换成功的话返回的是类的指针或引用,失败返回null;</p>
<h4 id="c-3"><a href="#c-3" class="headerlink" title="c."></a>c.</h4><p>dynamic_cast进行的转换的时候基类中一定要有虚函数,因为只有类中有了虚函数, 才说明它希望让基类指针或引用指向其派生类对象的情况,这样才有意义.这是由于运行时类型检查需要运行时类型的信息,而这些信息存储在虚函数表中.</p>
<h4 id="d-3"><a href="#d-3" class="headerlink" title="d."></a>d.</h4><p>在类的转换时,在类层次间进行转换的时候,dynamic_cast和static_cast进行上行转换的时候效果是一样的；但是在进行下行转换的时候,dynamic_cast会进行类型检查所以它更安全.它可以让指向基类的指针转换为指向其子类的指针或是其兄弟类的指针;</p>
<h3 id="4-reinterpret-cast-lt-T-gt-content-重解释类型转换"><a href="#4-reinterpret-cast-lt-T-gt-content-重解释类型转换" class="headerlink" title="4)reinterpret_cast&lt;T*&gt;(content)重解释类型转换;"></a>4)reinterpret_cast&lt;T*&gt;(content)重解释类型转换;</h3><p>   它有着和C风格强制类型转换同样的功能;它可以转化任何的内置数据类型为其他的类型, 同时它也可以把任何类型的指针转化为其他的类型;它的机理是对二进制数据进行重新的的解释,不会改变原来的格式,而static_cast会改变原来的格式;</p>

      
      
        <div class="page-reward">
          <p><a href="javascript:void(0)" onclick="dashangToggle()" class="dashang">赏</a></p>
          <div class="hide_box"></div>
          <div class="shang_box">
            <a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()">×</a>
            <div class="shang_tit">
              <p>纯属好玩</p>
            </div>
            <div class="shang_payimg">
              <img src="/img/alipayimg.jpg" alt="扫码支持" title="扫一扫" />
            </div>
              <div class="pay_explain">扫码打赏，你说多少就多少</div>
            <div class="shang_payselect">
              
                <div class="pay_item checked" data-id="alipay">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/alipay.png" alt="支付宝" /></span>
                </div>
              
              
                <div class="pay_item" data-id="wechat">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/weixin.png" alt="微信" /></span>
                </div>
              
            </div>
            <div class="shang_info">
              <p>打开<span id="shang_pay_txt">支付宝</span>扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
        <script type="text/javascript">
          $(".pay_item").click(function(){
            $(this).addClass('checked').siblings('.pay_item').removeClass('checked');
            var dataid=$(this).attr('data-id');
            $(".shang_payimg img").attr("src","/img/"+dataid+"img.jpg");
            $("#shang_pay_txt").text(dataid=="alipay"?"支付宝":"微信");
          });
          function dashangToggle(){

            $(".hide_box").fadeToggle();
            $(".shang_box").fadeToggle();
          }
        </script>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/09/21/C++%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/">C++面试高频题</a></p>
        <p><span>文章作者:</span><a href="/" title="访问  的个人博客"></a></p>
        <p><span>发布时间:</span>2018年09月21日 - 17时12分</p>
        <p><span>最后更新:</span>2019年07月18日 - 12时07分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/09/21/C++%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/" title="C++面试高频题">http://yoursite.com/2018/09/21/C++%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2018/09/21/C++%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/　　作者: " title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2018/10/04/116.Populating%20Next%20Right%20Pointers%20in%20Each%20Node%E5%A1%AB%E5%85%85%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          116.Populating Next Right Pointers in Each Node填充同一层的兄弟节点
        
      </div>
    </a>
  
  
    <a href="/2018/09/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">操作系统面试高频题</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E7%B3%BB"><span class="toc-number">1.</span> <span class="toc-text">联系:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a"><span class="toc-number">1.1.</span> <span class="toc-text">a.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b"><span class="toc-number">1.2.</span> <span class="toc-text">b.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c"><span class="toc-number">1.3.</span> <span class="toc-text">c.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d"><span class="toc-number">1.4.</span> <span class="toc-text">d.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">区别:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-1"><span class="toc-number">2.1.</span> <span class="toc-text">a.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-1"><span class="toc-number">2.2.</span> <span class="toc-text">b.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-1"><span class="toc-number">2.3.</span> <span class="toc-text">c.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-1"><span class="toc-number">2.4.</span> <span class="toc-text">d.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e"><span class="toc-number">2.5.</span> <span class="toc-text">e.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#f"><span class="toc-number">2.6.</span> <span class="toc-text">f.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#g"><span class="toc-number">2.7.</span> <span class="toc-text">g.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%882%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">参考答案2：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1"><span class="toc-number">3.1.</span> <span class="toc-text">1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2"><span class="toc-number">3.2.</span> <span class="toc-text">2)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3"><span class="toc-number">3.3.</span> <span class="toc-text">3)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4"><span class="toc-number">3.4.</span> <span class="toc-text">4)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5"><span class="toc-number">3.5.</span> <span class="toc-text">5)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6"><span class="toc-number">3.6.</span> <span class="toc-text">6)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7"><span class="toc-number">3.7.</span> <span class="toc-text">7)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8"><span class="toc-number">3.8.</span> <span class="toc-text">8)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9"><span class="toc-number">3.9.</span> <span class="toc-text">9)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C"><span class="toc-number">3.10.</span> <span class="toc-text">a.管理方式不同:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%8F%AF%E7%94%A8%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E5%90%8C"><span class="toc-number">3.11.</span> <span class="toc-text">b.可用内存空间不同:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E8%83%BD%E5%90%A6%E4%BA%A7%E7%94%9F%E7%A2%8E%E7%89%87%E4%B8%8D%E5%90%8C"><span class="toc-number">3.12.</span> <span class="toc-text">c.能否产生碎片不同:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E7%94%9F%E9%95%BF%E6%96%B9%E5%90%91%E4%B8%8D%E5%90%8C"><span class="toc-number">3.13.</span> <span class="toc-text">d.生长方向不同:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e-%E5%88%86%E9%85%8D%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C"><span class="toc-number">3.14.</span> <span class="toc-text">e.分配的方式不同:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#f-%E5%88%86%E9%85%8D%E7%9A%84%E6%95%88%E7%8E%87%E4%B8%8D%E5%90%8C"><span class="toc-number">3.15.</span> <span class="toc-text">f.分配的效率不同:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.16.</span> <span class="toc-text">a.运算符和库函数的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-2"><span class="toc-number">3.17.</span> <span class="toc-text">b.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-2"><span class="toc-number">3.18.</span> <span class="toc-text">c.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-2"><span class="toc-number">3.19.</span> <span class="toc-text">d.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%886%EF%BC%89-Struct%E5%92%8Cclass%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">（6） Struct和class的联系和区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E7%B3%BB-1"><span class="toc-number">1.</span> <span class="toc-text">联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%887%EF%BC%89-define-%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E3%80%81%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%AD%89%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">（7） define 和const的区别（编译阶段、安全性、内存占用等）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BC%96%E8%AF%91%E5%99%A8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%E3%80%82"><span class="toc-number">1.</span> <span class="toc-text">(1) 编译器处理方式不同。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5%E4%B8%8D%E5%90%8C%E3%80%82"><span class="toc-number">2.</span> <span class="toc-text">(2)类型和安全检查不同。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%E3%80%82"><span class="toc-number">3.</span> <span class="toc-text">(3)存储方式不同。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%888%EF%BC%89-%E5%9C%A8C-%E4%B8%ADconst%E5%92%8Cstatic%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E5%AE%9A%E4%B9%89%EF%BC%8C%E7%94%A8%E9%80%94%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">（8） 在C++中const和static的用法（定义，用途）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E8%87%B3%E5%B0%91%E6%9C%89%E4%B8%8B%E5%88%97n%E4%B8%AA%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">static关键字至少有下列n个作用：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">（1）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">（2）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">（3）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">（4）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">（5）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E5%85%B3%E9%94%AE%E5%AD%97%E8%87%B3%E5%B0%91%E6%9C%89%E4%B8%8B%E5%88%97n%E4%B8%AA%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">const关键字至少有下列n个作用：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-1"><span class="toc-number">2.1.</span> <span class="toc-text">（1）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-1"><span class="toc-number">2.2.</span> <span class="toc-text">（2）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89-1"><span class="toc-number">2.3.</span> <span class="toc-text">（3）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89-1"><span class="toc-number">2.4.</span> <span class="toc-text">（4）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89-1"><span class="toc-number">2.5.</span> <span class="toc-text">（5）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%889%EF%BC%89-const%E5%92%8Cstatic%E5%9C%A8%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%88%E5%AE%9A%E4%B9%89%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">（9） const和static在类中使用的注意事项（定义、初始化和使用）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89-C-%E4%B8%AD%E7%9A%84const%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%88%E7%94%A8%E6%B3%95%E5%92%8C%E6%84%8F%E4%B9%89%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">（10） C++中的const类成员函数（用法和意义）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">规则：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E4%B9%89%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">意义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">原因：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89-%E8%AE%A1%E7%AE%97%E4%B8%8B%E9%9D%A2%E5%87%A0%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%9A"><span class="toc-number"></span> <span class="toc-text">（11） 计算下面几个类的大小：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8813%EF%BC%89-C-%E7%9A%84STL%E4%BB%8B%E7%BB%8D%EF%BC%88%E8%BF%99%E4%B8%AA%E7%B3%BB%E5%88%97%E4%B9%9F%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%8C%E5%BB%BA%E8%AE%AE%E4%BE%AF%E6%8D%B7%E8%80%81%E5%B8%88%E7%9A%84%E8%BF%99%E6%96%B9%E9%9D%A2%E7%9A%84%E4%B9%A6%E7%B1%8D%E4%B8%8E%E8%A7%86%E9%A2%91%EF%BC%89%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%8C%85%E6%8B%AC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86allocator%EF%BC%8C%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%9C%BA%E7%90%86%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%AD%89"><span class="toc-number"></span> <span class="toc-text">（13） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8814%EF%BC%89-STL%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84hash%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number"></span> <span class="toc-text">（14） STL源码中的hash表的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8815%EF%BC%89-STL%E4%B8%ADunordered-map%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">（15） STL中unordered_map和map的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E6%9C%BA%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">内部实现机理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">map：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-map"><span class="toc-number">1.2.</span> <span class="toc-text">unordered_map:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%E4%BB%A5%E5%8F%8A%E9%80%82%E7%94%A8%E5%A4%84"><span class="toc-number">2.</span> <span class="toc-text">优缺点以及适用处</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">map 优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">map 缺点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-map-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">unordered_map 优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-map-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">2.4.</span> <span class="toc-text">unordered_map 缺点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8816%EF%BC%89-STL%E4%B8%ADvector%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number"></span> <span class="toc-text">（16） STL中vector的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81vector%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">一、vector的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">二、构造与析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%9E%84%E9%80%A0"><span class="toc-number">3.</span> <span class="toc-text">1、构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%9E%90%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">2、析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">5.</span> <span class="toc-text">三、插入和删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%85%B6%E4%BB%96%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.</span> <span class="toc-text">四、其他接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81reserve-%E6%93%8D%E4%BD%9C"><span class="toc-number">7.</span> <span class="toc-text">1、reserve()操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81resize-%E6%93%8D%E4%BD%9C"><span class="toc-number">8.</span> <span class="toc-text">2、resize()操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81-Insert-n-%E6%93%8D%E4%BD%9C"><span class="toc-number">9.</span> <span class="toc-text">3、_Insert_n()操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81erase-%E6%93%8D%E4%BD%9C"><span class="toc-number">10.</span> <span class="toc-text">4、erase()操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81assign-%E6%93%8D%E4%BD%9C"><span class="toc-number">11.</span> <span class="toc-text">5、assign()操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8817%EF%BC%89-vector%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%E5%8F%8A%E5%85%B6%E5%8E%9F%E5%9B%A0%EF%BC%8C%E9%A2%91%E7%B9%81%E5%AF%B9vector%E8%B0%83%E7%94%A8push-back-%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%E5%92%8C%E5%8E%9F%E5%9B%A0%E3%80%82"><span class="toc-number"></span> <span class="toc-text">（17） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8818%EF%BC%89-C-%E4%B8%AD%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number"></span> <span class="toc-text">（18） C++中的重载和重写的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8819%EF%BC%89-C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E7%83%AD%E9%97%A8%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">（19） C ++内存管理（热门问题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%80%E8%88%AC%E4%B8%80%E4%B8%AAc-x2F-c-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E7%9A%84%E6%97%B6%E5%80%99%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%A6%82%E4%B8%8B-%E5%9C%B0%E5%9D%80%E4%BB%8E%E4%BD%8E%E5%88%B0%E9%AB%98%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">(1)一般一个c&#x2F;c++程序编译的时候内存布局如下(地址从低到高的顺序)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E4%BB%A3%E7%A0%81%E5%8C%BA"><span class="toc-number">1.1.</span> <span class="toc-text">a.代码区:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%B8%B8%E9%87%8F%E5%8C%BA"><span class="toc-number">1.2.</span> <span class="toc-text">b.常量区:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">1.3.</span> <span class="toc-text">c.数据区:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-BSS%E6%AE%B5"><span class="toc-number">1.4.</span> <span class="toc-text">d.BSS段:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e-%E5%A0%86%E5%8C%BA"><span class="toc-number">1.5.</span> <span class="toc-text">e.堆区:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#f-%E6%A0%88%E5%8C%BA"><span class="toc-number">1.6.</span> <span class="toc-text">f.栈区:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#g-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8C%BA"><span class="toc-number">1.7.</span> <span class="toc-text">g.命令行参数和环境变量区;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%8E%E4%B8%8A%E9%9D%A2%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%87%BAc-x2F-c-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E4%B8%BB%E8%A6%81%E6%9C%89%E4%B8%89%E7%A7%8D"><span class="toc-number">2.</span> <span class="toc-text">(2)从上面可以看出c&#x2F;c++的内存分配方式主要有三种</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E4%BB%8E%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E5%88%86%E9%85%8D"><span class="toc-number">2.1.</span> <span class="toc-text">a.从静态存储区域分配:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">2.2.</span> <span class="toc-text">b.在栈上分配内存:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E4%BB%8E%E5%A0%86%E4%B8%AD%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">2.3.</span> <span class="toc-text">c.从堆中分配内存:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8820%EF%BC%89-%E4%BB%8B%E7%BB%8D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E6%AF%8F%E4%B8%80%E4%B8%AA%E3%80%82"><span class="toc-number"></span> <span class="toc-text">（20） 介绍面向对象的三大特性，并且举例说明每一个。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B0%81%E8%A3%85"><span class="toc-number">1.</span> <span class="toc-text">(1)封装:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%A7%E6%89%BF"><span class="toc-number">2.</span> <span class="toc-text">(2)继承:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-2"><span class="toc-number">2.1.</span> <span class="toc-text">a.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-3"><span class="toc-number">2.2.</span> <span class="toc-text">b.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E6%80%81"><span class="toc-number">3.</span> <span class="toc-text">(3)多态:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-3"><span class="toc-number">3.1.</span> <span class="toc-text">a.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-4"><span class="toc-number">3.2.</span> <span class="toc-text">b.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8821%EF%BC%89-%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%92%8C%E4%B8%8B%E4%B8%AA%E9%97%AE%E9%A2%98%E4%B8%80%E8%B5%B7%E5%9B%9E%E7%AD%94%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">（21） 多态的实现（和下个问题一起回答）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E7%9A%84%E5%A4%9A%E6%80%81%E6%80%A7%E5%B0%B1%E6%98%AF%E9%80%9A%E8%BF%87%E6%99%9A%E7%BB%91%E5%AE%9A%E6%8A%80%E6%9C%AF%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84%E3%80%82"><span class="toc-number">1.</span> <span class="toc-text">c++的多态性就是通过晚绑定技术来实现的。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8822%EF%BC%89-C-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%EF%BC%88%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%89%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E7%83%AD%E9%97%A8%EF%BC%8C%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">（22） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8823%EF%BC%89-%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E5%99%A8%E5%A4%84%E7%90%86%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-number"></span> <span class="toc-text">（23） 实现编译器处理虚函数表应该如何处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8824%EF%BC%89-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%80%E8%88%AC%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number"></span> <span class="toc-text">（24） 析构函数一般写成虚函数的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8825%EF%BC%89-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E8%88%AC%E4%B8%8D%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">（25） 构造函数为什么一般不定义为虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8826%EF%BC%89-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="toc-number"></span> <span class="toc-text">（26） 构造函数或者析构函数中调用虚函数会怎样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8827%EF%BC%89-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">（27） 纯虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">一、定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%BC%95%E5%85%A5%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.</span> <span class="toc-text">二、引入原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.</span> <span class="toc-text">抽象类的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8828%EF%BC%89-%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number"></span> <span class="toc-text">（28） 静态绑定和动态绑定的介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8829%EF%BC%89-%E5%BC%95%E7%94%A8%E6%98%AF%E5%90%A6%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E7%94%A8%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0"><span class="toc-number"></span> <span class="toc-text">（29） 引用是否能实现动态绑定，为什么引用可以实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8830%EF%BC%89-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">（30） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8831%EF%BC%89-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number"></span> <span class="toc-text">（31） 对象复用的了解，零拷贝的了解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8832%EF%BC%89-%E4%BB%8B%E7%BB%8DC-%E6%89%80%E6%9C%89%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">（32） 介绍C++所有的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84"><span class="toc-number">1.</span> <span class="toc-text">一、 构造函数是干什么的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">二、 构造函数的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8%E4%B8%8A%E9%9D%A2%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E8%AF%B4%E6%98%8E%E5%90%84%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">三、使用上面定义的类对象来说明各个构造函数的用法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8833%EF%BC%89-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">（33） 什么情况下会调用拷贝构造函数（三种情况）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8834%EF%BC%89-%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E5%92%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">（34） 结构体内存对齐方式和为什么要进行内存对齐？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8835%EF%BC%89-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">（35） 内存泄露的定义，如何检测与避免？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8836%EF%BC%89-%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%B1%BB%EF%BC%8834-37%E6%88%91%E6%B2%A1%E9%81%87%E8%A7%81%E8%BF%87%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">（36） 手写实现智能指针类（34-37我没遇见过）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8837%EF%BC%89-%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">（37） 调试程序的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8838%EF%BC%89-%E9%81%87%E5%88%B0coredump%E8%A6%81%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95"><span class="toc-number"></span> <span class="toc-text">（38） 遇到coredump要怎么调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8839%EF%BC%89-%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number"></span> <span class="toc-text">（39） 内存检查工具的了解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8840%EF%BC%89-%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number"></span> <span class="toc-text">（40） 模板的用法与适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.</span> <span class="toc-text">（1）函数模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">（2）模板函数：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8841%EF%BC%89-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%BC%9A%E5%BF%AB%E4%B8%80%E4%BA%9B%EF%BC%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%BF%EF%BC%89%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">（41） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8842%EF%BC%89-%E7%94%A8%E8%BF%87C11%E5%90%97%EF%BC%8C%E7%9F%A5%E9%81%93C11%E6%96%B0%E7%89%B9%E6%80%A7%E5%90%97%EF%BC%9F%EF%BC%88%E6%9C%89%E9%9D%A2%E8%AF%95%E5%AE%98%E5%BB%BA%E8%AE%AE%E7%86%9F%E6%82%89C11%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">（42） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.</span> <span class="toc-text">新的关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#auto"><span class="toc-number">1.1.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype"><span class="toc-number">1.2.</span> <span class="toc-text">decltype</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97for%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.</span> <span class="toc-text">序列for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">Lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.</span> <span class="toc-text">变长参数的模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%8A%A0%E4%BC%98%E9%9B%85%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">更加优雅的初始化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-14%EF%BC%9AC-14%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E4%B8%89%E4%B8%AA%E9%A2%86%E5%9F%9F%EF%BC%9ALambda%E5%87%BD%E6%95%B0%E3%80%81constexpr%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E3%80%82"><span class="toc-number">6.</span> <span class="toc-text">C++14：C++14的主要特性可以分为三个领域：Lambda函数、constexpr和类型推导。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">Lambda函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr"><span class="toc-number">8.</span> <span class="toc-text">constexpr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">9.</span> <span class="toc-text">类型推导</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8843%EF%BC%89-C-%E7%9A%84%E8%B0%83%E7%94%A8%E6%83%AF%E4%BE%8B%EF%BC%88%E7%AE%80%E5%8D%95%E4%B8%80%E7%82%B9C-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%8B%E6%A0%88%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">（43） C++的调用惯例（简单一点C++函数调用的压栈过程）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8844%EF%BC%89-C-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number"></span> <span class="toc-text">（44） C++的四种强制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-static-cast-lt-T-gt-content-%E9%9D%99%E6%80%81%E8%BD%AC%E6%8D%A2-%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E9%97%B4%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">1)static_cast &lt;T*&gt; (content)  静态转换.在编译期间处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E7%94%A8%E4%BA%8E%E5%9F%BA%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8%E7%9A%84%E8%BD%AC%E6%8D%A2%E3%80%82"><span class="toc-number">1.1.</span> <span class="toc-text">a.用于基类和子类之间的指针或引用的转换。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E6%8A%8Avoid%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%87%E9%92%88%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9B%AE%E6%A0%87%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%87%E9%92%88-%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">1.2.</span> <span class="toc-text">b.把void类型的指针转换成目标类型的指针(不安全).</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E7%94%A8%E4%BA%8E%E5%86%85%E7%BD%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.</span> <span class="toc-text">c.用于内置的基本的数据类型之间的转换.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E6%8A%8A%E4%BB%BB%E4%BD%95%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E6%88%90void%E7%B1%BB%E5%9E%8B%E7%9A%84"><span class="toc-number">1.4.</span> <span class="toc-text">d.把任何类型的表达式转换成void类型的.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-static-const-lt-T-gt-content-%E5%8E%BB%E5%B8%B8%E8%BD%AC%E6%8D%A2-%E7%BC%96%E8%AF%91%E6%97%B6%E6%89%A7%E8%A1%8C"><span class="toc-number">2.</span> <span class="toc-text">2)static_const&lt;T*&gt;(content):去常转换;编译时执行;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-dynamic-cast-lt-T-gt-content-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E4%B9%9F%E6%98%AF%E5%90%91%E4%B8%8B%E5%AE%89%E5%85%A8%E8%BD%AC%E5%9E%8B-%E6%98%AF%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E6%89%A7%E8%A1%8C"><span class="toc-number">3.</span> <span class="toc-text">3)dynamic_cast&lt;T*&gt;(content) 动态类型转换;也是向下安全转型;是在运行的时候执行;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-4"><span class="toc-number">3.1.</span> <span class="toc-text">a.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-5"><span class="toc-number">3.2.</span> <span class="toc-text">b.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-3"><span class="toc-number">3.3.</span> <span class="toc-text">c.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-3"><span class="toc-number">3.4.</span> <span class="toc-text">d.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-reinterpret-cast-lt-T-gt-content-%E9%87%8D%E8%A7%A3%E9%87%8A%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">4)reinterpret_cast&lt;T*&gt;(content)重解释类型转换;</span></a></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">


<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    
        <div id="gitments"></div>
<script src="/js/gitment.browser.js"></script>
<script>
    var gitment = new Gitment({
      id: window.location.pathname,
      owner: 'yiye',
      repo: 'liyiye012.github.io',
      oauth: {
        client_id: '',
        client_secret: '',
      },
    })
    gitment.render('gitments')
</script>
    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/10/04/116.Populating%20Next%20Right%20Pointers%20in%20Each%20Node%E5%A1%AB%E5%85%85%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/" title="上一篇: 116.Populating Next Right Pointers in Each Node填充同一层的兄弟节点">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2018/09/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/" title="下一篇: 操作系统面试高频题">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/08/22/733.%20%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/">733. 图像渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/22/463.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/">463. 岛屿的周长</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/09/748.%20%E6%9C%80%E7%9F%AD%E8%A1%A5%E5%85%A8%E8%AF%8D/">748. 最短补全词</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/05/C++%E4%BA%8C%E7%BB%B4%E5%8A%A8%E6%80%81%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82%E9%80%9F%E6%9F%A5/">C++二维动态静态数组传参速查</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/14/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91(%E5%89%91%E6%8C%87%20Offer%2007.%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91)/">105. 从前序与中序遍历序列构造二叉树(剑指 Offer 07. 重建二叉树)</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/06/13/Flask%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Flask学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/05/22/%E4%BB%8E%E6%96%87%E6%9C%AC%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/">从文本中读取数据</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/09/399.%20%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/">399. 除法求值</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/09/394.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/">394. 字符串解码</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/09/494.%20%E7%9B%AE%E6%A0%87%E5%92%8C/">494. 目标和</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/08/416.%20%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/">416. 分割等和子集</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/08/581.%20%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/">581. 最短无序连续子数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/28/Latex%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B/">Latex极简教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/17/85.%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/">85. 最大矩形</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/17/Hexo%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/">Hexo+github搭建个人博客问题总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/18/312.%20%E6%88%B3%E6%B0%94%E7%90%83%E4%BA%8C%E5%88%B7/">312. 戳气球</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/18/114.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/">114. 二叉树展开为链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/18/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/">145. 二叉树的后序遍历</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/12/84.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/">84.柱状图中最大的矩形</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/">32. 最长有效括号</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/438.%20%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/">438. 找到字符串中所有字母异位词</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/10/Hexo%E4%B8%8ENodejs%E7%89%88%E6%9C%AC%E4%B8%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">Hexo与Nodejs版本不匹配问题解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/10/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/">JAVA 学习笔记（数据结构）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/07/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%89/">JAVA 学习笔记（算法）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/07/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88YARN%EF%BC%89/">JAVA 学习笔记（YARN）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/07/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%91%E8%AE%A1%E7%AE%97%EF%BC%89/">JAVA 学习笔记（云计算）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/07/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Storm%EF%BC%89/">JAVA 学习笔记（Storm）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/07/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Spark%EF%BC%89/">JAVA 学习笔记（Spark）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/06/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Hadoop%EF%BC%89/">JAVA 学习笔记（Hadoop）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/06/%20JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%EF%BC%89/">JAVA 学习笔记（分布式缓存）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/06/%20JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%89/">JAVA 学习笔记（加密算法）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/06/Grafana%E6%B1%89%E5%8C%96%E6%8C%87%E5%8D%97/">Grafana汉化指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/06/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%EF%BC%89/">JAVA 学习笔记（一致性算法）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/06/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%89/">JAVA 学习笔记（数据库）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/05/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%89/">JAVA 学习笔记（负载均衡）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/05/686.%20%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/">686. 重复叠加字符串匹配</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/05/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Cassandra%EF%BC%89/">JAVA 学习笔记（Cassandra）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/05/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88MongoDB%EF%BC%89/">JAVA 学习笔记（MongoDB）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/05/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Hbase%EF%BC%89/">JAVA 学习笔记（Hbase）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/04/459.%20%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/">459. 重复的子字符串</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/04/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Kafka%EF%BC%89/">JAVA 学习笔记（Kafka）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/04/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%89/">JAVA 学习笔记（日志）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/03/28.%20%E5%AE%9E%E7%8E%B0%20strStr()/">28. 实现 strStr()</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/03/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%BD%91%E7%BB%9C7%E5%B1%82%E6%9E%B6%E6%9E%84%EF%BC%8CTCP%EF%BC%8CHTTP%E5%92%8CCDN%E5%8E%9F%E7%90%86%EF%BC%89/">JAVA 学习笔记（网络7层架构，TCP，HTTP和CDN原理）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/03/796.%20%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/">796. 旋转字符串</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/03/417.%20%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/">417. 太平洋大西洋水流问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/03/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88NIO%EF%BC%89/">JAVA 学习笔记（NIO）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/02/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Netty%20%E4%B8%8E%20RPC%EF%BC%89/">JAVA 学习笔记（Netty 与 RPC）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/31/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%89/">JAVA 学习笔记（微服务）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/30/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88IoC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%89/">JAVA 学习笔记（IoC控制反转）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/30/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Bean%EF%BC%89/">JAVA 学习笔记（Bean）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/30/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Spring%20%E5%8E%9F%E7%90%86%EF%BC%89/">JAVA 学习笔记（Spring 原理）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/29/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%8F%8D%E5%B0%84%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E6%B3%9B%E5%9E%8B%EF%BC%8C%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%A4%8D%E5%88%B6%EF%BC%89/">JAVA 学习笔记（异常，反射，注解，内部类，泛型，序列化，复制）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/24/423.%20%E4%BB%8E%E8%8B%B1%E6%96%87%E4%B8%AD%E9%87%8D%E5%BB%BA%E6%95%B0%E5%AD%97/">423. 从英文中重建数字</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/22/JAVA%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%BA%BF%E7%A8%8B%EF%BC%8C%E9%94%81%EF%BC%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89/">JAVA 多线程并发学习笔记（线程，锁，进程调度）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/22/JAVA%20%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88set%EF%BC%8Clist%E5%92%8Cmap%EF%BC%89/">JAVA 集合学习笔记（set，list和map）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/21/518.%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%20II/">518. 零钱兑换 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/21/%E5%89%91%E6%8C%87%20Offer%2017.%20%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/">剑指 Offer 17. 打印从1到最大的n位数</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/19/2103.%20%E7%8E%AF%E5%92%8C%E6%9D%86/">2103. 环和杆</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/19/2104.%20%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C/">2104. 子数组范围和</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/17/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%BA%BF%E7%A8%8B%EF%BC%8CJVM%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%BC%95%E7%94%A8%EF%BC%8CIO%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%89/">JVM学习笔记（线程，JVM，垃圾回收，引用，IO，类加载）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/17/875.%20%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/">875. 爱吃香蕉的珂珂</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/17/%E5%89%91%E6%8C%87%20Offer%20II%20073.%20%E7%8B%92%E7%8B%92%E5%90%83%E9%A6%99%E8%95%89/">剑指 Offer II 073. 狒狒吃香蕉</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/17/403.%20%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/">403. 青蛙过河</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/16/1884.%20%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD-%E4%B8%A4%E6%9E%9A%E9%B8%A1%E8%9B%8B/">1884. 鸡蛋掉落-两枚鸡蛋</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/16/1377.%20T%20%E7%A7%92%E5%90%8E%E9%9D%92%E8%9B%99%E7%9A%84%E4%BD%8D%E7%BD%AE/">1377. T 秒后青蛙的位置</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/16/1419.%20%E6%95%B0%E9%9D%92%E8%9B%99/">1419. 数青蛙</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/16/1936.%20%E6%96%B0%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%91%E5%8F%B0%E9%98%B6%E6%95%B0/">1936. 新增的最少台阶数</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/16/746.%20%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/">746. 使用最小花费爬楼梯</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/16/%E5%89%91%E6%8C%87%20Offer%20II%20088.%20%E7%88%AC%E6%A5%BC%E6%A2%AF%E7%9A%84%E6%9C%80%E5%B0%91%E6%88%90%E6%9C%AC/">剑指 Offer II 088. 爬楼梯的最少成本</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/16/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/">70. 爬楼梯</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/16/%E5%89%91%E6%8C%87%20Offer%2010-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/">剑指 Offer 10- II. 青蛙跳台阶问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/15/842.%20%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97/">1414. 和为 K 的最少斐波那契数字数目</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/15/1414.%20%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/">1414. 和为 K 的最少斐波那契数字数目</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/14/873.%20%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/">873. 最长的斐波那契子序列的长度</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/14/%E5%89%91%E6%8C%87%20Offer%20II%20093.%20%E6%9C%80%E9%95%BF%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/">剑指 Offer II 093. 最长斐波那契数列</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/13/372.%20%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/">372. 超级次方</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/13/69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9(%E4%BA%8C%E5%88%86%E6%B3%95%E6%A8%A1%E6%9D%BF%E9%A2%98%E5%8F%8A%E7%BB%8F%E5%85%B8%E8%A7%A3%E9%87%8A%EF%BC%89/">69. x 的平方根(二分法模板题及经典解释）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/13/%E5%89%91%E6%8C%87%20Offer%20II%20072.%20%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9(%E4%BA%8C%E5%88%86%E6%B3%95%E6%A8%A1%E6%9D%BF%E9%A2%98%E5%8F%8A%E7%BB%8F%E5%85%B8%E8%A7%A3%E9%87%8A%EF%BC%89/">剑指 Offer II072</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/13/50.%20Pow(x,%20n)%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/">50. Pow(x, n)快速幂算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/13/509.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/">509. 斐波那契数</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/13/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.06.%20%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/">面试题 08.06. 汉诺塔问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/12/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E5%BF%B5%EF%BC%8C%E6%9E%B6%E6%9E%84%E5%92%8C%E6%B6%88%E6%81%AF%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B%EF%BC%89/">RabbitMQ学习笔记（概念，架构和消息交换机类型）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/12/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.07.%20%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC/">面试题 16.07. 最大数值</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/12/%E5%89%91%E6%8C%87%20Offer%20II%20079.%20%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86/">剑指 Offer II 079. 所有子集</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/12/%E5%89%91%E6%8C%87%20Offer%20II%20067.%20%E6%9C%80%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96/">剑指 Offer II 067. 最大的异或</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/10/421.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/">421. 数组中两个数的最大异或值</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/10/%E9%9D%A2%E8%AF%95%E9%A2%98%2005.03.%20%E7%BF%BB%E8%BD%AC%E6%95%B0%E4%BD%8D/">面试题 05.03. 翻转数位</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/10/%E5%89%91%E6%8C%87%20Offer%2065.%20%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/">剑指 Offer 65. 不用加减乘除做加法</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/09/%E5%89%91%E6%8C%87%20Offer%2064.%20%E6%B1%821+2+%E2%80%A6+n/">剑指 Offer 64. 求1+2+…+n</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/08/1863.%20%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86%E7%9A%84%E5%BC%82%E6%88%96%E6%80%BB%E5%92%8C%E5%86%8D%E6%B1%82%E5%92%8C/">1863. 找出所有子集的异或总和再求和</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/08/%E5%89%91%E6%8C%87%20Offer%2053%20-%20II.%200%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/08/%E5%89%91%E6%8C%87%20Offer%2056%20-%20II.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%20II/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/08/%E5%89%91%E6%8C%87%20Offer%2056%20-%20I.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/">剑指 Offer 56 - I. 数组中数字出现的次数</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/07/477.%20%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/">477. 汉明距离总和</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/05/Zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%8D%8F%E8%AE%AE%EF%BC%8C%E6%8A%95%E7%A5%A8%E6%9C%BA%E5%88%B6%EF%BC%89/">Zookeeper学习笔记（概念，协议，投票机制）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5I/">计算机网络概念I</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/30/Linux%E6%96%87%E6%9C%AC%E4%B8%89%E5%89%91%E5%AE%A2%EF%BC%8Cawk%E3%80%81grep%E3%80%81sed/">Linux文本三剑客，awk、grep、sed</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/29/503.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20II/">503. 下一个更大元素 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/29/556.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20III/">556. 下一个更大元素 III</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/28/496.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20I/">496. 下一个更大元素 I</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/26/739.%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/">739. 每日温度</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/23/396.%20%E6%97%8B%E8%BD%AC%E5%87%BD%E6%95%B0/">396. 旋转函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/21/525.%20%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84/">525. 连续数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/18/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E4%BB%BD%E4%BC%98%E7%A7%80%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%91%A8%E6%8A%A5/">如何写出一份优秀的工作周报？</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/17/1044.%20%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/">1044. 最长重复子串</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/16/1358.%20%E5%8C%85%E5%90%AB%E6%89%80%E6%9C%89%E4%B8%89%E7%A7%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%9B%AE/">1358. 包含所有三种字符的子字符串数目</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/16/1297.%20%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/">1297. 子串的最大出现次数</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/15/1109.%20%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/">1109. 航班预订统计</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/15/904.%20%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/">904. 水果成篮</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/12/%E3%80%8A%E5%A4%A9%E9%BE%99%E5%85%AB%E9%83%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">《天龙八部》读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/12/795.%20%E5%8C%BA%E9%97%B4%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/">795. 区间子数组个数</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/10/467.%20%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%94%AF%E4%B8%80%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/">467. 环绕字符串中唯一的子字符串</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/07/992.%20K%20%E4%B8%AA%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/">992. K 个不同整数的子数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/07/340.%20%E8%87%B3%E5%A4%9A%E5%8C%85%E5%90%AB%20K%20%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/">340. 至多包含 K 个不同字符的最长子串</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/07/159.%20%E8%87%B3%E5%A4%9A%E5%8C%85%E5%90%AB%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/">159. 至多包含两个不同字符的最长子串</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/05/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/">3. 无重复字符的最长子串</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/03/991.%20%E5%9D%8F%E4%BA%86%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8/">991. 坏了的计算器</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/02/224.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/">224. 基本计算器</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/02/772.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8III/">772. 基本计算器III</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/02/227.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%20II/">227.基本计算器 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/31/560.%20%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/">560. 和为 K 的子数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/31/MySQL%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%9120%E9%97%AE/">MySQL面试高频20问</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/28/713.%20%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8EK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/">713. 乘积小于K的子数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/28/209.%20%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/">209. 长度最小的子数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/27/318.%20%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/">318. 最大单词长度乘积</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/25/1531.%20%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%20II/">1531. 压缩字符串 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/25/443.%20%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/">443. 压缩字符串</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/24/338.%20%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/">338. 比特位计数</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/21/262.%20%E8%A1%8C%E7%A8%8B%E5%92%8C%E7%94%A8%E6%88%B7/">262. 行程和用户</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/18/29.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/">29. 两数相除</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/04/1071.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/">1071. 字符串的最大公因子</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/07/1206.%20%E8%AE%BE%E8%AE%A1%E8%B7%B3%E8%A1%A8/">1206. 设计跳表</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/26/707.%20%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/">707. 设计链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/09/706.%20%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84/">706. 设计哈希映射</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/09/705.%20%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/">705. 设计哈希集合</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/07/LCP%2029.%20%E4%B9%90%E5%9B%A2%E7%AB%99%E4%BD%8D/">LCP 29. 乐团站位</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/05/LCP%2028.%20%E9%87%87%E8%B4%AD%E6%96%B9%E6%A1%88/">LCP 28. 采购方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/31/294%20%C2%B7%20%E7%AE%80%E5%8C%96%E9%93%BE%E8%A1%A8/">294 · 简化链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/31/711.%20%E4%B8%8D%E5%90%8C%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8FII/">711. 不同岛屿的数量II</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/31/694.%20%E4%B8%8D%E5%90%8C%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F/">694. 不同岛屿的数量</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/30/305.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%20II/">305. 岛屿数量 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/29/572.%20%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/">572. 另一个树的子树</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/27/491.%20%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/">304. 二维区域和检索 - 矩阵不可变</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/27/304.%20%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/">304. 二维区域和检索 - 矩阵不可变</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/25/456.%20132%20%E6%A8%A1%E5%BC%8F/">456. 132 模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/18/1188%20%E8%AE%BE%E8%AE%A1%E6%9C%89%E9%99%90%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/">1188 设计有限阻塞队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/18/1242.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB/">1242.多线程网页爬虫</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/17/1279.%20%E7%BA%A2%E7%BB%BF%E7%81%AF%E8%B7%AF%E5%8F%A3/">1279. 红绿灯路口</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/04/953.%20%E9%AA%8C%E8%AF%81%E5%A4%96%E6%98%9F%E8%AF%AD%E8%AF%8D%E5%85%B8/">953. 验证外星语词典</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/27/269.%E7%81%AB%E6%98%9F%E8%AF%8D%E5%85%B8/">269.火星词典</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/23/Java%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E5%8F%8A%E7%A4%BA%E4%BE%8B/">Java开发规范及示例</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/22/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/">Java基础知识-装箱和拆箱</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/22/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%87%8D%E5%86%99%20%60equals%60%20%E6%97%B6%E4%B8%BA%E4%BD%95%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99%20%60hashCode%60%20%E6%96%B9%E6%B3%95/">Java基础知识-重写 `equals` 时为何必须重写 `hashCode` 方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/20/JAVA%20%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/">JAVA 强软弱虚四种引用类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/03/77.%20%E7%BB%84%E5%90%88/">77. 组合</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/02/57.%20%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/">57. 插入区间</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/02/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/">17. 电话号码的字母组合</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/28/909.%20%E8%9B%87%E6%A2%AF%E6%A3%8B/">909. 蛇梯棋</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/27/688.%20%E2%80%9C%E9%A9%AC%E2%80%9D%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/">688. “马”在棋盘上的概率</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/27/782.%20%E5%8F%98%E4%B8%BA%E6%A3%8B%E7%9B%98/">782. 变为棋盘</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/25/1275.%20%E6%89%BE%E5%87%BA%E4%BA%95%E5%AD%97%E6%A3%8B%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85/">1275. 找出井字棋的获胜者</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/29/312.%20%E6%88%B3%E6%B0%94%E7%90%83/">312. 戳气球</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/23/406.%20%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/">406. 根据身高重建队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/23/301.%20%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/">301. 删除无效的括号</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/17/76.%20%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/">76. 最小覆盖子串</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/16/41.%20%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/">41. 缺失的第一个正数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/16/89.%20%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/">89. 格雷编码</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/15/61.%20%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/">61. 旋转链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/09/8.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%20(atoi)/">8. 字符串转换整数 (atoi)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/02/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/">1. 两数之和</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/30/176.%20%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/">176. 第二高的薪水</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/30/393.%20UTF-8%20%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81/">393. UTF-8 编码验证</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/26/69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/">69. x 的平方根</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/25/432.%20%E5%85%A8%20O(1)%20%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">432. 全 O(1) 的数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/24/354.%20%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83/">354. 俄罗斯套娃</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/24/120.%20%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/">120. 三角形最小路径和</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/24/1277.%20%E7%BB%9F%E8%AE%A1%E5%85%A8%E4%B8%BA%201%20%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5/">1277. 统计全为 1 的正方形子矩阵</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/24/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/">53. 最大子序和</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/23/221.%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/">221.最大正方形</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/23/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/">122.买卖股票的最佳时机II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/23/121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/">121.买卖股票的最佳时机</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/23/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/">102.二叉树的层次遍历</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/23/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/">103. 二叉树的锯齿形层次遍历</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/23/107.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20II/">107. 二叉树的层次遍历 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/20/23.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/">23. 合并K个升序链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/20/445.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/">445. 两数相加II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/20/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/">2. 两数相加</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/19/407.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4II/">407. 接雨水II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/18/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/">42. 接雨水</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/18/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/">56. 合并区间</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/18/547.%20%E6%9C%8B%E5%8F%8B%E5%9C%88/">547. 朋友圈</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/18/128.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/">128. 最长连续序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/13/60.%20%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/">60. 排列序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/13/674.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/">674. 最长连续递增序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/13/81.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/">81. 搜索旋转排序数组 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/11/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/">33. 搜索旋转排序数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/11/695.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/">695. 岛屿的最大面积</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/22/16.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/">16. 最接近的三数之和</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/22/923.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%8F%AF%E8%83%BD/">923. 三数之和的多种可能</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/22/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/">15. 三数之和</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/13/93.%20%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/">93. 复原IP地址</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/13/71.%20%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/">71. 简化路径</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/12/151.%20%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/">151. 翻转字符串里的单词</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/12/415.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/">415. 字符串相加</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/12/43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/">43. 字符串相乘</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/10/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8.%E9%9D%A2%E8%AF%95%E9%A2%9808.08.%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/">程序员面试金典.面试题08.08.有重复字符串的排列组合</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/10/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8.%E9%9D%A2%E8%AF%95%E9%A2%9808.07.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/">程序员面试金典.面试题08.07.无重复字符串的排列组合</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/10/%E5%89%91%E6%8C%87%20offer38.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/">剑指 offer38.字符串的排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/09/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/">14. 最长公共前缀</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/09/567.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/">567. 字符串的排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/09/784.%20%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97/">784. 字母大小写全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/06/146.%20LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">146. LRU缓存机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/05/134.%20%E5%8A%A0%E6%B2%B9%E7%AB%99/">134. 加油站</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/05/412.%20Fizz%20Buzz/">412. Fizz Buzz</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/04/371.%20%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/">371. 两整数之和</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/04/202.%20%E5%BF%AB%E4%B9%90%E6%95%B0/">202. 快乐数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/30/326.%203%E7%9A%84%E5%B9%82/">326. 3的幂</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/30/268.%20%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/">268. 缺失数字</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/29/204.%20%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/">204. 计数质数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/28/191.%20%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/">191. 位1的个数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/27/172.%20%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/">172. 阶乘后的零</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/27/190.%20%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/">190. 颠倒二进制位</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/18/166.%20%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/">166. 分数到小数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/18/149.%20%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/">149. 直线上最多的点数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/17/260.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III/">260. 只出现一次的数字III</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/16/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/">136. 只出现一次的数字</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/16/137.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II/">137. 只出现一次的数字II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/15/210.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8II/">210. 课程表II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/14/207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/">207. 课程表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/14/200.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/">200. 岛屿数量</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/09/127.%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/">127. 单词接龙</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/08/322.%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/">322. 零钱兑换</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/08/329.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/">329. 矩阵中的最长递增路径</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/08/300.%20%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/">300. 最长上升子序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/03/279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/">279. 完全平方数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/03/337.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII/">337. 打家劫舍III</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/03/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/">213. 打家劫舍II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/03/198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/">198. 打家劫舍</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/31/124.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/">124. 二叉树中的最大路径和</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/31/395.%20%E8%87%B3%E5%B0%91%E6%9C%89K%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/">395. 至少有K个重复字符的最长子串</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/26/%E5%89%91%E6%8C%87%20offer51.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/">剑指 offer51.数组中的逆序对</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/26/315.%20%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/">315. 计算右侧小于当前元素的个数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/25/287.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/">287. 寻找重复数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/24/162.%20%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/">162. 寻找峰值</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/24/324.%20%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F%20II/">324. 摆动排序 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/24/179.%20%E6%9C%80%E5%A4%A7%E6%95%B0/">179. 最大数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/24/297.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">297. 二叉树的序列化与反序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/24/236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">236. 二叉树的最近公共祖先</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/22/230.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/">230. 二叉搜索树中第K小的元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/21/380.%20%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/">380. 常数时间插入、删除和获取随机元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/21/454.%20%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%20II/">454. 四数相加 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/21/Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/">171. Excel表列序号</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/21/328.%20%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/">328. 奇偶链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/21/237.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/">237. 删除链表中的节点</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/20/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/">234. 回文链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/19/92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/">92. 反转链表II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/18/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">206. 反转链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/18/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/">160. 相交链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/17/Java%20%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE/">Java 练手项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/25/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/">142. 环形链表II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/25/148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/">148. 排序链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/24/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/">141. 环形链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/23/138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/">138. 复制带随机指针的链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/23/150.%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/">150. 逆波兰表达式求值</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/23/341.%20%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/">341. 扁平化嵌套列表迭代器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/19/239.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/">239. 滑动窗口最大值</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/18/347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/">347. 前 K 个高频元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/12/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Java编程思想-第二十二章 枚举阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/09/378.%20%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/">378. 有序矩阵中第K小的元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/06/295.%20%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/">295. 数据流的中位数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/06/215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/">215. 数组中的第K个最大元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/238.%20%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/">238. 除自身以外数组的乘积</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/155.%20%20%E6%9C%80%E5%B0%8F%E6%A0%88/">155. 最小栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/30/240.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II/">240. 搜索二维矩阵II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/30/74.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/">74. 搜索二维矩阵</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/30/334.%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97/">334. 递增的三元子序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/350.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/">350. 两个数组的交集II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/349.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/">349. 两个数组的交集</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/384.%20%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/">384. 打乱数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/">283. 移动零</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/Java%E4%B9%8BTreeSet%E7%B1%BB/">Java之TreeSet类</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/220.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0III/">220. 存在重复元素III</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/219.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/">219. 存在重复元素II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/217.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/">217. 存在重复元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/">152. 乘积最大子数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/189.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/">189. 旋转数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/63.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/">63. 不同路径II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/980.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20III/">980. 不同路径 III</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/62.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/">62. 不同路径</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/212.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2II/">212. 单词搜索II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0%20%E6%B3%A8%E8%A7%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Java编程思想-第二十三章 注解阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Java编程思想-第二十章 泛型阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/27/79.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/">79. 单词搜索</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/26/Java%E4%B9%8B%E6%95%B0%E7%BB%84/">Java之数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/26/%E3%80%8A%E7%94%9F%E4%BA%8B%E4%B9%8B%E5%B1%8B%EF%BC%9A%E7%99%BD%E5%AE%AB%E5%9B%9E%E5%BF%86%E5%BD%95%E3%80%8B%E8%8A%82%E9%80%89/">《生事之屋：白宫回忆录》节选</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/24/208.%20%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91)/">208. 实现 Trie (前缀树)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Sql_Mode/">数据库学习笔记-Sql_Mode</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/18/%20Java%E4%B9%8BString%E7%B1%BB/">Java之String类</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/18/Java%E4%B9%8B%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/">Java之可变参数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/15/Java%E4%B9%8BQueue%E3%80%81Deque%E3%80%81ArrayDeque/">Java之Queue、Deque、ArrayDeque</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/15/Java%E4%B9%8Binstanceof%E5%85%B3%E9%94%AE%E5%AD%97/">Java之instanceof关键字</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/14/Java%E4%B9%8Btransient%E5%85%B3%E9%94%AE%E5%AD%97/">Java之transient关键字</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%8E%A5%E5%8F%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Java编程思想-第十章 接口阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap/">Java集合之HashMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5III-%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">数据库基础概念III-事务并发控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/">数据库学习笔记-聚合函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%B4%A2%E5%BC%95/">数据库基础概念-索引</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-INTERSECT/">数据库学习笔记-INTERSECT</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-UNION/">数据库学习笔记-UNION</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%9E%E6%8E%A5/">数据库学习笔记-连接</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MySQL%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/">数据库学习笔记-MySQL安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5II-%E8%8C%83%E5%BC%8F-%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0-%E4%B8%89%E5%80%BC%E9%80%BB%E8%BE%91/">数据库基础概念II-范式-关系代数-三值逻辑</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SQL%E7%BA%A6%E6%9D%9F(Constraints)/">数据库学习笔记-SQL约束(Constraints)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/06/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E6%80%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Java编程思想-第九章 多态阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/06/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Java编程思想-第二十四章 并发编程阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/05/Maven%E5%BF%AB%E7%85%A7%E6%9C%BA%E5%88%B6(SNAPSHOT)/">Maven快照机制（SNAPSHOT）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/29/140.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86II/">140. 单词拆分II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/28/139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/">139. 单词拆分</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/28/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/">5. 最长回文子串</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/28/131.%20%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/">131. 分割回文串</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/28/887.%20%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD/">887. 鸡蛋掉落</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/27/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/">21. 合并两个有序链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/26/685.%E5%86%97%E4%BD%99%E9%93%BE%E6%8E%A5II/">685.冗余链接II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/26/1226.%20%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90/">1226. 哲学家进餐</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/24/1195.%20%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/">1195. 交替打印字符串</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/24/1117.%20H2O%20%E7%94%9F%E6%88%90/">1117. H2O 生成</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/24/1116.%20%E6%89%93%E5%8D%B0%E9%9B%B6%E4%B8%8E%E5%A5%87%E5%81%B6%E6%95%B0/">1116. 打印零与奇偶数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/22/1115.%20%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0FooBar/">1115. 交替打印FooBar</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/21/1114.%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0/">1114.按序打印</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/19/684.%E5%86%97%E4%BD%99%E9%93%BE%E6%8E%A5/">684.冗余链接</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/18/Lombok%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/">Lombok的基本注解使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/18/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E9%9B%86%E9%94%A6/">后端开发常用调试技巧集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/29/405.%20%E6%95%B0%E5%AD%97%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/">405. 数字转化为十六进制数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/17/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII-MybatisPlus%E6%95%99%E7%A8%8B/">SpringBoot学习笔记VIII-MybatisPlus教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">设计模式学习笔记V-策略模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/16/1046.%20%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/">1046. 最后一块石头的重量</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/24/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0XIV/">Java学习笔记XIV</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/24/257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/">257.二叉树的所有路径</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/22/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/">24.两两交换链表中的节点</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/20/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/">微信公众平台开发学习笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/20/601.Human%20Traffic%20of%20Stadium%E4%BD%93%E8%82%B2%E9%A6%86%E7%9A%84%E4%BA%BA%E6%B5%81%E9%87%8F/">601.Human Traffic of Stadium体育馆的人流量</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/20/185.Department%20Top%20Three%20Salaries/">185.Department Top Three Salaries</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IX/">数据库学习笔记IX</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/19/184.Department%20Highest%20Salary/">184.Department Highest Salary</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII/">数据库学习笔记VIII</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/17/1179.%20Reformat%20Department%20Table/">1179. Reformat Department Table</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/17/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0XVII/">Effective-Java阅读笔记XVII</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/17/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0XVI/">Effective-Java阅读笔记XVI</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/17/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0XV/">Effective-Java阅读笔记XV</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/16/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0XIV/">Effective-Java阅读笔记XIV</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/16/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0XIII/">Effective-Java阅读笔记XIII</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/16/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0XII/">Effective-Java阅读笔记XII</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/16/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0XI/">Effective-Java阅读笔记XI</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/16/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0X/">Effective-Java阅读笔记X</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/16/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0IX/">Effective-Java阅读笔记IX</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/16/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0VIII/">Effective-Java阅读笔记VIII</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/15/Hexo%E7%9A%84spfk%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9/">Hexo的spfk主题修改</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/15/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0VII/">Effective-Java阅读笔记VII</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/14/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0VI/">Effective-Java阅读笔记VI</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/13/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/">Git学习笔记III</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/06/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0V/">Effective-Java阅读笔记V</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/Hexo%E6%A0%87%E7%AD%BE%E4%B8%8Emd%E6%96%87%E4%BB%B6%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/">Hexo标签与md文件冲突问题解决</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/Java%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9/">Java开发中的易错点</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/">设计模式学习笔记IV</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VII/">数据库学习笔记VII</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/02/Java%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/">Java开发规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/31/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0III/">Effective-Java阅读笔记III</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/31/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0IV/">Effective-Java阅读笔记IV</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/31/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0II/">Effective-Java阅读笔记II</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/">设计模式学习笔记III</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/30/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0I/">Effective-Java阅读笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/27/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/">Scala学习笔记V</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/24/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0XII/">Java学习笔记XII</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/24/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0XIII/">Java学习笔记XIII</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/23/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/">Scala学习笔记IV</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/23/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0XI/">Java学习笔记XI</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/23/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/">Scala学习笔记III</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/17/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0X/">Java学习笔记X</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VI/">数据库学习笔记VI</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/">设计模式学习笔记II</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/">设计模式学习笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/25/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/">Scala学习笔记II</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IX/">Java学习笔记IX</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/Shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/">Shell学习笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/">Scala学习笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII/">Java学习笔记VIII</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VII/">Java学习笔记VII</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/05/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VI/">Java学习笔记VI</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/05/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II-Git%E7%89%88%E6%9C%AC%E5%9B%9E%E6%BB%9A/">Git学习笔记II-Git版本回滚</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/">数据库学习笔记V</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/">Git学习笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/">数据库学习笔记IV</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/">数据库学习笔记III</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/">Java学习笔记V</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/">Java学习笔记IV</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/">Java学习笔记III</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/">数据库学习笔记II</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/07/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/">Java学习笔记II</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/">Java学习笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/01/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VII/">SpringBoot学习笔记VII</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I-%E6%9F%A5%E8%AF%A2/">数据库学习笔记I-查询</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/30/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/">SpringBoot学习笔记V</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/">SpringBoot学习笔记IV</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/25/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/">SpringBoot学习笔记III</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/17/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/">SpringBoot学习笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/03/Linux%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/">Linux配置问题小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5I/">操作系统基础概念I</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/28/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/">Hexo博客多终端更新问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/TensorFlow%E5%85%A5%E9%97%A8-Mnist%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/">TensorFlow入门-Mnist手写数字识别</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/30/235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">235.Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/22/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/">Linux学习笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/11/Permutations%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/">Permutations全排列问题总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/09/84.Largest%20Rectangle%20in%20Histogram%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/">84.Largest Rectangle in Histogram柱状图中最大的矩形</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/05/52.%20N-QueensIIN%E7%9A%87%E5%90%8EII/">52. N-QueensNII皇后II</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/05/51.%20N-QueensN%E7%9A%87%E5%90%8E/">51. N-QueensN皇后</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/04/117.Populating%20Next%20Right%20Pointers%20in%20Each%20NodeII%E5%A1%AB%E5%85%85%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9II/">117.Populating Next Right Pointers in Each NodeII填充同一层的兄弟节点II</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/04/199.Binary%20Tree%20Right%20Side%20View%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/">199.Binary Tree Right Side View二叉树的右视图</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/04/545.Boundary%20of%20Binary%20Tree%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BE%B9%E7%95%8C/">545.Boundary of Binary Tree 二叉树的边界</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/04/116.Populating%20Next%20Right%20Pointers%20in%20Each%20Node%E5%A1%AB%E5%85%85%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/">116.Populating Next Right Pointers in Each Node填充同一层的兄弟节点</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/21/C++%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/">C++面试高频题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/">操作系统面试高频题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/">数据库面试高频题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/20/792.%20Number%20of%20Matching%20Subsequences%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/">792. Number of Matching Subsequences匹配子序列的单词数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/20/392.%20Is%20Subsequence%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/">392. Is Subsequence判断子序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/Linux%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/">Linux基础面试高频题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/">算法面试高频题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/">计算机网络面试高频题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/">设计模式面试高频题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%97%AE%E9%A2%98%E9%80%9A%E8%A7%A3/">回溯法问题通解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/78.%20Subsets%E5%AD%90%E9%9B%86/">78. Subsets子集</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/90.%20SubsetsII%E5%AD%90%E9%9B%86II/">90. SubsetsII子集II</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/72.%20Edit%20Distance%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/">72. Edit Distance编辑距离</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/13/277.Find%20the%20Celebrity%E5%AF%BB%E6%89%BE%E5%90%8D%E4%BA%BA/">277.Find the Celebrity寻找名人</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/13/148.%20Sort%20List%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/">148. Sort List排序链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/12/692.%20Top%20K%20Frequent%20Words%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/">692. Top K Frequent Words前K个高频单词</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/12/450.%20Delete%20Node%20in%20a%20BST%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/">450. Delete Node in a BST删除二叉搜索树中的节点</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/435.%20Non-overlapping%20Intervals%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/">435. Non-overlapping Intervals无重叠区间</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/C++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5VI/">C++基础概念VI</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/75.%20Sort%20Colors%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/">75. Sort Colors颜色分类</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/275.%20H-Index%20II%20H%E6%8C%87%E6%95%B0%20II/">275. H-Index II H指数 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/10/274.%20H-IndexH%E6%8C%87%E6%95%B0/">274. H-IndexH指数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/10/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bvector/">STL源码剖析之vector</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/06/Git%E5%88%86%E5%8C%BA%E6%A6%82%E5%BF%B5/">Git分区概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/06/486.%20Predict%20the%20Winner%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/">486. Predict the Winner预测赢家</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/">快速排序及其优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/31/C++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5IV/">C++基础概念IV</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/30/682.%20Baseball%20Game%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/">682. Baseball Game棒球比赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/30/542.%2001%20Matrix%2001%20%E7%9F%A9%E9%98%B5/">542. 01 Matrix 01 矩阵</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/29/C++%E8%BE%93%E5%85%A5%E6%80%BB%E7%BB%93/">C++输入总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/27/688.%20Knight%20Probability%20in%20Chessboard%E2%80%9C%E9%A9%AC%E2%80%9D%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/">688. Knight Probability in Chessboard“马”在棋盘上的概率</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/139.%20Word%20Break%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/">139. Word Break单词拆分</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/626.%20Exchange%20Seats%E6%8D%A2%E5%BA%A7%E4%BD%8D/">626. Exchange Seats换座位</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/Kickstart-Round-E-2018-ProblemA.Yogurt/">Kickstart-Round-E-2018-ProblemA.Yogurt</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/865.%20Smallest%20Subtree%20with%20all%20the%20Deepest%20Nodes%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9C%80%E6%B7%B1%E7%BB%93%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91/">865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/485.%20Max%20Consecutive%20Ones/">485. Max Consecutive Ones最大连续1的个数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/538.%20Convert%20BST%20to%20Greater%20Tree%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/">538. Convert BST to Greater Tree把二叉搜索树转换为累加树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/697.%20Degree%20of%20an%20Array%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/">697. Degree of an Array数组的度</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/885.%20Spiral%20Matrix%20III/">885. Spiral Matrix III螺旋矩阵 III</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5I/">数据库基础概念I</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/%E5%89%91%E6%8C%87Offer20.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/">20.PrintMatrix顺时针打印矩阵(CodingInterview)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/59.%20Spiral%20Matrix%20II%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%20II/">59. Spiral Matrix II螺旋矩阵 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/650.%202%20Keys%20Keyboard%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/">650. 2 Keys Keyboard只有两个键的键盘</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/23/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%EF%BC%8C%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/">在浏览器地址栏输入URL，按下回车后发生了什么</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/23/%E5%89%91%E6%8C%87Offer59.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/">59.SymmetricalBinaryTree对称的二叉树(CodingInterview)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/23/%E5%89%91%E6%8C%87offer%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/">剑指offer思路总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/300.%20Longest%20Increasing%20Subsequence%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/">300. Longest Increasing Subsequence最长上升子序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/%E5%89%91%E6%8C%87Offer64.%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/">64.StreamMedian数据流中的中位数(Coding Interviews )</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/21/C++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5I/">C++基础概念I</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/21/C++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5II/">C++基础概念II</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/21/C++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5III/">C++基础概念III</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/21/%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%E9%97%AE%E9%A2%98%E9%80%9A%E8%A7%A3%E5%B0%8F%E7%BB%93/">股票交易问题通解小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/16/%E5%89%8D%E8%A8%80/">前言</a></li></ul>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2022 Yiye Li
            </div>
                <i class="fas fa-chart-area"></i>
                    <span class="post-count">总字数：1090.5k</span>
                <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
                    <script>
                        var now = new Date();
                        function createtime() {
                            var grt= new Date("11/16/2017 21:14:20");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
                            now.setTime(now.getTime()+250);
                            days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
                            hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
                            if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
                            mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
                            seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                            snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
                            document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
                            document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
                        }
                    setInterval("createtime()",250);
                    </script>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_uv" style='display:none'>
                        <span id="site-visit" >本站访客数:
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量:
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>


    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>



  </div>
</body>
</html>