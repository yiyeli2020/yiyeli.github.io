<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Java编程思想-第二十章 泛型阅读笔记 | Yiye Li</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java编程思想-第二十章 泛型阅读笔记">
<meta property="og:url" content="http://yoursite.com/2020/06/28/Java编程思想-第二十章 泛型阅读笔记/index.html">
<meta property="og:site_name" content="Yiye Li">
<meta property="og:description" content="接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-06-29T06:23:02.363Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java编程思想-第二十章 泛型阅读笔记">
<meta name="twitter:description" content="接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。">
  
    <link rel="alternative" href="/atom.xml" title="Yiye Li" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet">
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">Yiye Li</a></h1>
        </hgroup>

        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=KBoeHhgdGBEQHhBoWVkGS0dF" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/liyiye012" title="github">github</a>
                            
                                <a class="fl linkedin" target="_blank" href="https://www.linkedin.com/in/yiye-li-864b3a99/" title="linkedin">linkedin</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Algorithm/" style="font-size: 12.22px;">Algorithm</a> <a href="/tags/Array/" style="font-size: 18.33px;">Array</a> <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/Backtracking/" style="font-size: 15.56px;">Backtracking</a> <a href="/tags/Binary-Indexed-Tree/" style="font-size: 10px;">Binary Indexed Tree</a> <a href="/tags/Binary-Search/" style="font-size: 17.22px;">Binary Search</a> <a href="/tags/Binary-Search-Tree/" style="font-size: 10px;">Binary Search Tree</a> <a href="/tags/BinaryTree/" style="font-size: 10.56px;">BinaryTree</a> <a href="/tags/Bit-Manipulation/" style="font-size: 10.56px;">Bit Manipulation</a> <a href="/tags/Breadth-first-Search/" style="font-size: 11.67px;">Breadth-first Search</a> <a href="/tags/C/" style="font-size: 16.11px;">C++</a> <a href="/tags/Coding-Interviews/" style="font-size: 12.22px;">Coding Interviews</a> <a href="/tags/Computer-Network/" style="font-size: 10px;">Computer Network</a> <a href="/tags/Concurrency/" style="font-size: 13.33px;">Concurrency</a> <a href="/tags/DFS/" style="font-size: 10px;">DFS</a> <a href="/tags/Database/" style="font-size: 17.22px;">Database</a> <a href="/tags/Database，MySQL/" style="font-size: 14.44px;">Database，MySQL</a> <a href="/tags/Depth-first-Search/" style="font-size: 13.89px;">Depth-first Search</a> <a href="/tags/Design/" style="font-size: 12.22px;">Design</a> <a href="/tags/Design-Pattern，Java/" style="font-size: 12.22px;">Design Pattern，Java</a> <a href="/tags/Divide-and-Conque/" style="font-size: 10px;">Divide and Conque</a> <a href="/tags/Divide-and-Conquer/" style="font-size: 10.56px;">Divide and Conquer</a> <a href="/tags/Dynamic-Programming/" style="font-size: 17.78px;">Dynamic Programming</a> <a href="/tags/Git/" style="font-size: 12.22px;">Git</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Google/" style="font-size: 10px;">Google</a> <a href="/tags/Graph/" style="font-size: 10.56px;">Graph</a> <a href="/tags/Greedy/" style="font-size: 10.56px;">Greedy</a> <a href="/tags/Hash-Table/" style="font-size: 16.11px;">Hash Table</a> <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a> <a href="/tags/Heap/" style="font-size: 13.89px;">Heap</a> <a href="/tags/Hexo/" style="font-size: 11.67px;">Hexo</a> <a href="/tags/Java/" style="font-size: 18.89px;">Java</a> <a href="/tags/Kickstart/" style="font-size: 10px;">Kickstart</a> <a href="/tags/Latex/" style="font-size: 10px;">Latex</a> <a href="/tags/LeetCode/" style="font-size: 20px;">LeetCode</a> <a href="/tags/Leetcode/" style="font-size: 19.44px;">Leetcode</a> <a href="/tags/LinkList/" style="font-size: 10px;">LinkList</a> <a href="/tags/Linked-List/" style="font-size: 15.56px;">Linked List</a> <a href="/tags/Linux/" style="font-size: 10.56px;">Linux</a> <a href="/tags/Math/" style="font-size: 11.11px;">Math</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Max-Heap/" style="font-size: 10px;">Max Heap</a> <a href="/tags/Memoization/" style="font-size: 10px;">Memoization</a> <a href="/tags/Minimax/" style="font-size: 10px;">Minimax</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Operating-System/" style="font-size: 10.56px;">Operating System</a> <a href="/tags/Ordered-Map/" style="font-size: 10px;">Ordered Map</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/Scala/" style="font-size: 12.22px;">Scala</a> <a href="/tags/Segment-Tree/" style="font-size: 10px;">Segment Tree</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/Sliding-Window/" style="font-size: 10px;">Sliding Window</a> <a href="/tags/Sort/" style="font-size: 13.33px;">Sort</a> <a href="/tags/SpringBoot/" style="font-size: 12.78px;">SpringBoot</a> <a href="/tags/Stack/" style="font-size: 12.22px;">Stack</a> <a href="/tags/String/" style="font-size: 11.11px;">String</a> <a href="/tags/TCPIP/" style="font-size: 10px;">TCPIP</a> <a href="/tags/Template/" style="font-size: 10.56px;">Template</a> <a href="/tags/TensorFlow/" style="font-size: 10px;">TensorFlow</a> <a href="/tags/Topological-Sort/" style="font-size: 10px;">Topological Sort</a> <a href="/tags/Tree/" style="font-size: 16.67px;">Tree</a> <a href="/tags/TreeSet/" style="font-size: 10px;">TreeSet</a> <a href="/tags/Trie/" style="font-size: 12.22px;">Trie</a> <a href="/tags/Two-Pointers/" style="font-size: 13.33px;">Two Pointers</a> <a href="/tags/Union-Find/" style="font-size: 11.11px;">Union Find</a> <a href="/tags/Virtual-function/" style="font-size: 10px;">Virtual function</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/Wechat/" style="font-size: 10px;">Wechat</a> <a href="/tags/blog/" style="font-size: 10.56px;">blog</a> <a href="/tags/heap/" style="font-size: 10px;">heap</a> <a href="/tags/sizeof/" style="font-size: 10px;">sizeof</a> <a href="/tags/stdin/" style="font-size: 10px;">stdin</a> <a href="/tags/vector/" style="font-size: 10px;">vector</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://liyiye012.github.io/">name</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">日拱一卒，功不唐捐</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Yiye Li</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Yiye Li</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=KBoeHhgdGBEQHhBoWVkGS0dF" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/liyiye012" title="github">github</a>
                    
                        <a class="linkedin" target="_blank" href="https://www.linkedin.com/in/yiye-li-864b3a99/" title="linkedin">linkedin</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-Java编程思想-第二十章 泛型阅读笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/28/Java编程思想-第二十章 泛型阅读笔记/" class="article-date">
      <time datetime="2020-06-28T02:53:12.000Z" itemprop="datePublished">2020-06-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java编程思想-第二十章 泛型阅读笔记
    </h1>
  

        
          <div style="margin-top:10px;">
    <span class="post-time">
      <span class="post-meta-item-icon">
        <i class="fa fa-keyboard-o"></i>
        <span class="post-meta-item-text">  字数统计: </span>
        <span class="post-count">40.9k字</span>
      </span>
    </span>
    &nbsp; | &nbsp;
    <span class="post-time">
      <span class="post-meta-item-icon">
        <i class="fa fa-hourglass-half"></i>
        <span class="post-meta-item-text">  阅读时长: </span>
        <span class="post-count">179分</span>
      </span>
    </span>
</div>

          
      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/2020年6月/">2020年6月</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。</p>
<a id="more"></a>

<p>[TOC]</p>
<!-- Generics -->

<h1 id="第二十章-泛型"><a href="#第二十章-泛型" class="headerlink" title="第二十章 泛型"></a>第二十章 泛型</h1><blockquote>
<p>普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。</p>
</blockquote>
<p>多态是一种面向对象思想的泛化机制。可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 <code>final</code> 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。</p>
<p>拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。如果方法以接口而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。</p>
<p>即便是接口也还是有诸多限制。一旦指定了接口，它就要求我们的代码必须使用特定的接口。而我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。</p>
<p>这就是泛型的概念，是 Java 5 的重大变化之一。泛型实现了<em>参数化类型</em>，这样我们编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后我们会发现 Java 中泛型的实现并没有那么“泛”，我们可能会质疑“泛型”这个词是否合适用来描述这一功能。</p>
<p>如果我们从未接触过参数化类型机制，我们会发现泛型对 Java 语言确实是个很有益的补充。在我们实例化一个类型参数时，编译器会负责转型并确保类型的正确性。这是一大进步。</p>
<p>然而，如果我们了解其他语言（例如 C++ ）的参数化机制，我们会发现，Java 泛型并不能满足所有的预期。使用别人创建好的泛型相对容易，但是创建自己的泛型时，就会遇到很多意料之外的麻烦。</p>
<p>这并不是说 Java 泛型毫无用处。在很多情况下，它可以使代码更直接更优雅。不过，如果我们见识过那种实现了更纯粹的泛型的编程语言，那么，Java 可能会令我们失望。本章会介绍 Java 泛型的优点与局限。我会解释 Java 的泛型是如何发展成现在这样的，希望能够帮助我们更有效地使用这个特性。</p>
<h3 id="与-C-的比较"><a href="#与-C-的比较" class="headerlink" title="与 C++ 的比较"></a>与 C++ 的比较</h3><p>Java 的设计者曾说过，这门语言的灵感主要来自 C++ 。尽管如此，学习 Java 时基本不用参考 C++ 。</p>
<p>但是，Java 中的泛型需要与 C++ 进行对比，理由有两个：首先，理解 C++ <em>模板</em>（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。同时，非常重要的一点是，我们可以了解 Java 泛型的局限是什么，以及为什么会有这些局限。最终的目标是明确 Java 泛型的边界，让我们成为一个程序高手。只有知道了某个技术不能做什么，我们才能更好地做到所能做的（部分原因是，不必浪费时间在死胡同里）。</p>
<p>第二个原因是，在 Java 社区中，大家普遍对 C++ 模板有一种误解，而这种误解可能会令我们在理解泛型的意图时产生偏差。</p>
<p>因此，本章中会介绍少量 C++ 模板的例子，仅当它们确实可以加深理解时才会引入。</p>
<!-- Simple Generics -->

<h2 id="简单泛型"><a href="#简单泛型" class="headerlink" title="简单泛型"></a>简单泛型</h2><p>促成泛型出现的最主要的动机之一是为了创建<em>集合类</em>，参见 集合 章节。集合用于存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。几乎所有程序在运行过程中都会涉及到一组对象，因此集合是可复用性最高的类库之一。</p>
<p>我们先看一个只能持有单个对象的类。这个类可以明确指定其持有的对象的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Holder1.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automobile</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Automobile a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder1</span><span class="params">(Automobile a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function">Automobile <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类的可复用性不高，它无法持有其他类型的对象。我们可不希望为碰到的每个类型都编写一个新的类。</p>
<p>在 Java 5 之前，我们可以让这个类直接持有 <code>Object</code> 类型的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ObjectHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectHolder</span><span class="params">(Object a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectHolder h2 = <span class="keyword">new</span> ObjectHolder(<span class="keyword">new</span> Automobile());</span><br><span class="line">        Automobile a = (Automobile)h2.get();</span><br><span class="line">        h2.set(<span class="string">"Not an Automobile"</span>);</span><br><span class="line">        String s = (String)h2.get();</span><br><span class="line">        h2.set(<span class="number">1</span>); <span class="comment">// 自动装箱为 Integer</span></span><br><span class="line">        Integer x = (Integer)h2.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，<code>ObjectHolder</code> 可以持有任何类型的对象，在上面的示例中，一个 <code>ObjectHolder</code> 先后持有了三种不同类型的对象。</p>
<p>一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。</p>
<p>因此，与其使用 <code>Object</code> ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用<em>类型参数</em>，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，<code>T</code> 就是类型参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericHolder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder&lt;Automobile&gt; h3 = <span class="keyword">new</span> GenericHolder&lt;Automobile&gt;();</span><br><span class="line">        h3.set(<span class="keyword">new</span> Automobile()); <span class="comment">// 此处有类型校验</span></span><br><span class="line">        Automobile a = h3.get();  <span class="comment">// 无需类型转换</span></span><br><span class="line">        <span class="comment">//- h3.set("Not an Automobile"); // 报错</span></span><br><span class="line">        <span class="comment">//- h3.set(1);  // 报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 <code>GenericHolder</code> 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 <code>main()</code> 中那样使用。然后，我们就只能在 <code>GenericHolder</code> 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当我们调用 <code>get()</code> 取值时，直接就是正确的类型。</p>
<p>这就是 Java 泛型的核心概念：我们只需告诉编译器要使用什么类型，剩下的细节交给它来处理。</p>
<p>我们可能注意到 <code>h3</code> 的定义非常繁复。在 <code>=</code> 左边有 <code>GenericHolder&lt;Automobile&gt;</code>, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Diamond.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bob</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Diamond</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder&lt;Bob&gt; h3 = <span class="keyword">new</span> GenericHolder&lt;&gt;();</span><br><span class="line">        h3.set(<span class="keyword">new</span> Bob());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在 <code>h3</code> 的定义处，<code>=</code> 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。</p>
<p>一般来说，我们可以认为泛型和其他类型差不多，只不过它们碰巧有类型参数罢了。在使用泛型时，我们只需要指定它们的名称和类型参数列表即可。</p>
<h3 id="一个元组类库"><a href="#一个元组类库" class="headerlink" title="一个元组类库"></a>一个元组类库</h3><p>有时一个方法需要能返回多个对象。而 <strong>return</strong> 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。</p>
<p>这个概念称为<em>元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象</em> 或 <em>信使</em> ）。</p>
<p>通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple2.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A a1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B a2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple2</span><span class="params">(A a, B b)</span> </span>&#123; a1 = a; a2 = b; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a1 + <span class="string">", "</span> + a2; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + rep() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。</p>
<p>初次阅读上面的代码时，我们可能认为这违反了 Java 编程的封装原则。<code>a1</code> 和 <code>a2</code> 应该声明为 <strong>private</strong>，然后提供 <code>getFirst()</code> 和 <code>getSecond()</code> 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 <code>a1</code> 和 <code>a2</code> 然后对它们执行任何操作，但无法对 <code>a1</code> 和 <code>a2</code> 重新赋值。例子中的 <code>final</code> 可以实现同样的效果，并且更为简洁明了。</p>
<p>另一种设计思路是允许元组的用户给 <code>a1</code> 和 <code>a2</code> 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 <code>Tuple2</code> 对象。</p>
<p>我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple3.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple3</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">Tuple2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C a3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple3</span><span class="params">(A a, B b, C c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b);</span><br><span class="line">        a3 = c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">", "</span> + a3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onjava/Tuple4.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Tuple3</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> D a4;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple4</span><span class="params">(A a, B b, C c, D d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b, c);</span><br><span class="line">        a4 = d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">", "</span> + a4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onjava/Tuple5.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple5</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>, <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> E a5;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple5</span><span class="params">(A a, B b, C c, D d, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b, c, d);</span><br><span class="line">        a5 = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">", "</span> + a5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示需要，再定义两个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Amphibian.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Amphibian</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/Vehicle.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用元组时，我们只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/TupleTest.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple2&lt;String, Integer&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 47 自动装箱为 Integer</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple3&lt;Amphibian, String, Integer&gt; <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple4&lt;Vehicle, Amphibian, String, Integer&gt; <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple4&lt;&gt;(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple5&lt;Vehicle, Amphibian, String, Integer, Double&gt; <span class="title">k</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple5&lt;&gt;(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>, <span class="number">11.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tuple2&lt;String, Integer&gt; ttsi = f();</span><br><span class="line">        System.out.println(ttsi);</span><br><span class="line">        <span class="comment">// ttsi.a1 = "there"; // 编译错误，因为 final 不能重新赋值</span></span><br><span class="line">        System.out.println(g());</span><br><span class="line">        System.out.println(h());</span><br><span class="line">        System.out.println(k());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment"> (hi, 47)</span></span><br><span class="line"><span class="comment"> (Amphibian@1540e19d, hi, 47)</span></span><br><span class="line"><span class="comment"> (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)</span></span><br><span class="line"><span class="comment"> (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>有了泛型，我们可以很容易地创建元组，令其返回一组任意类型的对象。</p>
<p>通过 <code>ttsi.a1 = &quot;there&quot;</code> 语句的报错，我们可以看出，<strong>final</strong> 声明确实可以确保 <strong>public</strong> 字段在对象被构造出来之后就不能重新赋值了。</p>
<p>在上面的程序中，<code>new</code> 表达式有些啰嗦。本章稍后会介绍，如何利用 <em>泛型方法</em> 简化它们。</p>
<h3 id="一个堆栈类"><a href="#一个堆栈类" class="headerlink" title="一个堆栈类"></a>一个堆栈类</h3><p>接下来我们看一个稍微复杂一点的例子：堆栈。在 <a href="book/12-Collections.md">集合</a> 一章中，我们用 <code>LinkedList</code> 实现了 <code>onjava.Stack</code> 类。在那个例子中，<code>LinkedList</code> 本身已经具备了创建堆栈所需的方法。<code>Stack</code> 是通过两个泛型类 <code>Stack&lt;T&gt;</code> 和 <code>LinkedList&lt;T&gt;</code> 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。</p>
<p>这次我们不用 <code>LinkedList</code> 来实现自己的内部链式存储机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/LinkedStack.java</span></span><br><span class="line"><span class="comment">// 用链式结构实现的堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">    </span><br><span class="line">        Node() &#123; item = <span class="keyword">null</span>; next = <span class="keyword">null</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        Node(U item, Node&lt;U&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top = <span class="keyword">new</span> Node&lt;&gt;();  <span class="comment">// 栈顶</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;&gt;(item, top);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span> (!top.end()) &#123;</span><br><span class="line">            top = top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; lss = <span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : <span class="string">"Phasers on stun!"</span>.split(<span class="string">" "</span>)) &#123;</span><br><span class="line">            lss.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = lss.pop()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stun!</span><br><span class="line">on</span><br><span class="line">Phasers</span><br></pre></td></tr></table></figure>

<p>内部类 <code>Node</code> 也是一个泛型，它拥有自己的类型参数。</p>
<p>这个例子使用了一个 <em>末端标识</em> (end sentinel) 来判断栈何时为空。这个末端标识是在构造 <code>LinkedStack</code> 时创建的。然后，每次调用 <code>push()</code> 就会创建一个 <code>Node&lt;T&gt;</code> 对象，并将其链接到前一个 <code>Node&lt;T&gt;</code> 对象。当我们调用 <code>pop()</code> 方法时，总是返回 <code>top.item</code>，然后丢弃当前 <code>top</code> 所指向的 <code>Node&lt;T&gt;</code>，并将 <code>top</code> 指向下一个 <code>Node&lt;T&gt;</code>，除非到达末端标识，这时就不能再移动 <code>top</code> 了。如果已经到达末端，程序还继续调用 <code>pop()</code> 方法，它只能得到 <code>null</code>，说明栈已经空了。</p>
<h3 id="RandomList"><a href="#RandomList" class="headerlink" title="RandomList"></a>RandomList</h3><p>作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 <code>select()</code> 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/RandomList.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(rand.nextInt(size()));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomList&lt;String&gt; rs = <span class="keyword">new</span> RandomList&lt;&gt;();</span><br><span class="line">        Arrays.stream(<span class="string">"The quick brown fox jumped over the lazy brown dog"</span>.split(<span class="string">" "</span>)).forEach(rs::add);</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">11</span>).forEach(i -&gt; </span><br><span class="line">            System.out.print(rs.select() + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brown over fox quick quick dog brown The brown lazy brown</span><br></pre></td></tr></table></figure>

<p><code>RandomList</code> 继承了 <code>ArrayList</code> 的所有方法。本例中只添加了 <code>select()</code> 这个方法。</p>
<!-- Generic Interfaces -->

<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型也可以应用于接口。例如 <em>生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法</em> 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。</p>
<p>一般而言，一个生成器只定义一个方法，用于创建对象。例如 <code>java.util.function</code> 类库中的 <code>Supplier</code> 就是一个生成器，调用其 <code>get()</code> 获取对象。<code>get()</code> 是泛型方法，返回值为类型参数 <code>T</code>。</p>
<p>为了演示 <code>Supplier</code>，我们需要定义几个类。下面是个咖啡相关的继承体系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/coffee/Coffee.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName() + <span class="string">" "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Latte.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Latte</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Mocha.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Cappuccino.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cappuccino</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Americano.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Americano</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Breve.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Breve</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以编写一个类，实现 <code>Supplier&lt;Coffee&gt;</code> 接口，它能够随机生成不同类型的 <code>Coffee</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/coffee/CoffeeSupplier.java</span></span><br><span class="line"><span class="comment">// &#123;java generics.coffee.CoffeeSupplier&#125;</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeSupplier</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Coffee</span>&gt;, <span class="title">Iterable</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] types = &#123; Latte.class, Mocha.class, </span><br><span class="line">        Cappuccino.class, Americano.class, Breve.class &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeSupplier</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// For iteration:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeSupplier</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123; size = sz; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Coffee) types[rand.nextInt(types.length)].newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CoffeeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = size;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count &gt; <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> CoffeeSupplier.<span class="keyword">this</span>.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Coffee&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CoffeeIterator();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(<span class="keyword">new</span> CoffeeSupplier())</span><br><span class="line">              .limit(<span class="number">5</span>)</span><br><span class="line">              .forEach(System.out::println);</span><br><span class="line">        <span class="keyword">for</span> (Coffee c : <span class="keyword">new</span> CoffeeSupplier(<span class="number">5</span>)) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Americano <span class="number">0</span></span><br><span class="line">Latte <span class="number">1</span></span><br><span class="line">Americano <span class="number">2</span></span><br><span class="line">Mocha <span class="number">3</span></span><br><span class="line">Mocha <span class="number">4</span></span><br><span class="line">Breve <span class="number">5</span></span><br><span class="line">Americano <span class="number">6</span></span><br><span class="line">Latte <span class="number">7</span></span><br><span class="line">Cappuccino <span class="number">8</span></span><br><span class="line">Cappuccino <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>参数化的 <code>Supplier</code> 接口确保 <code>get()</code> 返回值是参数的类型。<code>CoffeeSupplier</code> 同时还实现了 <code>Iterable</code> 接口，所以能用于 <em>for-in</em> 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。</p>
<p>下面是另一个实现 <code>Supplier&lt;T&gt;</code> 接口的例子，它负责生成 Fibonacci 数列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Fibonacci.java</span></span><br><span class="line"><span class="comment">// Generate a Fibonacci sequence</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> fib(count++); &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">2</span>) + fib(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(<span class="keyword">new</span> Fibonacci())</span><br><span class="line">              .limit(<span class="number">18</span>)</span><br><span class="line">              .map(n -&gt; n + <span class="string">" "</span>)</span><br><span class="line">              .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span> <span class="number">1597</span> <span class="number">2584</span></span><br></pre></td></tr></table></figure>

<p>虽然我们在 <code>Fibonacci</code> 类的里里外外使用的都是 <code>int</code> 类型，但是其参数类型却是 <code>Integer</code>。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 <code>Fibonacci</code> 类对 <code>int</code> 的使用，我们已经看到了这种效果。</p>
<p>如果还想更进一步，编写一个实现了 <code>Iterable</code> 的 <code>Fibnoacci</code> 生成器。我们的一个选择是重写这个类，令其实现 <code>Iterable</code> 接口。不过，我们并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 <em>适配器</em> (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。</p>
<p>有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/IterableFibonacci.java</span></span><br><span class="line"><span class="comment">// Adapt the Fibonacci class to make it Iterable</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterableFibonacci</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IterableFibonacci</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123; n = count; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n &gt; <span class="number">0</span>; &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                n--;</span><br><span class="line">                <span class="keyword">return</span> IterableFibonacci.<span class="keyword">this</span>.get();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="comment">// Not implemented</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : <span class="keyword">new</span> IterableFibonacci(<span class="number">18</span>))</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span> <span class="number">1597</span> <span class="number">2584</span></span><br></pre></td></tr></table></figure>

<p>在 <em>for-in</em> 语句中使用 <code>IterableFibonacci</code>，必须在构造函数中提供一个边界值，这样 <code>hasNext()</code> 才知道何时返回 <strong>false</strong>，结束循环。</p>
<!-- Generic Methods -->

<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。</p>
<p>泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。</p>
<p>如果方法是 <strong>static</strong> 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。</p>
<p>要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericMethods.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericMethods gm = <span class="keyword">new</span> GenericMethods();</span><br><span class="line">        gm.f(<span class="string">""</span>);</span><br><span class="line">        gm.f(<span class="number">1</span>);</span><br><span class="line">        gm.f(<span class="number">1.0</span>);</span><br><span class="line">        gm.f(<span class="number">1.0F</span>);</span><br><span class="line">        gm.f(<span class="string">'c'</span>);</span><br><span class="line">        gm.f(gm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">java.lang.String</span></span><br><span class="line"><span class="comment">java.lang.Integer</span></span><br><span class="line"><span class="comment">java.lang.Double</span></span><br><span class="line"><span class="comment">java.lang.Float</span></span><br><span class="line"><span class="comment">java.lang.Character</span></span><br><span class="line"><span class="comment">GenericMethods</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>尽管可以同时对类及其方法进行参数化，但这里未将 <strong>GenericMethods</strong> 类参数化。只有方法 <code>f()</code> 具有类型参数，该参数由方法返回类型之前的参数列表指示。</p>
<p>对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 <em>类型参数推断</em>。因此，对 <code>f()</code> 的调用看起来像普通的方法调用，并且 <code>f()</code> 看起来像被重载了无数次一样。它甚至会接受 <strong>GenericMethods</strong> 类型的参数。</p>
<p>如果使用基本类型调用 <code>f()</code> ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。</p>
<!-- Varargs and Generic Methods -->
<h3 id="变长参数和泛型方法"><a href="#变长参数和泛型方法" class="headerlink" title="变长参数和泛型方法"></a>变长参数和泛型方法</h3><p>泛型方法和变长参数列表可以很好地共存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericVarargs.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargs</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T item : args)</span><br><span class="line">            result.add(item);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ls = makeList(<span class="string">"A"</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(</span><br><span class="line">                <span class="string">"ABCDEFFHIJKLMNOPQRSTUVWXYZ"</span>.split(<span class="string">""</span>));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[A]</span></span><br><span class="line"><span class="comment">[A, B, C]</span></span><br><span class="line"><span class="comment">[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,</span></span><br><span class="line"><span class="comment">S, T, U, V, W, X, Y, Z]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>此处显示的 <code>makeList()</code> 方法产生的功能与标准库的 <code>java.util.Arrays.asList()</code> 方法相同。</p>
<p><code>@SafeVarargs</code> 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。</p>
<!-- A General-Purpose Supplier -->
<h3 id="一个泛型的-Supplier"><a href="#一个泛型的-Supplier" class="headerlink" title="一个泛型的 Supplier"></a>一个泛型的 Supplier</h3><p>这是一个为任意具有无参构造方法的类生成 <strong>Supplier</strong> 的类。为了减少键入，它还包括一个用于生成 <strong>BasicSupplier</strong> 的泛型方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/BasicSupplier.java</span></span><br><span class="line"><span class="comment">// Supplier from a class with a no-arg constructor</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSupplier</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicSupplier</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Assumes type is a public class:</span></span><br><span class="line">            <span class="keyword">return</span> type.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException |</span><br><span class="line">                IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Produce a default Supplier from a type token:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Supplier&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicSupplier&lt;&gt;(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此类提供了产生以下对象的基本实现：</p>
<ol>
<li><p>是 <strong>public</strong> 的。 因为 <strong>BasicSupplier</strong> 在单独的包中，所以相关的类必须具有 <strong>public</strong> 权限，而不仅仅是包级访问权限。</p>
</li>
<li><p>具有无参构造方法。要创建一个这样的 <strong>BasicSupplier</strong> 对象，请调用 <code>create()</code> 方法，并将要生成类型的类型令牌传递给它。通用的 <code>create()</code> 方法提供了 <code>BasicSupplier.create(MyType.class)</code> 这种较简洁的语法来代替较笨拙的 <code>new BasicSupplier &lt;MyType&gt;(MyType.class)</code>。</p>
</li>
</ol>
<p>例如，这是一个具有无参构造方法的简单类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CountedObject.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountedObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CountedObject "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CountedObject</strong> 类可以跟踪自身创建了多少个实例，并通过 <code>toString()</code> 报告这些实例的数量。 <strong>BasicSupplier</strong> 可以轻松地为 <strong>CountedObject</strong> 创建 <strong>Supplier</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// generics/BasicSupplierDemo.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.BasicSupplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSupplierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(</span><br><span class="line">                BasicSupplier.create(CountedObject.class))</span><br><span class="line">                .limit(<span class="number">5</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">CountedObject 0</span></span><br><span class="line"><span class="comment">CountedObject 1</span></span><br><span class="line"><span class="comment">CountedObject 2</span></span><br><span class="line"><span class="comment">CountedObject 3</span></span><br><span class="line"><span class="comment">CountedObject 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>泛型方法减少了产生 <strong>Supplier</strong> 对象所需的代码量。 Java 泛型强制传递 <strong>Class</strong> 对象，以便在 <code>create()</code> 方法中将其用于类型推断。</p>
<!-- Simplifying Tuple Use -->
<h3 id="简化元组的使用"><a href="#简化元组的使用" class="headerlink" title="简化元组的使用"></a>简化元组的使用</h3><p>使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库。在这里，我们使用重载的静态方法创建元组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple.java</span></span><br><span class="line"><span class="comment">// Tuple library using type argument inference</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B&gt; <span class="function">Tuple2&lt;A, B&gt; <span class="title">tuple</span><span class="params">(A a, B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B, C&gt; Tuple3&lt;A, B, C&gt;</span><br><span class="line">    tuple(A a, B b, C c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple3&lt;&gt;(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B, C, D&gt; Tuple4&lt;A, B, C, D&gt;</span><br><span class="line">    tuple(A a, B b, C c, D d) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple4&lt;&gt;(a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B, C, D, E&gt;</span><br><span class="line">    <span class="function">Tuple5&lt;A, B, C, D, E&gt; <span class="title">tuple</span><span class="params">(A a, B b, C c, D d, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple5&lt;&gt;(a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们修改 <strong>TupleTest.java</strong> 来测试 <strong>Tuple.java</strong> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/TupleTest2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Tuple2;</span><br><span class="line"><span class="keyword">import</span> onjava.Tuple3;</span><br><span class="line"><span class="keyword">import</span> onjava.Tuple4;</span><br><span class="line"><span class="keyword">import</span> onjava.Tuple5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.Tuple.tuple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple2&lt;String, Integer&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(<span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple2 <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(<span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple3&lt;Amphibian, String, Integer&gt; <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(<span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple4&lt;Vehicle, Amphibian, String, Integer&gt; <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(</span><br><span class="line">                <span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Tuple5&lt;Vehicle, Amphibian,</span><br><span class="line">            String, Integer, Double&gt; k() &#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(),</span><br><span class="line">                <span class="string">"hi"</span>, <span class="number">47</span>, <span class="number">11.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tuple2&lt;String, Integer&gt; ttsi = f();</span><br><span class="line">        System.out.println(ttsi);</span><br><span class="line">        System.out.println(f2());</span><br><span class="line">        System.out.println(g());</span><br><span class="line">        System.out.println(h());</span><br><span class="line">        System.out.println(k());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">(hi, 47)</span></span><br><span class="line"><span class="comment">(hi, 47)</span></span><br><span class="line"><span class="comment">(Amphibian@14ae5a5, hi, 47)</span></span><br><span class="line"><span class="comment">(Vehicle@135fbaa4, Amphibian@45ee12a7, hi, 47)</span></span><br><span class="line"><span class="comment">(Vehicle@4b67cf4d, Amphibian@7ea987ac, hi, 47, 11.1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>请注意，<code>f()</code> 返回一个参数化的 <strong>Tuple2</strong> 对象，而 <code>f2()</code> 返回一个未参数化的 <strong>Tuple2</strong> 对象。编译器不会在这里警告 <code>f2()</code> ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 <strong>Tuple2</strong> 。 但是，如果尝试将 <code>f2()</code> 的结果放入到参数化的 <strong>Tuple2</strong> 中，则编译器将发出警告。</p>
<!-- A Set Utility -->
<h3 id="一个-Set-工具"><a href="#一个-Set-工具" class="headerlink" title="一个 Set 工具"></a>一个 Set 工具</h3><p>对于泛型方法的另一个示例，请考虑由 <strong>Set</strong> 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Sets.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">union</span><span class="params">(Set&lt;T&gt; a, Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.addAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    <span class="function">Set&lt;T&gt; <span class="title">intersection</span><span class="params">(Set&lt;T&gt; a, Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.retainAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subtract subset from superset:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt;</span><br><span class="line">    difference(Set&lt;T&gt; superset, Set&lt;T&gt; subset) &#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(superset);</span><br><span class="line">        result.removeAll(subset);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reflexive--everything not in the intersection:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">complement</span><span class="params">(Set&lt;T&gt; a, Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> difference(union(a, b), intersection(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前三个方法通过将第一个参数的引用复制到新的 <strong>HashSet</strong> 对象中来复制第一个参数，因此不会直接修改参数集合。因此，返回值是一个新的 <strong>Set</strong> 对象。</p>
<p>这四种方法代表数学集合操作： <code>union()</code> 返回一个包含两个参数并集的 <strong>Set</strong> ， <code>intersection()</code> 返回一个包含两个参数集合交集的 <strong>Set</strong> ， <code>difference()</code> 从 <strong>superset</strong> 中减去 <strong>subset</strong> 的元素 ，而 <code>complement()</code> 返回所有不在交集中的元素的 <strong>Set</strong>。作为显示这些方法效果的简单示例的一部分，下面是一个包含不同水彩名称的 <strong>enum</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/watercolors/Watercolors.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> watercolors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Watercolors &#123;</span><br><span class="line">    ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW,</span><br><span class="line">    ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA,</span><br><span class="line">    ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE,</span><br><span class="line">    PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE,</span><br><span class="line">    PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN,</span><br><span class="line">    YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,</span><br><span class="line">    BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便起见（不必全限定所有名称），将其静态导入到以下示例中。本示例使用 <strong>EnumSet</strong> 轻松从 <strong>enum</strong> 中创建 <strong>Set</strong> 。（可以在<a href="book/22-Enumerations.md">第二十二章 枚举</a>一章中了解有关 <strong>EnumSet</strong> 的更多信息。）在这里，静态方法 <code>EnumSet.range()</code> 要求提供所要在结果 <strong>Set</strong> 中创建的元素范围的第一个和最后一个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/WatercolorSets.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> watercolors.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> watercolors.Watercolors.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.Sets.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatercolorSets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Watercolors&gt; set1 =</span><br><span class="line">                EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE);</span><br><span class="line">        Set&lt;Watercolors&gt; set2 =</span><br><span class="line">                EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);</span><br><span class="line">        System.out.println(<span class="string">"set1: "</span> + set1);</span><br><span class="line">        System.out.println(<span class="string">"set2: "</span> + set2);</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"union(set1, set2): "</span> + union(set1, set2));</span><br><span class="line">        Set&lt;Watercolors&gt; subset = intersection(set1, set2);</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"intersection(set1, set2): "</span> + subset);</span><br><span class="line">        System.out.println(<span class="string">"difference(set1, subset): "</span> +</span><br><span class="line">                difference(set1, subset));</span><br><span class="line">        System.out.println(<span class="string">"difference(set2, subset): "</span> +</span><br><span class="line">                difference(set2, subset));</span><br><span class="line">        System.out.println(<span class="string">"complement(set1, set2): "</span> +</span><br><span class="line">                complement(set1, set2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER,</span></span><br><span class="line"><span class="comment">VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,</span></span><br><span class="line"><span class="comment">COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE]</span></span><br><span class="line"><span class="comment">set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,</span></span><br><span class="line"><span class="comment">COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE,</span></span><br><span class="line"><span class="comment">SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,</span></span><br><span class="line"><span class="comment">BURNT_UMBER]</span></span><br><span class="line"><span class="comment">union(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,</span></span><br><span class="line"><span class="comment">YELLOW_OCHRE, MAGENTA, SAP_GREEN, CERULEAN_BLUE_HUE,</span></span><br><span class="line"><span class="comment">ULTRAMARINE, VIRIDIAN_HUE, VIOLET, RAW_UMBER,</span></span><br><span class="line"><span class="comment">ROSE_MADDER, PERMANENT_GREEN, BURNT_UMBER,</span></span><br><span class="line"><span class="comment">PHTHALO_BLUE, CRIMSON, COBALT_BLUE_HUE]</span></span><br><span class="line"><span class="comment">intersection(set1, set2): [PERMANENT_GREEN,</span></span><br><span class="line"><span class="comment">CERULEAN_BLUE_HUE, ULTRAMARINE, VIRIDIAN_HUE,</span></span><br><span class="line"><span class="comment">PHTHALO_BLUE, COBALT_BLUE_HUE]</span></span><br><span class="line"><span class="comment">difference(set1, subset): [BRILLIANT_RED, MAGENTA,</span></span><br><span class="line"><span class="comment">VIOLET, CRIMSON, ROSE_MADDER]</span></span><br><span class="line"><span class="comment">difference(set2, subset): [BURNT_SIENNA, YELLOW_OCHRE,</span></span><br><span class="line"><span class="comment">BURNT_UMBER, SAP_GREEN, RAW_UMBER]</span></span><br><span class="line"><span class="comment">complement(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,</span></span><br><span class="line"><span class="comment">YELLOW_OCHRE, MAGENTA, SAP_GREEN, VIOLET, RAW_UMBER,</span></span><br><span class="line"><span class="comment">ROSE_MADDER, BURNT_UMBER, CRIMSON]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>接下来的例子使用 <code>Sets.difference()</code> 方法来展示 <strong>java.util</strong> 包中各种 <strong>Collection</strong> 和 <strong>Map</strong> 类之间的方法差异：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/CollectionMethodDifferences.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.CollectionMethodDifferences&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionMethodDifferences</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Set&lt;String&gt; <span class="title">methodSet</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(type.getMethods())</span><br><span class="line">                .map(Method::getName)</span><br><span class="line">                .collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">interfaces</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Interfaces in "</span> +</span><br><span class="line">                type.getSimpleName() + <span class="string">": "</span>);</span><br><span class="line">        System.out.println(</span><br><span class="line">                Arrays.stream(type.getInterfaces())</span><br><span class="line">                        .map(Class::getSimpleName)</span><br><span class="line">                        .collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Set&lt;String&gt; object = methodSet(Object.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        object.add(<span class="string">"clone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    difference(Class&lt;?&gt; superset, Class&lt;?&gt; subset) &#123;</span><br><span class="line">        System.out.print(superset.getSimpleName() +</span><br><span class="line">                <span class="string">" extends "</span> + subset.getSimpleName() +</span><br><span class="line">                <span class="string">", adds: "</span>);</span><br><span class="line">        Set&lt;String&gt; comp = Sets.difference(</span><br><span class="line">                methodSet(superset), methodSet(subset));</span><br><span class="line">        comp.removeAll(object); <span class="comment">// Ignore 'Object' methods</span></span><br><span class="line">        System.out.println(comp);</span><br><span class="line">        interfaces(superset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Collection: "</span> +</span><br><span class="line">                methodSet(Collection.class));</span><br><span class="line">        interfaces(Collection.class);</span><br><span class="line">        difference(Set.class, Collection.class);</span><br><span class="line">        difference(HashSet.class, Set.class);</span><br><span class="line">        difference(LinkedHashSet.class, HashSet.class);</span><br><span class="line">        difference(TreeSet.class, Set.class);</span><br><span class="line">        difference(List.class, Collection.class);</span><br><span class="line">        difference(ArrayList.class, List.class);</span><br><span class="line">        difference(LinkedList.class, List.class);</span><br><span class="line">        difference(Queue.class, Collection.class);</span><br><span class="line">        difference(PriorityQueue.class, Queue.class);</span><br><span class="line">        System.out.println(<span class="string">"Map: "</span> + methodSet(Map.class));</span><br><span class="line">        difference(HashMap.class, Map.class);</span><br><span class="line">        difference(LinkedHashMap.class, HashMap.class);</span><br><span class="line">        difference(SortedMap.class, Map.class);</span><br><span class="line">        difference(TreeMap.class, Map.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Collection: [add, addAll, clear, contains, containsAll,</span></span><br><span class="line"><span class="comment">equals, forEach, hashCode, isEmpty, iterator,</span></span><br><span class="line"><span class="comment">parallelStream, remove, removeAll, removeIf, retainAll,</span></span><br><span class="line"><span class="comment">size, spliterator, stream, toArray]</span></span><br><span class="line"><span class="comment">Interfaces in Collection: [Iterable]</span></span><br><span class="line"><span class="comment">Set extends Collection, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in Set: [Collection]</span></span><br><span class="line"><span class="comment">HashSet extends Set, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in HashSet: [Set, Cloneable, Serializable]</span></span><br><span class="line"><span class="comment">LinkedHashSet extends HashSet, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in LinkedHashSet: [Set, Cloneable,</span></span><br><span class="line"><span class="comment">Serializable]</span></span><br><span class="line"><span class="comment">TreeSet extends Set, adds: [headSet,</span></span><br><span class="line"><span class="comment">descendingIterator, descendingSet, pollLast, subSet,</span></span><br><span class="line"><span class="comment">floor, tailSet, ceiling, last, lower, comparator,</span></span><br><span class="line"><span class="comment">pollFirst, first, higher]</span></span><br><span class="line"><span class="comment">Interfaces in TreeSet: [NavigableSet, Cloneable,</span></span><br><span class="line"><span class="comment">Serializable]</span></span><br><span class="line"><span class="comment">List extends Collection, adds: [replaceAll, get,</span></span><br><span class="line"><span class="comment">indexOf, subList, set, sort, lastIndexOf, listIterator]</span></span><br><span class="line"><span class="comment">Interfaces in List: [Collection]</span></span><br><span class="line"><span class="comment">ArrayList extends List, adds: [trimToSize,</span></span><br><span class="line"><span class="comment">ensureCapacity]</span></span><br><span class="line"><span class="comment">Interfaces in ArrayList: [List, RandomAccess,</span></span><br><span class="line"><span class="comment">Cloneable, Serializable]</span></span><br><span class="line"><span class="comment">LinkedList extends List, adds: [offerFirst, poll,</span></span><br><span class="line"><span class="comment">getLast, offer, getFirst, removeFirst, element,</span></span><br><span class="line"><span class="comment">removeLastOccurrence, peekFirst, peekLast, push,</span></span><br><span class="line"><span class="comment">pollFirst, removeFirstOccurrence, descendingIterator,</span></span><br><span class="line"><span class="comment">pollLast, removeLast, pop, addLast, peek, offerLast,</span></span><br><span class="line"><span class="comment">addFirst]</span></span><br><span class="line"><span class="comment">Interfaces in LinkedList: [List, Deque, Cloneable,</span></span><br><span class="line"><span class="comment">Serializable]</span></span><br><span class="line"><span class="comment">Queue extends Collection, adds: [poll, peek, offer,</span></span><br><span class="line"><span class="comment">element]</span></span><br><span class="line"><span class="comment">Interfaces in Queue: [Collection]</span></span><br><span class="line"><span class="comment">PriorityQueue extends Queue, adds: [comparator]</span></span><br><span class="line"><span class="comment">Interfaces in PriorityQueue: [Serializable]</span></span><br><span class="line"><span class="comment">Map: [clear, compute, computeIfAbsent,</span></span><br><span class="line"><span class="comment">computeIfPresent, containsKey, containsValue, entrySet,</span></span><br><span class="line"><span class="comment">equals, forEach, get, getOrDefault, hashCode, isEmpty,</span></span><br><span class="line"><span class="comment">keySet, merge, put, putAll, putIfAbsent, remove,</span></span><br><span class="line"><span class="comment">replace, replaceAll, size, values]</span></span><br><span class="line"><span class="comment">HashMap extends Map, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in HashMap: [Map, Cloneable, Serializable]</span></span><br><span class="line"><span class="comment">LinkedHashMap extends HashMap, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in LinkedHashMap: [Map]</span></span><br><span class="line"><span class="comment">SortedMap extends Map, adds: [lastKey, subMap,</span></span><br><span class="line"><span class="comment">comparator, firstKey, headMap, tailMap]</span></span><br><span class="line"><span class="comment">Interfaces in SortedMap: [Map]</span></span><br><span class="line"><span class="comment">TreeMap extends Map, adds: [descendingKeySet,</span></span><br><span class="line"><span class="comment">navigableKeySet, higherEntry, higherKey, floorKey,</span></span><br><span class="line"><span class="comment">subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,</span></span><br><span class="line"><span class="comment">headMap, tailMap, lowerEntry, ceilingEntry,</span></span><br><span class="line"><span class="comment">descendingMap, pollFirstEntry, lastKey, firstEntry,</span></span><br><span class="line"><span class="comment">floorEntry, comparator, lastEntry]</span></span><br><span class="line"><span class="comment">Interfaces in TreeMap: [NavigableMap, Cloneable,</span></span><br><span class="line"><span class="comment">Serializable]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在第十二章 <a href="book/12-Collections.md#本章小结">集合的本章小结</a> 部分将会用到这里的输出结果。</p>
<!-- Building Complex Models -->

<h2 id="构建复杂模型"><a href="#构建复杂模型" class="headerlink" title="构建复杂模型"></a>构建复杂模型</h2><p>泛型的一个重要好处是能够简单安全地创建复杂模型。例如，我们可以轻松地创建一个元组列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/TupleList.java</span></span><br><span class="line"><span class="comment">// Combining generic types to make complex generic types</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Tuple4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleList</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TupleList&lt;Vehicle, Amphibian, String, Integer&gt; tl =</span><br><span class="line">                <span class="keyword">new</span> TupleList&lt;&gt;();</span><br><span class="line">        tl.add(TupleTest2.h());</span><br><span class="line">        tl.add(TupleTest2.h());</span><br><span class="line">        tl.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">(Vehicle@7cca494b, Amphibian@7ba4f24f, hi, 47)</span></span><br><span class="line"><span class="comment">(Vehicle@3b9a45b3, Amphibian@7699a589, hi, 47)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这将产生一个功能强大的数据结构，而无需太多代码。</p>
<p>下面是第二个例子。每个类都是组成块，总体包含很多个块。在这里，该模型是一个具有过道，货架和产品的零售商店：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Store.java</span></span><br><span class="line"><span class="comment">// Building a complex model using generic collections</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Suppliers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    Product(<span class="keyword">int</span> idNumber, String descr, <span class="keyword">double</span> price) &#123;</span><br><span class="line">        id = idNumber;</span><br><span class="line">        description = descr;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        System.out.println(toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id + <span class="string">": "</span> + description +</span><br><span class="line">                <span class="string">", price: $"</span> + price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">priceChange</span><span class="params">(<span class="keyword">double</span> change)</span> </span>&#123;</span><br><span class="line">        price += change;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Supplier&lt;Product&gt; generator =</span><br><span class="line">            <span class="keyword">new</span> Supplier&lt;Product&gt;() &#123;</span><br><span class="line">                <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Product <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Product(rand.nextInt(<span class="number">1000</span>), <span class="string">"Test"</span>,</span><br><span class="line">                            Math.round(</span><br><span class="line">                                    rand.nextDouble() * <span class="number">1000.0</span>) + <span class="number">0.99</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shelf</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Product</span>&gt; </span>&#123;</span><br><span class="line">    Shelf(<span class="keyword">int</span> nProducts) &#123;</span><br><span class="line">        Suppliers.fill(<span class="keyword">this</span>, Product.generator, nProducts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aisle</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Shelf</span>&gt; </span>&#123;</span><br><span class="line">    Aisle(<span class="keyword">int</span> nShelves, <span class="keyword">int</span> nProducts) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nShelves; i++)</span><br><span class="line">            add(<span class="keyword">new</span> Shelf(nProducts));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckoutStand</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Office</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Aisle</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;CheckoutStand&gt; checkouts =</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Office office = <span class="keyword">new</span> Office();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Store</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> nAisles, <span class="keyword">int</span> nShelves, <span class="keyword">int</span> nProducts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nAisles; i++)</span><br><span class="line">            add(<span class="keyword">new</span> Aisle(nShelves, nProducts));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Aisle a : <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">for</span> (Shelf s : a)</span><br><span class="line">                <span class="keyword">for</span> (Product p : s) &#123;</span><br><span class="line">                    result.append(p);</span><br><span class="line">                    result.append(<span class="string">"\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Store(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: (First 8 Lines)</span></span><br><span class="line"><span class="comment">258: Test, price: $400.99</span></span><br><span class="line"><span class="comment">861: Test, price: $160.99</span></span><br><span class="line"><span class="comment">868: Test, price: $417.99</span></span><br><span class="line"><span class="comment">207: Test, price: $268.99</span></span><br><span class="line"><span class="comment">551: Test, price: $114.99</span></span><br><span class="line"><span class="comment">278: Test, price: $804.99</span></span><br><span class="line"><span class="comment">520: Test, price: $554.99</span></span><br><span class="line"><span class="comment">140: Test, price: $530.99</span></span><br><span class="line"><span class="comment">                  ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>Store.toString()</code> 显示了结果：尽管有复杂的层次结构，但多层的集合仍然是类型安全的和可管理的。令人印象深刻的是，组装这样的模型并不需要耗费过多精力。</p>
<p><strong>Shelf</strong> 使用 <code>Suppliers.fill()</code> 这个实用程序，该实用程序接受 <strong>Collection</strong> （第一个参数），并使用 <strong>Supplier</strong> （第二个参数），以元素的数量为 <strong>n</strong> （第三个参数）来填充它。 <strong>Suppliers</strong> 类将会在本章末尾定义，其中的方法都是在执行某种填充操作，并在本章的其他示例中使用。</p>
<!-- The Mystery of Erasure -->
<h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>当我们开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以说  <code>ArrayList.class</code>，但不能说成 <code>ArrayList&lt;Integer&gt;.class</code>。考虑下面的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ErasedTypeEquivalence.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>ArrayList&lt;String&gt;</code> 和 <code>ArrayList&lt;Integer&gt;</code> 应该是不同的类型。不同的类型会有不同的行为。例如，如果尝试向 <code>ArrayList&lt;String&gt;</code> 中放入一个 <code>Integer</code>，所得到的行为（失败）和向 <code>ArrayList&lt;Integer&gt;</code> 中放入一个 <code>Integer</code> 所得到的行为（成功）完全不同。然而上面的程序认为它们是相同的类型。</p>
<p>下面的例子是对该谜题的补充：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/LostInformation.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frob</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fnorkle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quark</span>&lt;<span class="title">Q</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Particle</span>&lt;<span class="title">POSITION</span>, <span class="title">MOMENTUM</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LostInformation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Frob&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Frob, Fnorkle&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Quark&lt;Fnorkle&gt; quark = <span class="keyword">new</span> Quark&lt;&gt;();</span><br><span class="line">        Particle&lt;Long, Double&gt; p = <span class="keyword">new</span> Particle&lt;&gt;();</span><br><span class="line">        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[E]</span></span><br><span class="line"><span class="comment">[K,V]</span></span><br><span class="line"><span class="comment">[Q]</span></span><br><span class="line"><span class="comment">[POSITION,MOMENTUM]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>根据 JDK 文档，<strong>Class.getTypeParameters()</strong> “返回一个 <strong>TypeVariable</strong> 对象数组，表示泛型声明中声明的类型参数…” 这暗示我们可以发现这些参数类型。但是正如上例中输出所示，我们只能看到用作参数占位符的标识符，这并非有用的信息。</p>
<p>残酷的现实是：</p>
<p>在泛型代码内部，无法获取任何有关泛型参数类型的信息。</p>
<p>因此，我们可以知道如类型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。如果我们曾是 C++ 程序员，那么这个事实会让我们很沮丧，在使用 Java 泛型工作时，它是必须处理的最基本的问题。</p>
<p>Java 泛型是使用擦除实现的。这意味着当我们在使用泛型时，任何具体的类型信息都被擦除了，我们唯一知道的就是我们在使用一个对象。因此，<code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在运行时实际上是相同的类型。它们都被擦除成原生类型 <code>List</code>。</p>
<p>理解擦除并知道如何处理它，是我们在学习 Java 泛型时面临的最大障碍之一。这也是本节将要探讨的内容。</p>
<h3 id="C-的方式"><a href="#C-的方式" class="headerlink" title="C++ 的方式"></a>C++ 的方式</h3><p>下面是使用模版的 C++ 示例。我们会看到类型参数的语法十分相似，因为 Java 是受 C++ 启发的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Templates.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Manipulator</span> &#123;</span></span><br><span class="line">    T obj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Manipulator(T x) &#123; obj = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123; obj.f(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"HasF::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HasF hf;</span><br><span class="line">    Manipulator&lt;HasF&gt; manipulator(hf);</span><br><span class="line">    manipulator.manipulate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">HasF::f()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>Manipulator</strong> 类存储了一个 <strong>T</strong> 类型的对象。<code>manipulate()</code> 方法会调用 <strong>obj</strong> 上的 <code>f()</code> 方法。它是如何知道类型参数 <strong>T</strong> 中存在 <code>f()</code> 方法的呢？C++ 编译器会在我们实例化模版时进行检查，所以在 <code>Manipulator&lt;HasF&gt;</code> 实例化的那一刻，它看到 <strong>HasF</strong> 中含有一个方法 <code>f()</code>。如果情况并非如此，我们就会得到一个编译期错误，保持类型安全。</p>
<p>用 C++ 编写这种代码很简单，因为当模版被实例化时，模版代码就知道模版参数的类型。Java 泛型就不同了。下面是 <strong>HasF</strong> 的 Java 版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/HasF.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HasF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HasF.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们将示例的其余代码用 Java 实现，就不会通过编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Manipulation.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    </span><br><span class="line">    Manipulator(T x) &#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Error: cannot find symbol: method f():</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulation</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HasF hf = <span class="keyword">new</span> HasF();</span><br><span class="line">        Manipulator&lt;HasF&gt; manipulator = <span class="keyword">new</span> Manipulator&lt;&gt;(hf);</span><br><span class="line">        manipulator.manipulate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为擦除，Java 编译器无法将 <code>manipulate()</code> 方法必须能调用 <strong>obj</strong> 的 <code>f()</code> 方法这一需求映射到 HasF 具有 <code>f()</code> 方法这个事实上。为了调用 <code>f()</code>，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 <strong>extends</strong> 关键字。由于有了边界，下面的代码就能通过编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulator2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">    Manipulator2(T x) &#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>边界 <code>&lt;T extends HasF&gt;</code> 声明 T 必须是 HasF 类型或其子类。如果情况确实如此，就可以安全地在 <strong>obj</strong> 上调用 <code>f()</code> 方法。</p>
<p>我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后我们将看到）。我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例，<strong>T</strong> 擦除到了 <strong>HasF</strong>，就像在类的声明中用 <strong>HasF</strong> 替换了 <strong>T</strong> 一样。</p>
<p>我们可能正确地观察到了泛型在 <strong>Manipulator2.java</strong> 中没有贡献任何事。我们可以很轻松地自己去执行擦除，生成没有泛型的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Manipulator3.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HasF obj;</span><br><span class="line">    </span><br><span class="line">    Manipulator3(HasF x) &#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 <code>&lt;T extends HasF&gt;</code> 形式就是有缺陷的。例如，如果某个类有一个返回 <strong>T</strong> 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ReturnGenericType.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnGenericType</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    </span><br><span class="line">    ReturnGenericType(T x) &#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。</p>
<p>我们将在本章稍后看到有关边界的更多细节。</p>
<h3 id="迁移兼容性"><a href="#迁移兼容性" class="headerlink" title="迁移兼容性"></a>迁移兼容性</h3><p>为了减少潜在的关于擦除的困惑，我们必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使我们痛苦，因此我们需要尽早习惯它并了解为什么它会这样。</p>
<p>如果 Java 1.0 就含有泛型的话，那么这个特性就不会使用擦除来实现——它会使用具体化，保持参数类型为第一类实体，因此我们就能在类型参数上执行基于类型的语言操作和反射操作。本章稍后我们会看到，擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。</p>
<p>在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如， <code>List&lt;T&gt;</code> 这样的类型注解会被擦除为 <strong>List</strong>，普通的类型变量在未指定边界的情况下会被擦除为 <strong>Object</strong>。</p>
<p>擦除的核心动机是我们可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。在理想情况下，所有事物将在指定的某天被泛化。在现实中，即使程序员只编写泛型代码，他们也必须处理 Java 5 之前编写的非泛型类库。这些类库的作者可能从没想过要泛化他们的代码，或许他们可能刚刚开始接触泛型。</p>
<p>因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。在确定了这个目标后，Java 设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方案。擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。</p>
<p>例如，假设一个应用使用了两个类库 <strong>X</strong> 和 <strong>Y</strong>，<strong>Y</strong> 使用了类库 <strong>Z</strong>。随着 Java 5 的出现，这个应用和这些类库的创建者最终可能希望迁移到泛型上。但是当进行迁移时，它们有着不同的动机和限制。为了实现迁移兼容性，每个类库与应用必须与其他所有的部分是否使用泛型无关。因此，它们不能探测其他类库是否使用了泛型。因此，某个特定的类库使用了泛型这样的证据必须被”擦除“。</p>
<p>如果没有某种类型的迁移途径，所有已经构建了很长时间的类库就需要与希望迁移到 Java 泛型上的开发者们说再见了。类库毫无争议是编程语言的一部分，对生产效率有着极大的影响，所以这种代码无法接受。擦除是否是最佳的或唯一的迁移途径，还待时间来证明。</p>
<h3 id="擦除的问题"><a href="#擦除的问题" class="headerlink" title="擦除的问题"></a>擦除的问题</h3><p>因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许我们继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。</p>
<p>擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、<strong>instanceof</strong> 操作和 <strong>new</strong> 表达式。因为所有关于参数的类型信息都丢失了，当我们在编写泛型代码时，必须时刻提醒自己，我们只是看起来拥有有关参数的类型信息而已。</p>
<p>考虑如下的代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上去当我们创建一个 <strong>Foo</strong> 实例时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;Cat&gt; f = <span class="keyword">new</span> Foo&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>class</strong> <strong>Foo</strong> 中的代码应该知道现在工作于 <strong>Cat</strong> 之上。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当我们在编写这个类的代码时，必须提醒自己：“不，这只是一个 <strong>Object</strong>“。</p>
<p>另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管我们可能希望这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ErasureAndInheritance.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericBase</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T element;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        element = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">GenericBase</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> <span class="keyword">extends</span> <span class="title">GenericBase</span> </span>&#123;&#125; <span class="comment">// No warning</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class Derived3 extends GenericBase&lt;?&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">// Strange error:</span></span><br><span class="line"><span class="comment">// unexpected type</span></span><br><span class="line"><span class="comment">// required: class or interface without bounds</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasureAndInteritance</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Derived2 d2 = <span class="keyword">new</span> Derived2();</span><br><span class="line">        Object obj = d2.get();</span><br><span class="line">        d2.set(obj); <span class="comment">// Warning here!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Derived2</strong> 继承自 <strong>GenericBase</strong>，但是没有任何类型参数，编译器没有发出任何警告。直到调用 <code>set()</code> 方法时才出现警告。</p>
<p>为了关闭警告，Java 提供了一个注解，我们可以在列表中看到它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br></pre></td></tr></table></figure>

<p>这个注解放置在产生警告的方法上，而不是整个类上。当我们要关闭警告时，最好尽可能地“聚焦”，这样就不会因为过于宽泛地关闭警告，而导致意外地遮蔽掉真正的问题。</p>
<p>可以推断，<strong>Derived3</strong> 产生的错误意味着编译器期望得到一个原生基类。</p>
<p>当我们希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界，并且与在 C++、Ada 和 Eiffel 这样的语言中获得参数化类型相比，我们需要付出多得多的努力来获得少得多的回报。这并不是说，对于大多数的编程问题而言，这些语言通常都会比 Java 更得心应手，只是说它们的参数化类型机制相比 Java 更灵活、更强大。</p>
<h3 id="边界处的动作"><a href="#边界处的动作" class="headerlink" title="边界处的动作"></a>边界处的动作</h3><p>因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ArrayMaker.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayMaker</span><span class="params">(Class&lt;T&gt; kind)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    T[] create(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) Array.newInstance(kind, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayMaker&lt;String&gt; stringMaker = <span class="keyword">new</span> ArrayMaker&lt;&gt;(String.class);</span><br><span class="line">        String[] stringArray = stringMaker.create(<span class="number">9</span>);</span><br><span class="line">        System.out.println(Arrays.toString(stringArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">[null,null,null,null,null,null,null,null,null]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>即使 <strong>kind</strong> 被存储为 <code>Class&lt;T&gt;</code>，擦除也意味着它实际被存储为没有任何参数的 <strong>Class</strong>。因此，当我们在使用它时，例如创建数组，<code>Array.newInstance()</code> 实际上并未拥有 <strong>kind</strong> 所蕴含的类型信息。所以它不会产生具体的结果，因而必须转型，这会产生一条令我们无法满意的警告。</p>
<p>注意，对于在泛型中创建数组，使用 <code>Array.newInstance()</code> 是推荐的方式。</p>
<p>如果我们创建一个集合而不是数组，情况就不同了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ListMaker.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListMaker&lt;String&gt; stringMaker = <span class="keyword">new</span> ListMaker&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; stringList = stringMaker.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器不会给出任何警告，尽管我们知道（从擦除中）在 <code>create()</code> 内部的 <code>new ArrayList&lt;&gt;()</code> 中的 <code>&lt;T&gt;</code> 被移除了——在运行时，类内部没有任何 <code>&lt;T&gt;</code>，因此这看起来毫无意义。但是如果我们遵从这种思路，并将这个表达式改为 <code>new ArrayList()</code>，编译器就会发出警告。</p>
<p>本例中这么做真的毫无意义吗？如果在创建 <strong>List</strong> 的同时向其中放入一些对象呢，像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/FilledList.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    FilledList(Supplier&lt;T&gt; gen, <span class="keyword">int</span> size) &#123;</span><br><span class="line">        Suppliers.fill(<span class="keyword">this</span>, gen, size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FilledList</span><span class="params">(T t, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> FilledList&lt;&gt;(<span class="string">"Hello"</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// Supplier version:</span></span><br><span class="line">        List&lt;Integer&gt; ilist = <span class="keyword">new</span> FilledList&lt;&gt;(() -&gt; <span class="number">47</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(ilist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Hello,Hello,Hello,Hello]</span></span><br><span class="line"><span class="comment">[47,47,47,47]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>即使编译器无法得知 <code>add()</code> 中的 <strong>T</strong> 的任何信息，但它仍可以在编译期确保我们放入 <strong>FilledList</strong> 中的对象是 <strong>T</strong> 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。</p>
<p>因为擦除移除了方法体中的类型信息，所以在运行时的问题就是<em>边界</em>：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。</p>
<p>考虑如下这段非泛型示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SimpleHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHolder holder = <span class="keyword">new</span> SimpleHolder();</span><br><span class="line">        holder.set(<span class="string">"Item"</span>);</span><br><span class="line">        String s = (String) holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用 <strong>javap -c SimpleHolder</strong> 反编译这个类，会得到如下内容（经过编辑）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   <span class="number">1</span>: aload_1</span><br><span class="line">   2: putfield #2; // Field obj:Object;</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   1: getfield #2; // Field obj:Object;</span><br><span class="line">   <span class="number">4</span>: areturn</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   0: new #3; // class SimpleHolder</span><br><span class="line">   <span class="number">3</span>: dup</span><br><span class="line">   4: invokespecial #4; // Method "&lt;init&gt;":()V</span><br><span class="line">   <span class="number">7</span>: astore_1</span><br><span class="line">   <span class="number">8</span>: aload_1</span><br><span class="line">   9: ldc #5; // String Item</span><br><span class="line">   11: invokevirtual #6; // Method set:(Object;)V</span><br><span class="line">   <span class="number">14</span>: aload_1</span><br><span class="line">   15: invokevirtual #7; // Method get:()Object;</span><br><span class="line">   18: checkcast #8; // class java/lang/String</span><br><span class="line">   <span class="number">21</span>: astore_2</span><br><span class="line">   <span class="number">22</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><code>set()</code> 和 <code>get()</code> 方法存储和产生值，转型在调用 <code>get()</code> 时接受检查。</p>
<p>现在将泛型融入上例代码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericHolder2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder2&lt;String&gt; holder =  <span class="keyword">new</span> GenericHolder2&lt;&gt;();</span><br><span class="line">        holder.set(<span class="string">"Item"</span>);</span><br><span class="line">        String s = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 <code>get()</code> 返回后的转型消失了，但是我们还知道传递给 <code>set()</code> 的值在编译期会被检查。下面是相关的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   <span class="number">1</span>: aload_1</span><br><span class="line">   2: putfield #2; // Field obj:Object;</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   1: getfield #2; // Field obj:Object;</span><br><span class="line">   <span class="number">4</span>: areturn</span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   0: new #3; // class GenericHolder2</span><br><span class="line">   <span class="number">3</span>: dup</span><br><span class="line">   4: invokespecial #4; // Method "&lt;init&gt;":()V</span><br><span class="line">   <span class="number">7</span>: astore_1</span><br><span class="line">   <span class="number">8</span>: aload_1</span><br><span class="line">   9: ldc #5; // String Item</span><br><span class="line">   11: invokevirtual #6; // Method set:(Object;)V</span><br><span class="line">   <span class="number">14</span>: aload_1</span><br><span class="line">   15: invokevirtual #7; // Method get:()Object;</span><br><span class="line">   18: checkcast #8; // class java/lang/String</span><br><span class="line">   <span class="number">21</span>: astore_2</span><br><span class="line">   <span class="number">22</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>所产生的字节码是相同的。对进入 <code>set()</code> 的类型进行检查是不需要的，因为这将由编译器执行。而对 <code>get()</code> 返回的值进行转型仍然是需要的，只不过不需要我们来操作，它由编译器自动插入，这样我们就不用编写（阅读）杂乱的代码。</p>
<p><code>get()</code> 和 <code>set()</code> 产生了相同的字节码，这就告诉我们泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型。这有助于澄清对擦除的困惑，记住：“边界就是动作发生的地方”。</p>
<!-- Compensating for Erasure -->

<h2 id="补偿擦除"><a href="#补偿擦除" class="headerlink" title="补偿擦除"></a>补偿擦除</h2><p>因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Erased.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// error: illegal generic type for instanceof</span></span><br><span class="line">        <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> T) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// error: unexpected type</span></span><br><span class="line">        T var = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="comment">// error: generic array creation</span></span><br><span class="line">        T[] array = <span class="keyword">new</span> T[SIZE];</span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked cast</span></span><br><span class="line">        T[] array = (T[]) <span class="keyword">new</span> Object[SIZE];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 <strong>Class</strong> 对象，以在类型表达式中使用它。</p>
<p>例如，由于擦除了类型信息，因此在上一个程序中尝试使用 <strong>instanceof</strong> 将会失败。类型标签可以使用动态 <code>isInstance()</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ClassTypeCapture.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> <span class="keyword">extends</span> <span class="title">Building</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTypeCapture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassTypeCapture</span><span class="params">(Class&lt;T&gt; kind)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kind.isInstance(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassTypeCapture&lt;Building&gt; ctt1 =</span><br><span class="line">                <span class="keyword">new</span> ClassTypeCapture&lt;&gt;(Building.class);</span><br><span class="line">        System.out.println(ctt1.f(<span class="keyword">new</span> Building()));</span><br><span class="line">        System.out.println(ctt1.f(<span class="keyword">new</span> House()));</span><br><span class="line">        ClassTypeCapture&lt;House&gt; ctt2 =</span><br><span class="line">                <span class="keyword">new</span> ClassTypeCapture&lt;&gt;(House.class);</span><br><span class="line">        System.out.println(ctt2.f(<span class="keyword">new</span> Building()));</span><br><span class="line">        System.out.println(ctt2.f(<span class="keyword">new</span> House()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>编译器来保证类型标签与泛型参数相匹配。</p>
<!-- Creating Instances of Types -->
<h3 id="创建类型的实例"><a href="#创建类型的实例" class="headerlink" title="创建类型的实例"></a>创建类型的实例</h3><p>试图在 <strong>Erased.java</strong> 中 <code>new T()</code> 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 <strong>T</strong> 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/InstantiateGenericType.cpp</span></span><br><span class="line"><span class="comment">// C++, not Java!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  T x; <span class="comment">// Create a field of type T</span></span><br><span class="line">  T* y; <span class="comment">// Pointer to T</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize the pointer:</span></span><br><span class="line">  Foo() &#123; y = <span class="keyword">new</span> T(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Foo&lt;Bar&gt; fb;</span><br><span class="line">  Foo&lt;<span class="keyword">int</span>&gt; fi; <span class="comment">// ... and it works with primitives</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 <strong>Class</strong> 对象，因此，如果使用类型标记，则可以使用 <code>newInstance()</code> 创建该类型的新对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/InstantiateGenericType.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAsFactory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">    ClassAsFactory(Class&lt;T&gt; kind) &#123;</span><br><span class="line">        <span class="keyword">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> kind.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException |</span><br><span class="line">                IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Employee"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiateGenericType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassAsFactory&lt;Employee&gt; fe =</span><br><span class="line">                <span class="keyword">new</span> ClassAsFactory&lt;&gt;(Employee.class);</span><br><span class="line">        System.out.println(fe.get());</span><br><span class="line">        ClassAsFactory&lt;Integer&gt; fi =</span><br><span class="line">                <span class="keyword">new</span> ClassAsFactory&lt;&gt;(Integer.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(fi.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Employee</span></span><br><span class="line"><span class="comment">java.lang.InstantiationException: java.lang.Integer</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这样可以编译，但对于 <code>ClassAsFactory&lt;Integer&gt;</code> 会失败，这是因为 <strong>Integer</strong> 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（<strong>Supplier</strong>）并约束类型，以便只有实现该工厂的类可以这样创建对象。这是创建工厂的两种不同方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/FactoryConstraint.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Suppliers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    Widget(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        id = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Widget "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Widget</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Widget <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Widget(++i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fudge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = count++;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Fudge "</span> + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; x = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Foo2(Supplier&lt;T&gt; factory) &#123;</span><br><span class="line">        Suppliers.fill(x, factory, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryConstraint</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="keyword">new</span> Foo2&lt;&gt;(<span class="keyword">new</span> IntegerFactory()));</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="keyword">new</span> Foo2&lt;&gt;(<span class="keyword">new</span> Widget.Factory()));</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="keyword">new</span> Foo2&lt;&gt;(Fudge::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">[Widget 1, Widget 2, Widget 3, Widget 4, Widget 5]</span></span><br><span class="line"><span class="comment">[Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>IntegerFactory</strong> 本身就是通过实现 <code>Supplier&lt;Integer&gt;</code> 的工厂。 <strong>Widget</strong> 包含一个内部类，它是一个工厂。还要注意，<strong>Fudge</strong> 并没有做任何类似于工厂的操作，并且传递 <code>Fudge::new</code> 仍然会产生工厂行为，因为编译器将对函数方法 <code>::new</code> 的调用转换为对 <code>get()</code> 的调用。</p>
<p>另一种方法是模板方法设计模式。在以下示例中，<code>create()</code> 是模板方法，在子类中被重写以生成该类型的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CreatorGeneric.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T element;</span><br><span class="line"></span><br><span class="line">    GenericWithCreate() &#123;</span><br><span class="line">        element = create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XCreator</span> <span class="keyword">extends</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">X</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">X <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> X();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatorGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        XCreator xc = <span class="keyword">new</span> XCreator();</span><br><span class="line">        xc.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">X</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>GenericWithCreate</strong> 包含 <code>element</code> 字段，并通过无参构造函数强制其初始化，该构造函数又调用抽象的 <code>create()</code> 方法。这种创建方式可以在子类中定义，同时建立 <strong>T</strong> 的类型。</p>
<!-- Arrays of Generics -->

<h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>正如在 <strong>Erased.java</strong> 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 <strong>ArrayList</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ListOfGenerics.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfGenerics</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        array.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做可以获得数组的行为，并且还具有泛型提供的编译时类型安全性。</p>
<p>有时，仍然会创建泛型类型的数组（例如， <strong>ArrayList</strong> 在内部使用数组）。可以通过使编译器满意的方式定义对数组的通用引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ArrayOfGenericReference.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGenericReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Generic&lt;Integer&gt;[] gia;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器接受此操作而不产生警告。但是我们永远无法创建具有该确切类型（包括类型参数）的数组，因此有点令人困惑。由于所有数组，无论它们持有什么类型，都具有相同的结构（每个数组插槽的大小和数组布局），因此似乎可以创建一个 <strong>Object</strong> 数组并将其转换为所需的数组类型。实际上，这确实可以编译，但是会产生 <strong>ClassCastException</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ArrayOfGeneric.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGeneric</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> Generic&lt;Integer&gt;[] gia;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            gia = (Generic&lt;Integer&gt;[]) <span class="keyword">new</span> Object[SIZE];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Runtime type is the raw (erased) type:</span></span><br><span class="line">        gia = (Generic&lt;Integer&gt;[]) <span class="keyword">new</span> Generic[SIZE];</span><br><span class="line">        System.out.println(gia.getClass().getSimpleName());</span><br><span class="line">        gia[<span class="number">0</span>] = <span class="keyword">new</span> Generic&lt;&gt;();</span><br><span class="line">        <span class="comment">//- gia[1] = new Object(); // Compile-time error</span></span><br><span class="line">        <span class="comment">// Discovers type mismatch at compile time:</span></span><br><span class="line">        <span class="comment">//- gia[2] = new Generic&lt;Double&gt;();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Ljava.lang.Object; cannot be cast to [LGeneric;</span></span><br><span class="line"><span class="comment">Generic[]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>问题在于数组会跟踪其实际类型，而该类型是在创建数组时建立的。因此，即使 <code>gia</code> 被强制转换为 <code>Generic&lt;Integer&gt;[]</code> ，该信息也仅在编译时存在（并且没有 <strong>@SuppressWarnings</strong> 注解，将会收到有关该强制转换的警告）。在运行时，它仍然是一个 <strong>Object</strong> 数组，这会引起问题。成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。</p>
<p>让我们看一个更复杂的示例。考虑一个包装数组的简单泛型包装器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericArray.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        array = (T[]) <span class="keyword">new</span> Object[sz];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method that exposes the underlying representation:</span></span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericArray&lt;Integer&gt; gai = <span class="keyword">new</span> GenericArray&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer[] ia = gai.rep();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// This is OK:</span></span><br><span class="line">        Object[] oa = gai.rep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Ljava.lang.Object; cannot be cast to</span></span><br><span class="line"><span class="comment">[Ljava.lang.Integer;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>和以前一样，我们不能说 <code>T[] array = new T[sz]</code> ，所以我们创建了一个 <strong>Object</strong> 数组并将其强制转换。</p>
<p><code>rep()</code> 方法返回一个 <code>T[]</code> ，在主方法中它应该是 <code>gai</code> 的 <code>Integer[]</code>，但是如果调用它并尝试将结果转换为 <code>Integer[]</code> 引用，则会得到 <strong>ClassCastException</strong> ，这再次是因为实际的运行时类型为 <code>Object[]</code> 。</p>
<p>如果再注释掉 <strong>@SuppressWarnings</strong> 注解后编译 <strong>GenericArray.java</strong> ，则编译器会产生警告：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GenericArray.java uses unchecked or unsafe operations.</span><br><span class="line">Recompile with -Xlint:unchecked <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>

<p>在这里，我们收到了一个警告，我们认为这是有关强制转换的。</p>
<p>但是要真正确定，请使用 <code>-Xlint：unchecked</code> 进行编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenericArray.java:<span class="number">7</span>: warning: [unchecked] unchecked cast    array = (T[])<span class="keyword">new</span> Object[sz];                 ^  required: T[]  found:    Object[]  where T is a type-variable:    T extends Object declared in <span class="class"><span class="keyword">class</span> <span class="title">GenericArray</span> 1 <span class="title">warning</span></span></span><br></pre></td></tr></table></figure>

<p>确实是在抱怨那个强制转换。由于警告会变成噪音，因此，一旦我们确认预期会出现特定警告，我们可以做的最好的办法就是使用 <strong>@SuppressWarnings</strong> 将其关闭。这样，当警告确实出现时，我们将进行实际调查。</p>
<p>由于擦除，数组的运行时类型只能是 <code>Object[]</code> 。 如果我们立即将其转换为 <code>T[]</code> ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 <code>Object[]</code> ，并在使用数组元素时向 <strong>T</strong> 添加强制类型转换。让我们来看看在 <strong>GenericArray.java</strong> 示例中会是怎么样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericArray2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray2</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> Object[sz];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) array; <span class="comment">// Unchecked cast</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericArray2&lt;Integer&gt; gai =</span><br><span class="line">                <span class="keyword">new</span> GenericArray2&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            gai.put(i, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            System.out.print(gai.get(i) + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer[] ia = gai.rep();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: [Ljava.lang.Object;</span></span><br><span class="line"><span class="comment">cannot be cast to [Ljava.lang.Integer;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>最初，看起来并没有太大不同，只是转换的位置移动了。没有 <strong>@SuppressWarnings</strong> 注解，仍然会收到“unchecked”警告。但是，内部表示现在是 <code>Object[]</code> 而不是 <code>T[]</code> 。 调用 <code>get()</code> 时，它将对象强制转换为 <strong>T</strong> ，实际上这是正确的类型，因此很安全。但是，如果调用 <code>rep()</code> ，它将再次尝试将 <code>Object[]</code> 强制转换为 <code>T[]</code> ，但仍然不正确，并在编译时生成警告，并在运行时生成异常。因此，无法破坏基础数组的类型，该基础数组只能是 <code>Object[]</code> 。在内部将数组视为 <code>Object[]</code> 而不是 <code>T[]</code> 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。</p>
<p>对于新代码，请传入类型标记。在这种情况下，<strong>GenericArray</strong> 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericArrayWithTypeToken.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArrayWithTypeToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArrayWithTypeToken</span><span class="params">(Class&lt;T&gt; type, <span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        array = (T[]) Array.newInstance(type, sz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expose the underlying representation:</span></span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericArrayWithTypeToken&lt;Integer&gt; gai =</span><br><span class="line">                <span class="keyword">new</span> GenericArrayWithTypeToken&lt;&gt;(</span><br><span class="line">                        Integer.class, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// This now works:</span></span><br><span class="line">        Integer[] ia = gai.rep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型标记 <strong>Class&lt;T&gt;</strong> 被传递到构造函数中以从擦除中恢复，因此尽管必须使用 <strong>@SuppressWarnings</strong> 关闭来自强制类型转换的警告，但我们仍可以创建所需的实际数组类型。一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看到的那样。数组的运行时类型是确切的类型 <code>T[]</code> 。</p>
<p>不幸的是，如果查看 Java 标准库中的源代码，我们会发现到处都有从 <strong>Object</strong> 数组到参数化类型的转换。例如，这是<strong>ArrayList</strong> 中，复制一个 <strong>Collection</strong> 的构造函数，这里为了简化，去除了源码中对此不重要的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection c)</span> </span>&#123;</span><br><span class="line">  size = c.size();</span><br><span class="line">  elementData = (E[])<span class="keyword">new</span> Object[size];</span><br><span class="line">  c.toArray(elementData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们浏览 <strong>ArrayList.java</strong> 的代码，将会发现很多此类强制转换。当我们编译它时会发生什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Note: ArrayList.java uses unchecked or unsafe operations</span><br><span class="line">Note: Recompile with -Xlint:unchecked <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>

<p>果然，标准库会产生很多警告。如果我们使用过 C 语言，尤其是使用 ANSI C 之前的语言，我们会记住警告的特殊效果：发现警告后，可以忽略它们。因此，除非程序员必须对其进行处理，否则最好不要从编译器发出任何类型的消息。</p>
<p>Neal Gafter（Java 5 的主要开发人员之一）在他的博客中[^2]指出，他在重写 Java 库时是很随意、马虎的，我们不应该像他那样做。Neal 还指出，他在不破坏现有接口的情况下无法修复某些 Java 库代码。因此，即使在 Java 库源代码中出现了一些习惯用法，它们也不一定是正确的做法。当查看库代码时，我们不能认为这就是要在自己代码中必须遵循的示例。</p>
<p>请注意，在 Java 文献中推荐使用类型标记技术，例如 Gilad Bracha 的论文《Generics in the Java Programming Language》[^3]，他指出：“例如，这种用法已广泛用于新的 API 中以处理注解。” 我发现此技术在人们对于舒适度的看法方面存在一些不一致之处；有些人强烈喜欢本章前面介绍的工厂方法。</p>
<!-- Bounds -->

<h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p><em>边界</em>（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。</p>
<p>由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 <strong>Object</strong> 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 <code>extends</code> 关键字。</p>
<p>重要的是要理解，当用于限定泛型类型时，<code>extends</code> 的含义与通常的意义截然不同。此示例展示边界的基础应用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/BasicBounds.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HasColor</span> </span>&#123;</span><br><span class="line">    java.awt.<span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithColor</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    WithColor(T item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The bound allows you to call a method:</span></span><br><span class="line">    java.awt.<span class="function">Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y, z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This fails. Class must be first, then interfaces:</span></span><br><span class="line"><span class="comment">// class WithColorCoord&lt;T extends HasColor &amp; Coord&gt; &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiple bounds:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithColorCoord</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    WithColorCoord(T item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    java.awt.<span class="function">Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Weight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// As with inheritance, you can have only one</span></span><br><span class="line"><span class="comment">// concrete class but multiple interfaces:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    Solid(T item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    java.awt.<span class="function">Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bounded</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">Coord</span> <span class="keyword">implements</span> <span class="title">HasColor</span>, <span class="title">Weight</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.awt.<span class="function">Color <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solid&lt;Bounded&gt; solid =</span><br><span class="line">                <span class="keyword">new</span> Solid&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid.color();</span><br><span class="line">        solid.getY();</span><br><span class="line">        solid.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可能会观察到 <strong>BasicBounds.java</strong> 中似乎包含一些冗余，它们可以通过继承来消除。在这里，每个继承级别还添加了边界约束：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/InheritBounds.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    HoldItem(T item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithColor2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    WithColor2(T item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    java.awt.<span class="function">Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithColorCoord2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">WithColor2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    WithColorCoord2(T item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">WithColorCoord2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Solid2(T item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solid2&lt;Bounded&gt; solid2 =</span><br><span class="line">                <span class="keyword">new</span> Solid2&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid2.color();</span><br><span class="line">        solid2.getY();</span><br><span class="line">        solid2.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HoldItem</strong> 拥有一个对象，因此此行为将继承到 <strong>WithColor2</strong> 中，这也需要其参数符合 <strong>HasColor</strong>。 <strong>WithColorCoord2</strong> 和 <strong>Solid2</strong> 进一步扩展了层次结构，并在每个级别添加了边界。现在，这些方法已被继承，并且在每个类中不再重复。</p>
<p>这是一个具有更多层次的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/EpicBattle.java</span></span><br><span class="line"><span class="comment">// Bounds in Java generics</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SuperPower</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">XRayVision</span> <span class="keyword">extends</span> <span class="title">SuperPower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seeThroughWalls</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SuperHearing</span> <span class="keyword">extends</span> <span class="title">SuperPower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hearSubtleNoises</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SuperSmell</span> <span class="keyword">extends</span> <span class="title">SuperPower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trackBySmell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperHero</span>&lt;<span class="title">POWER</span> <span class="keyword">extends</span> <span class="title">SuperPower</span>&gt; </span>&#123;</span><br><span class="line">    POWER power;</span><br><span class="line"></span><br><span class="line">    SuperHero(POWER power) &#123;</span><br><span class="line">        <span class="keyword">this</span>.power = power;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">POWER <span class="title">getPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> power;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperSleuth</span>&lt;<span class="title">POWER</span> <span class="keyword">extends</span> <span class="title">XRayVision</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">SuperHero</span>&lt;<span class="title">POWER</span>&gt; </span>&#123;</span><br><span class="line">    SuperSleuth(POWER power) &#123;</span><br><span class="line">        <span class="keyword">super</span>(power);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">see</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        power.seeThroughWalls();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">CanineHero</span>&lt;<span class="title">POWER</span> <span class="keyword">extends</span> <span class="title">SuperHearing</span> &amp; <span class="title">SuperSmell</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">SuperHero</span>&lt;<span class="title">POWER</span>&gt; </span>&#123;</span><br><span class="line">    CanineHero(POWER power) &#123;</span><br><span class="line">        <span class="keyword">super</span>(power);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        power.hearSubtleNoises();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">smell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        power.trackBySmell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperHearSmell</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SuperHearing</span>, <span class="title">SuperSmell</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hearSubtleNoises</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackBySmell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogPerson</span> <span class="keyword">extends</span> <span class="title">CanineHero</span>&lt;<span class="title">SuperHearSmell</span>&gt; </span>&#123;</span><br><span class="line">    DogPerson() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> SuperHearSmell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EpicBattle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Bounds in generic methods:</span></span><br><span class="line">    <span class="keyword">static</span> &lt;POWER extends SuperHearing&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">useSuperHearing</span><span class="params">(SuperHero&lt;POWER&gt; hero)</span> </span>&#123;</span><br><span class="line">        hero.getPower().hearSubtleNoises();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;POWER extends SuperHearing &amp; SuperSmell&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">superFind</span><span class="params">(SuperHero&lt;POWER&gt; hero)</span> </span>&#123;</span><br><span class="line">        hero.getPower().hearSubtleNoises();</span><br><span class="line">        hero.getPower().trackBySmell();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DogPerson dogPerson = <span class="keyword">new</span> DogPerson();</span><br><span class="line">        useSuperHearing(dogPerson);</span><br><span class="line">        superFind(dogPerson);</span><br><span class="line">        <span class="comment">// You can do this:</span></span><br><span class="line">        List&lt;? extends SuperHearing&gt; audioPeople;</span><br><span class="line">        <span class="comment">// But you can't do this:</span></span><br><span class="line">        <span class="comment">// List&lt;? extends SuperHearing &amp; SuperSmell&gt; dogPs;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来将要研究的通配符将会把范围限制在单个类型。</p>
<!-- Wildcards -->

<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>我们已经在 <a href="book/12-Collections.md">集合</a> 章节中看到了一些简单示例使用了通配符——在泛型参数表达式中的问号，在 <a href="book/19-Type-Information.md">类型信息</a> 一章中这种示例更多。本节将更深入地探讨这个特性。</p>
<p>我们的起始示例要展示数组的一种特殊行为：我们可以将派生类的数组赋值给基类的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CovariantArrays.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fruit[] fruit = <span class="keyword">new</span> Apple[<span class="number">10</span>];</span><br><span class="line">        fruit[<span class="number">0</span>] = <span class="keyword">new</span> Apple(); <span class="comment">// OK</span></span><br><span class="line">        fruit[<span class="number">1</span>] = <span class="keyword">new</span> Jonathan(); <span class="comment">// OK</span></span><br><span class="line">        <span class="comment">// Runtime type is Apple[], not Fruit[] or Orange[]:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Compiler allows you to add Fruit:</span></span><br><span class="line">            fruit[<span class="number">0</span>] = <span class="keyword">new</span> Fruit(); <span class="comment">// ArrayStoreException</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Compiler allows you to add Oranges:</span></span><br><span class="line">            fruit[<span class="number">0</span>] = <span class="keyword">new</span> Orange(); <span class="comment">// ArrayStoreException</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">java.lang.ArrayStoreException: Fruit</span></span><br><span class="line"><span class="comment">java.lang.ArrayStoreException: Orange</span></span><br></pre></td></tr></table></figure>

<p><code>main()</code> 中的第一行创建了 <strong>Apple</strong> 数组，并赋值给一个 <strong>Fruit</strong> 数组引用。这是有意义的，因为 <strong>Apple</strong> 也是一种 <strong>Fruit</strong>，因此 <strong>Apple</strong> 数组应该也是一个 <strong>Fruit</strong> 数组。</p>
<p>但是，如果实际的数组类型是 <strong>Apple[]</strong>，我们可以在其中放置 <strong>Apple</strong> 或 <strong>Apple</strong> 的子类型，这在编译期和运行时都可以工作。但是我们也可以在数组中放置 <strong>Fruit</strong> 对象。这对编译器来说是有意义的，因为它有一个 <strong>Fruit[]</strong> 引用——它有什么理由不允许将 <strong>Fruit</strong> 对象或任何从 <strong>Fruit</strong> 继承出来的对象（比如 <strong>Orange</strong>），放置到这个数组中呢？因此在编译期，这是允许的。然而，运行时的数组机制知道它处理的是 <strong>Apple[]</strong>，因此会在向数组中放置异构类型时抛出异常。</p>
<p>向上转型用在这里不合适。我们真正在做的是将一个数组赋值给另一个数组。数组的行为是持有其他对象，这里只是因为我们能够向上转型而已，所以很明显，数组对象可以保留有关它们包含的对象类型的规则。看起来就像数组对它们持有的对象是有意识的，因此在编译期检查和运行时检查之间，我们不能滥用它们。</p>
<p>数组的这种赋值并不是那么可怕，因为在运行时我们可以发现插入了错误的类型。但是泛型的主要目标之一是将这种错误检测移到编译期。所以当我们试图使用泛型集合代替数组时，会发生什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/NonCovariantGenerics.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonCovariantGenerics</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compile Error: incompatible types:</span></span><br><span class="line">    List&lt;Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管我们在首次阅读这段代码时会认为“不能将一个 <strong>Apple</strong> 集合赋值给一个 <strong>Fruit</strong> 集合”。记住，泛型不仅仅是关于集合，它真正要表达的是“不能把一个涉及 <strong>Apple</strong> 的泛型赋值给一个涉及 <strong>Fruit</strong> 的泛型”。如果像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及到的集合，那么它可能会留下一些余地。但是它不知道任何有关这方面的信息，因此它拒绝向上转型。然而实际上这也不是向上转型—— <strong>Apple</strong> 的 <strong>List</strong> 不是 <strong>Fruit</strong> 的 <strong>List</strong>。<strong>Apple</strong> 的 <strong>List</strong> 将持有 <strong>Apple</strong> 和 <strong>Apple</strong> 的子类型，<strong>Fruit</strong> 的 <strong>List</strong> 将持有任何类型的 <strong>Fruit</strong>。是的，这包括 <strong>Apple</strong>，但是它不是一个 <strong>Apple</strong> 的 <strong>List</strong>，它仍然是 <strong>Fruit</strong> 的 <strong>List</strong>。<strong>Apple</strong> 的 <strong>List</strong> 在类型上不等价于 <strong>Fruit</strong> 的 <strong>List</strong>，即使 <strong>Apple</strong> 是一种 <strong>Fruit</strong> 类型。</p>
<p>真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道我们想用类型做什么，以及应该采用什么规则。</p>
<p>但是，有时我们想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericsAndCovariance.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndCovariance</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Wildcards allow covariance:</span></span><br><span class="line">        List&lt;? extends Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Compile Error: can't add any type of object:</span></span><br><span class="line">        <span class="comment">// flist.add(new Apple());</span></span><br><span class="line">        <span class="comment">// flist.add(new Fruit());</span></span><br><span class="line">        <span class="comment">// flist.add(new Object());</span></span><br><span class="line">        flist.add(<span class="keyword">null</span>); <span class="comment">// Legal but uninteresting</span></span><br><span class="line">        <span class="comment">// We know it returns at least Fruit:</span></span><br><span class="line">        Fruit f = flist.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>flist</strong> 的类型现在是 <code>List&lt;? extends Fruit&gt;</code>，我们可以读作“一个具有任何从 <strong>Fruit</strong> 继承的类型的列表”。然而，这实际上并不意味着这个 <strong>List</strong> 将持有任何类型的 <strong>Fruit</strong>。通配符引用的是明确的类型，因此它意味着“某种 <strong>flist</strong> 引用没有指定的具体类型”。因此这个被赋值的 <strong>List</strong> 必须持有诸如 <strong>Fruit</strong> 或 <strong>Apple</strong> 这样的指定类型，但是为了向上转型为 <strong>Fruit</strong>，这个类型是什么没人在意。</p>
<p><strong>List</strong> 必须持有一种具体的 <strong>Fruit</strong> 或 <strong>Fruit</strong> 的子类型，但是如果我们不关心具体的类型是什么，那么我们能对这样的 <strong>List</strong> 做什么呢？如果不知道 <strong>List</strong> 中持有的对象是什么类型，我们怎能保证安全地向其中添加对象呢？就像在 <strong>CovariantArrays.java</strong> 中向上转型一样，我们不能，除非编译器而不是运行时系统可以阻止这种操作的发生。我们很快就会发现这个问题。</p>
<p>我们可能认为事情开始变得有点走极端了，因为现在我们甚至不能向刚刚声明过将持有 <strong>Apple</strong> 对象的 <strong>List</strong> 中放入一个 <strong>Apple</strong> 对象。是的，但编译器并不知道这一点。<code>List&lt;? extends Fruit&gt;</code> 可能合法地指向一个 <code>List&lt;Orange&gt;</code>。一旦执行这种类型的向上转型，我们就丢失了向其中传递任何对象的能力，甚至传递 <strong>Object</strong> 也不行。</p>
<p>另一方面，如果我们调用了一个返回 <strong>Fruit</strong> 的方法，则是安全的，因为我们知道这个 <strong>List</strong> 中的任何对象至少具有 <strong>Fruit</strong> 类型，因此编译器允许这么做。</p>
<h3 id="编译器有多聪明"><a href="#编译器有多聪明" class="headerlink" title="编译器有多聪明"></a>编译器有多聪明</h3><p>现在我们可能会猜想自己不能去调用任何接受参数的方法，但是考虑下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CompilerIntelligence.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompilerIntelligence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; flist = Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">        Apple a = (Apple) flist.get(<span class="number">0</span>); <span class="comment">// No warning</span></span><br><span class="line">        flist.contains(<span class="keyword">new</span> Apple()); <span class="comment">// Argument is 'Object'</span></span><br><span class="line">        flist.indexOf(<span class="keyword">new</span> Apple()); <span class="comment">// Argument is 'Object'</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对 <code>contains()</code> 和 <code>indexOf()</code> 的调用接受 <strong>Apple</strong> 对象作为参数，执行没问题。这是否意味着编译器实际上会检查代码，以查看是否有某个特定的方法修改了它的对象？</p>
<p>通过查看 <strong>ArrayList</strong> 的文档，我们发现编译器没有那么聪明。尽管 <code>add()</code> 接受一个泛型参数类型的参数，但 <code>contains()</code> 和 <code>indexOf()</code> 接受的参数类型是 <strong>Object</strong>。因此当我们指定一个 <code>ArrayList&lt;? extends Fruit&gt;</code> 时，<code>add()</code> 的参数就变成了”<strong>? extends Fruit</strong>“。从这个描述中，编译器无法得知这里需要 <strong>Fruit</strong> 的哪个具体子类型，因此它不会接受任何类型的 <strong>Fruit</strong>。如果我们先把 <strong>Apple</strong> 向上转型为 <strong>Fruit</strong>，也没有关系——编译器仅仅会拒绝调用像 <code>add()</code> 这样参数列表中涉及通配符的方法。</p>
<p><code>contains()</code> 和 <code>indexOf()</code> 的参数类型是 <strong>Object</strong>，不涉及通配符，所以编译器允许调用它们。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 <strong>Object</strong> 类作为它们的参数类型。为了禁止对类型中使用了通配符的方法调用，需要在参数列表中使用类型参数。</p>
<p>下面展示一个简单的 <strong>Holder</strong> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Holder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> Holder &amp;&amp; Objects.equals(value, ((Holder) o).value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder&lt;Apple&gt; apple = <span class="keyword">new</span> Holder&lt;&gt;(<span class="keyword">new</span> Apple());</span><br><span class="line">        Apple d = apple.get();</span><br><span class="line">        apple.set(d);</span><br><span class="line">        <span class="comment">// Holder&lt;Fruit&gt; fruit = apple; // Cannot upcast</span></span><br><span class="line">        Holder&lt;? extends Fruit&gt; fruit = apple; <span class="comment">// OK</span></span><br><span class="line">        Fruit p = fruit.get();</span><br><span class="line">        d = (Apple) fruit.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Orange c = (Orange) fruit.get(); <span class="comment">// No warning</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fruit.set(new Apple()); // Cannot call set()</span></span><br><span class="line">        <span class="comment">// fruit.set(new Fruit()); // Cannot call set()</span></span><br><span class="line">        System.out.println(fruit.equals(d)); <span class="comment">// OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: Apple cannot be cast to Orange</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>Holder</strong> 有一个接受 <strong>T</strong> 类型对象的 <code>set()</code> 方法，一个返回 T 对象的 <code>get()</code> 方法和一个接受 Object 对象的 <code>equals()</code> 方法。正如我们所见，如果创建了一个 <code>Holder&lt;Apple&gt;</code>，就不能将其向上转型为 <code>Holder&lt;Fruit&gt;</code>，但是可以向上转型为 <code>Holder&lt;? extends Fruit&gt;</code>。如果调用 <code>get()</code>，只能返回一个 <strong>Fruit</strong>——这就是在给定“任何扩展自 <strong>Fruit</strong> 的对象”这一边界后，它所能知道的一切了。如果我们知道更多的信息，就可以将其转型到某种具体的 <strong>Fruit</strong> 而不会导致任何警告，但是存在得到 <strong>ClassCastException</strong> 的风险。<code>set()</code> 方法不能工作在 <strong>Apple</strong> 和 <strong>Fruit</strong> 上，因为 <code>set()</code> 的参数也是”<strong>? extends Fruit</strong>“，意味着它可以是任何事物，编译器无法验证“任何事物”的类型安全性。</p>
<p>但是，<code>equals()</code> 方法可以正常工作，因为它接受的参数是 <strong>Object</strong> 而不是 <strong>T</strong> 类型。因此，编译器只关注传递进来和要返回的对象类型。它不会分析代码，以查看是否执行了任何实际的写入和读取操作。</p>
<p>Java 7 引入了 <strong>java.util.Objects</strong> 库，使创建 <code>equals()</code> 和 <code>hashCode()</code> 方法变得更加容易，当然还有很多其他功能。<code>equals()</code> 方法的标准形式参考 <a href="book/Appendix-Understanding-equals-and-hashCode">附录：理解 equals 和 hashCode 方法</a> 一章。</p>
<h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p>还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 <code>&lt;？super MyClass&gt;</code> ，或者甚至使用类型参数： <code>&lt;？super T&gt;</code>（尽管我们不能对泛型参数给出一个超类型边界；即不能声明 <code>&lt;T super MyClass&gt;</code> ）。这使得我们可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 <strong>Collection</strong> 写入了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SuperTypeWildcards.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTypeWildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span> </span>&#123;</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">        <span class="comment">// apples.add(new Fruit()); // Error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数 <strong>apples</strong> 是 <strong>Apple</strong> 的某种基类型的 <strong>List</strong>，这样我们就知道向其中添加 <strong>Apple</strong> 或 <strong>Apple</strong> 的子类型是安全的。但是因为 <strong>Apple</strong> 是下界，所以我们知道向这样的 <strong>List</strong> 中添加 <strong>Fruit</strong> 是不安全的，因为这将使这个 <strong>List</strong> 敞开口子，从而可以向其中添加非 <strong>Apple</strong> 类型的对象，而这是违反静态类型安全的。<br>下面的示例复习了一下逆变和通配符的的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericReading.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericReading</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Apple&gt; apples = Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">    <span class="keyword">static</span> List&lt;Fruit&gt; fruit = Arrays.asList(<span class="keyword">new</span> Fruit());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A static method adapts to each call:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Apple a = readExact(apples);</span><br><span class="line">        Fruit f = readExact(fruit);</span><br><span class="line">        f = readExact(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A class type is established</span></span><br><span class="line">    <span class="comment">// when the class is instantiated:</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Reader&lt;Fruit&gt; fruitReader = <span class="keyword">new</span> Reader&lt;&gt;();</span><br><span class="line">        Fruit f = fruitReader.readExact(fruit);</span><br><span class="line">        <span class="comment">//- Fruit a = fruitReader.readExact(apples);</span></span><br><span class="line">        <span class="comment">// error: incompatible types: List&lt;Apple&gt;</span></span><br><span class="line">        <span class="comment">// cannot be converted to List&lt;Fruit&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readCovariant</span><span class="params">(List&lt;? extends T&gt; list)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CovariantReader&lt;Fruit&gt; fruitReader = <span class="keyword">new</span> CovariantReader&lt;&gt;();</span><br><span class="line">        Fruit f = fruitReader.readCovariant(fruit);</span><br><span class="line">        Fruit a = fruitReader.readCovariant(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f1(); </span><br><span class="line">        f2(); </span><br><span class="line">        f3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>readExact()</code> 方法使用了精确的类型。如果使用这个没有任何通配符的精确类型，就可以向 <strong>List</strong> 中写入和读取这个精确类型。另外，对于返回值，静态的泛型方法 <code>readExact()</code> 可以有效地“适应”每个方法调用，并能够从 <code>List&lt;Apple&gt;</code> 中返回一个 <strong>Apple</strong> ，从 <code>List&lt;Fruit&gt;</code> 中返回一个 <strong>Fruit</strong> ，就像在 <code>f1()</code> 中看到的那样。因此，如果可以摆脱静态泛型方法，那么在读取时就不需要协变类型了。<br>然而对于泛型类来说，当我们创建这个类的实例时，就要为这个类确定参数。就像在 <code>f2()</code> 中看到的，<strong>fruitReader</strong> 实例可以从 <code>List&lt;Fruit&gt;</code> 中读取一个 <strong>Fruit</strong> ，因为这就是它的确切类型。但是 <code>List&lt;Apple&gt;</code> 也应该产生 <strong>Fruit</strong> 对象，而 <strong>fruitReader</strong> 不允许这么做。<br>为了修正这个问题，<code>CovariantReader.readCovariant()</code> 方法将接受 <code>List&lt;？extends T&gt;</code> ，因此，从这个列表中读取一个 <strong>T</strong> 是安全的（我们知道在这个列表中的所有对象至少是一个 <strong>T</strong> ，并且可能是从 T 导出的某种对象）。在 <code>f3()</code> 中，我们可以看到现在可以从 <code>List&lt;Apple&gt;</code> 中读取 <strong>Fruit</strong> 了。</p>
<h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><p>无界通配符 <code>&lt;?&gt;</code> 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/UnboundedWildcards1.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundedWildcards1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list1;</span><br><span class="line">    <span class="keyword">static</span> List&lt;?&gt; list2;</span><br><span class="line">    <span class="keyword">static</span> List&lt;? extends Object&gt; list3;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        <span class="comment">//- list3 = list;</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">// list3 = list;</span></span><br><span class="line">        <span class="comment">//         ^</span></span><br><span class="line">        <span class="comment">// required: List&lt;? extends Object&gt;</span></span><br><span class="line">        <span class="comment">// found:    List</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(List&lt;? extends Object&gt; list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        <span class="comment">//- assign3(new ArrayList());</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method assign3 in class UnboundedWildcards1</span></span><br><span class="line">        <span class="comment">// is applied to given types</span></span><br><span class="line">        <span class="comment">// assign3(new ArrayList());</span></span><br><span class="line">        <span class="comment">//        ^</span></span><br><span class="line">        <span class="comment">// required: List&lt;? extends Object&gt;</span></span><br><span class="line">        <span class="comment">// found: ArrayList</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">// assign3(new ArrayList());</span></span><br><span class="line">        <span class="comment">//         ^</span></span><br><span class="line">        <span class="comment">// required: List&lt;? extends Object&gt;</span></span><br><span class="line">        <span class="comment">// found:    ArrayList</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="comment">// Both forms are acceptable as List&lt;?&gt;:</span></span><br><span class="line">        List&lt;?&gt; wildList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        wildList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        assign1(wildList);</span><br><span class="line">        assign2(wildList);</span><br><span class="line">        assign3(wildList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有很多情况都和我们在这里看到的情况类似，即编译器很少关心使用的是原生类型还是 <code>&lt;?&gt;</code> 。在这些情况中，<code>&lt;?&gt;</code> 可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上它是在声明：“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”<br>第二个示例展示了无界通配符的一个重要应用。当我们在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/UnboundedWildcards2.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundedWildcards2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map map1;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;?,?&gt; map2;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,?&gt; map3;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(Map map)</span> </span>&#123; </span><br><span class="line">        map1 = map; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(Map&lt;?,?&gt; map)</span> </span>&#123; </span><br><span class="line">        map2 = map; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(Map&lt;String,?&gt; map)</span> </span>&#123; </span><br><span class="line">        map3 = map; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap());</span><br><span class="line">        <span class="comment">//- assign3(new HashMap());</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method assign3 in class UnboundedWildcards2</span></span><br><span class="line">        <span class="comment">// is applied to given types</span></span><br><span class="line">        <span class="comment">//     assign3(new HashMap());</span></span><br><span class="line">        <span class="comment">//            ^</span></span><br><span class="line">        <span class="comment">//   required: Map&lt;String,?&gt;</span></span><br><span class="line">        <span class="comment">//   found: HashMap</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     assign3(new HashMap());</span></span><br><span class="line">        <span class="comment">//             ^</span></span><br><span class="line">        <span class="comment">//   required: Map&lt;String,?&gt;</span></span><br><span class="line">        <span class="comment">//   found:    HashMap</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，当我们拥有的全都是无界通配符时，就像在 <code>Map&lt;?,?&gt;</code> 中看到的那样，编译器看起来就无法将其与原生 <strong>Map</strong> 区分开了。另外， <strong>UnboundedWildcards1.java</strong> 展示了编译器处理  <code>List&lt;?&gt;</code> 和 <code>List&lt;? extends Object&gt;</code> 是不同的。<br>令人困惑的是，编译器并非总是关注像 <code>List</code> 和 <code>List&lt;?&gt;</code> 之间的这种差异，因此它们看起来就像是相同的事物。事实上，因为泛型参数擦除到它的第一个边界，因此 <code>List&lt;?&gt;</code> 看起来等价于 <code>List&lt;Object&gt;</code> ，而 <strong>List</strong> 实际上也是 <code>List&lt;Object&gt;</code> ——除非这些语句都不为真。<strong>List</strong> 实际上表示“持有任何 <strong>Object</strong> 类型的原生 <strong>List ** ”，而 <code>List&lt;?&gt;</code> 表示“具有某种特定类型的非原生 **List</strong> ，只是我们不知道类型是什么。”<br>编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？下面的示例使用了前面定义的 <code>Holder&lt;T&gt;</code> 类，它包含接受 <strong>Holder</strong> 作为参数的各种方法，但是它们具有不同的形式：作为原生类型，具有具体的类型参数以及具有无界通配符参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Wildcards.java</span></span><br><span class="line"><span class="comment">// Exploring the meaning of wildcards</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wildcards</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Raw argument:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rawArgs</span><span class="params">(Holder holder, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- holder.set(arg);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked call to set(T)</span></span><br><span class="line">        <span class="comment">// as a member of the raw type Holder</span></span><br><span class="line">        <span class="comment">//     holder.set(arg);</span></span><br><span class="line">        <span class="comment">//               ^</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in class Holder</span></span><br><span class="line">        <span class="comment">// 1 warning</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can't do this; don't have any 'T':</span></span><br><span class="line">        <span class="comment">// T t = holder.get();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// OK, but type information is lost:</span></span><br><span class="line">        Object obj = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Like rawArgs(), but errors instead of warnings:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unboundedArg</span><span class="params">(Holder&lt;?&gt; holder, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- holder.set(arg);</span></span><br><span class="line">        <span class="comment">// error: method set in class Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     holder.set(arg);</span></span><br><span class="line">        <span class="comment">//           ^</span></span><br><span class="line">        <span class="comment">//   required: CAP#1</span></span><br><span class="line">        <span class="comment">//   found: Object</span></span><br><span class="line">        <span class="comment">//   reason: argument mismatch;</span></span><br><span class="line">        <span class="comment">//     Object cannot be converted to CAP#1</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in class Holder</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Object from capture of ?</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can't do this; don't have any 'T':</span></span><br><span class="line">        <span class="comment">// T t = holder.get();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// OK, but type information is lost:</span></span><br><span class="line">        Object obj = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact1</span><span class="params">(Holder&lt;T&gt; holder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact2</span><span class="params">(Holder&lt;T&gt; holder, T arg)</span> </span>&#123;</span><br><span class="line">        holder.set(arg);</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">wildSubtype</span><span class="params">(Holder&lt;? extends T&gt; holder, T arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- holder.set(arg);</span></span><br><span class="line">        <span class="comment">// error: method set in class Holder&lt;T#2&gt;</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     holder.set(arg);</span></span><br><span class="line">        <span class="comment">//           ^</span></span><br><span class="line">        <span class="comment">//   required: CAP#1</span></span><br><span class="line">        <span class="comment">//   found: T#1</span></span><br><span class="line">        <span class="comment">//   reason: argument mismatch;</span></span><br><span class="line">        <span class="comment">//     T#1 cannot be converted to CAP#1</span></span><br><span class="line">        <span class="comment">//   where T#1,T#2 are type-variables:</span></span><br><span class="line">        <span class="comment">//     T#1 extends Object declared in method</span></span><br><span class="line">        <span class="comment">//     &lt;T#1&gt;wildSubtype(Holder&lt;? extends T#1&gt;,T#1)</span></span><br><span class="line">        <span class="comment">//     T#2 extends Object declared in class Holder</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends T#1 from</span></span><br><span class="line">        <span class="comment">//       capture of ? extends T#1</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">wildSupertype</span><span class="params">(Holder&lt;? <span class="keyword">super</span> T&gt; holder, T arg)</span> </span>&#123;</span><br><span class="line">        holder.set(arg);</span><br><span class="line">        <span class="comment">//- T t = holder.get();</span></span><br><span class="line">        <span class="comment">// error: incompatible types:</span></span><br><span class="line">        <span class="comment">// CAP#1 cannot be converted to T</span></span><br><span class="line">        <span class="comment">//     T t = holder.get();</span></span><br><span class="line">        <span class="comment">//                     ^</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in method</span></span><br><span class="line">        <span class="comment">//       &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Object super:</span></span><br><span class="line">        <span class="comment">//       T from capture of ? super T</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// OK, but type information is lost:</span></span><br><span class="line">        Object obj = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        <span class="comment">// Or:</span></span><br><span class="line">        raw = <span class="keyword">new</span> Holder();</span><br><span class="line">        Holder&lt;Long&gt; qualified = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Holder&lt;?&gt; unbounded = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Holder&lt;? extends Long&gt; bounded = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Long lng = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        rawArgs(raw, lng);</span><br><span class="line">        rawArgs(qualified, lng);</span><br><span class="line">        rawArgs(unbounded, lng);</span><br><span class="line">        rawArgs(bounded, lng);</span><br><span class="line"></span><br><span class="line">        unboundedArg(raw, lng);</span><br><span class="line">        unboundedArg(qualified, lng);</span><br><span class="line">        unboundedArg(unbounded, lng);</span><br><span class="line">        unboundedArg(bounded, lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Object r1 = exact1(raw);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method exact1 in class Wildcards is applied</span></span><br><span class="line">        <span class="comment">// to given types</span></span><br><span class="line">        <span class="comment">//      Object r1 = exact1(raw);</span></span><br><span class="line">        <span class="comment">//                        ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found: Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;exact1(Holder&lt;T&gt;)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//      Object r1 = exact1(raw);</span></span><br><span class="line">        <span class="comment">//                         ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;exact1(Holder&lt;T&gt;)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line"></span><br><span class="line">        Long r2 = exact1(qualified);</span><br><span class="line">        Object r3 = exact1(unbounded); <span class="comment">// Must return Object</span></span><br><span class="line">        Long r4 = exact1(bounded);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Long r5 = exact2(raw, lng);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method exact2 in class Wildcards is</span></span><br><span class="line">        <span class="comment">// applied to given types</span></span><br><span class="line">        <span class="comment">//     Long r5 = exact2(raw, lng);</span></span><br><span class="line">        <span class="comment">//                     ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder,Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//       method &lt;T&gt;exact2(Holder&lt;T&gt;,T)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     Long r5 = exact2(raw, lng);</span></span><br><span class="line">        <span class="comment">//                      ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//       method &lt;T&gt;exact2(Holder&lt;T&gt;,T)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line"></span><br><span class="line">        Long r6 = exact2(qualified, lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Long r7 = exact2(unbounded, lng);</span></span><br><span class="line">        <span class="comment">// error: method exact2 in class Wildcards</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     Long r7 = exact2(unbounded, lng);</span></span><br><span class="line">        <span class="comment">//               ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder&lt;CAP#1&gt;,Long</span></span><br><span class="line">        <span class="comment">//   reason: inference variable T has</span></span><br><span class="line">        <span class="comment">//     incompatible bounds</span></span><br><span class="line">        <span class="comment">//     equality constraints: CAP#1</span></span><br><span class="line">        <span class="comment">//     lower bounds: Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//       method &lt;T&gt;exact2(Holder&lt;T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Object from capture of ?</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Long r8 = exact2(bounded, lng);</span></span><br><span class="line">        <span class="comment">// error: method exact2 in class Wildcards</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//      Long r8 = exact2(bounded, lng);</span></span><br><span class="line">        <span class="comment">//                ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder&lt;CAP#1&gt;,Long</span></span><br><span class="line">        <span class="comment">//   reason: inference variable T</span></span><br><span class="line">        <span class="comment">//     has incompatible bounds</span></span><br><span class="line">        <span class="comment">//     equality constraints: CAP#1</span></span><br><span class="line">        <span class="comment">//     lower bounds: Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//       method &lt;T&gt;exact2(Holder&lt;T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Long from</span></span><br><span class="line">        <span class="comment">//       capture of ? extends Long</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Long r9 = wildSubtype(raw, lng);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method wildSubtype in class Wildcards</span></span><br><span class="line">        <span class="comment">// is applied to given types</span></span><br><span class="line">        <span class="comment">//     Long r9 = wildSubtype(raw, lng);</span></span><br><span class="line">        <span class="comment">//                          ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? extends T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder,Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSubtype(Holder&lt;? extends T&gt;,T)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     Long r9 = wildSubtype(raw, lng);</span></span><br><span class="line">        <span class="comment">//                           ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? extends T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSubtype(Holder&lt;? extends T&gt;,T)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line"></span><br><span class="line">        Long r10 = wildSubtype(qualified, lng);</span><br><span class="line">        <span class="comment">// OK, but can only return Object:</span></span><br><span class="line">        Object r11 = wildSubtype(unbounded, lng);</span><br><span class="line">        Long r12 = wildSubtype(bounded, lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- wildSupertype(raw, lng);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">//   method wildSupertype in class Wildcards</span></span><br><span class="line">        <span class="comment">//   is applied to given types</span></span><br><span class="line">        <span class="comment">//     wildSupertype(raw, lng);</span></span><br><span class="line">        <span class="comment">//                  ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? super T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder,Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     wildSupertype(raw, lng);</span></span><br><span class="line">        <span class="comment">//                   ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? super T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line"></span><br><span class="line">        wildSupertype(qualified, lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- wildSupertype(unbounded, lng);</span></span><br><span class="line">        <span class="comment">// error: method wildSupertype in class Wildcards</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     wildSupertype(unbounded, lng);</span></span><br><span class="line">        <span class="comment">//     ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? super T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder&lt;CAP#1&gt;,Long</span></span><br><span class="line">        <span class="comment">//   reason: cannot infer type-variable(s) T</span></span><br><span class="line">        <span class="comment">//     (argument mismatch; Holder&lt;CAP#1&gt;</span></span><br><span class="line">        <span class="comment">//     cannot be converted to Holder&lt;? super T&gt;)</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Object from capture of ?</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- wildSupertype(bounded, lng);</span></span><br><span class="line">        <span class="comment">// error: method wildSupertype in class Wildcards</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     wildSupertype(bounded, lng);</span></span><br><span class="line">        <span class="comment">//     ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? super T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder&lt;CAP#1&gt;,Long</span></span><br><span class="line">        <span class="comment">//   reason: cannot infer type-variable(s) T</span></span><br><span class="line">        <span class="comment">//     (argument mismatch; Holder&lt;CAP#1&gt;</span></span><br><span class="line">        <span class="comment">//     cannot be converted to Holder&lt;? super T&gt;)</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Long from capture of</span></span><br><span class="line">        <span class="comment">//     ? extends Long</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>rawArgs()</code> 中，编译器知道 <code>Holder</code> 是一个泛型类型，因此即使它在这里被表示成一个原生类型，编译器仍旧知道向 <code>set()</code> 传递一个 <strong>Object</strong> 是不安全的。由于它是原生类型，我们可以将任何类型的对象传递给 <code>set()</code> ，而这个对象将被向上转型为 <strong>Object</strong> 。因此无论何时，只要使用了原生类型，都会放弃编译期检查。对 <code>get()</code> 的调用说明了相同的问题：没有任何 <strong>T</strong> 类型的对象，因此结果只能是一个 <strong>Object</strong>。<br>人们很自然地会开始考虑原生 <code>Holder</code> 与 <code>Holder&lt;?&gt;</code> 是大致相同的事物。但是 <code>unboundedArg()</code> 强调它们是不同的——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，因为原生 <strong>Holder</strong> 将持有任何类型的组合，而 <code>Holder&lt;?&gt;</code> 将持有具有某种具体类型的同构集合，因此不能只是向其中传递 <strong>Object</strong> 。<br>在 <code>exact1()</code> 和 <code>exact2()</code> 中，我们可以看到使用了确切的泛型参数——没有任何通配符。我们将看到，<code>exact2()</code>与 <code>exact1()</code> 具有不同的限制，因为它有额外的参数。<br>在 <code>wildSubtype()</code> 中，在 <strong>Holder</strong> 类型上的限制被放松为包括持有任何扩展自 <strong>T</strong> 的对象的 <strong>Holder</strong> 。这还是意味着如果 T 是 <strong>Fruit</strong> ，那么 <code>holder</code> 可以是 <code>Holder&lt;Apple&gt;</code> ，这是合法的。为了防止将 <strong>Orange</strong> 放置到 <code>Holder&lt;Apple&gt;</code> 中，对 <code>set()</code> 的调用（或者对任何接受这个类型参数为参数的方法的调用）都是不允许的。但是，我们仍旧知道任何来自 <code>Holder&lt;？extends Fruit&gt;</code> 的对象至少是 <strong>Fruit</strong> ，因此 <code>get()</code> （或者任何将产生具有这个类型参数的返回值的方法）都是允许的。<br><code>wildSupertype()</code> 展示了超类型通配符，这个方法展示了与 <code>wildSubtype()</code> 相反的行为：<code>holder</code> 可以是持有任何 T 的基类型的容器。因此， <code>set()</code> 可以接受 <strong>T</strong> ，因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是 <strong>T</strong> ）。但是，尝试着调用 <code>get()</code> 是没有用的，因为由 <code>holder</code> 持有的类型可以是任何超类型，因此唯一安全的类型就是 <strong>Object</strong> 。<br>这个示例还展示了对于在 <code>unbounded()</code> 中使用无界通配符能够做什么不能做什么所做出的限制：因为我们没有 <strong>T</strong>，所以我们不能将 <code>set()</code> 或 <code>get()</code> 作用于 <strong>T</strong> 上。</p>
<p>在 <code>main()</code> 方法中我们看到了某些方法在接受某些类型的参数时没有报错和警告。为了迁移兼容性，<code>rawArgs()</code>  将接受所有 <strong>Holder</strong> 的不同变体，而不会产生警告。<code>unboundedArg()</code> 方法也可以接受相同的所有类型，尽管如前所述，它在方法体内部处理这些类型的方式并不相同。</p>
<p>如果向接受“确切”泛型类型（没有通配符）的方法传递一个原生 <strong>Holder</strong> 引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息。如果向 <code>exact1()</code> 传递一个无界引用，就不会有任何可以确定返回类型的类型信息。<br>可以看到，<code>exact2()</code> 具有最多的限制，因为它希望精确地得到一个 <code>Holder&lt;T&gt;</code> ，以及一个具有类型 <strong>T</strong> 的参数，正由于此，它将产生错误或警告，除非提供确切的参数。有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决于是否想要从泛型参数中返回类型确定的返回值（就像在 <code>wildSubtype()</code> 中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在 <code>wildSupertype()</code> 中看到的那样）。<br>因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得我们必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合我们的需求的方法。</p>
<h3 id="捕获转换"><a href="#捕获转换" class="headerlink" title="捕获转换"></a>捕获转换</h3><p>有一种特殊情况需要使用 <code>&lt;?&gt;</code> 而不是原生类型。如果向一个使用 <code>&lt;?&gt;</code> 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在 <code>@SuppressWarnings</code> 注解被移除之后才能起作用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CaptureConversion.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureConversion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Holder&lt;T&gt; holder)</span> </span>&#123;</span><br><span class="line">        T t = holder.get();</span><br><span class="line">        System.out.println(t.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(Holder&lt;?&gt; holder)</span> </span>&#123;</span><br><span class="line">        f1(holder); <span class="comment">// Call with captured type</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        f1(raw);</span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method f1 in class CaptureConversion</span></span><br><span class="line">        <span class="comment">// is applied to given types</span></span><br><span class="line">        <span class="comment">//     f1(raw);</span></span><br><span class="line">        <span class="comment">//       ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found: Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;f1(Holder&lt;T&gt;)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     f1(raw);</span></span><br><span class="line">        <span class="comment">//        ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;f1(Holder&lt;T&gt;)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line">        f2(raw); <span class="comment">// No warnings</span></span><br><span class="line">        </span><br><span class="line">        Holder rawBasic = <span class="keyword">new</span> Holder();</span><br><span class="line">        rawBasic.set(<span class="keyword">new</span> Object());</span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked call to set(T)</span></span><br><span class="line">        <span class="comment">// as a member of the raw type Holder</span></span><br><span class="line">        <span class="comment">//     rawBasic.set(new Object());</span></span><br><span class="line">        <span class="comment">//                 ^</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in class Holder</span></span><br><span class="line">        <span class="comment">// 1 warning</span></span><br><span class="line">        f2(rawBasic); <span class="comment">// No warnings</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Upcast to Holder&lt;?&gt;, still figures it out:</span></span><br><span class="line">        Holder&lt;?&gt; wildcarded = <span class="keyword">new</span> Holder&lt;&gt;(<span class="number">1.0</span>);</span><br><span class="line">        f2(wildcarded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Object</span></span><br><span class="line"><span class="comment">Double</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>f1()</code> 中的类型参数都是确切的，没有通配符或边界。在 <code>f2()</code> 中，<strong>Holder</strong> 参数是一个无界通配符，因此它看起来是未知的。但是，在 <code>f2()</code> 中调用了 <code>f1()</code>，而 <code>f1()</code> 需要一个已知参数。这里所发生的是：在调用 <code>f2()</code> 的过程中捕获了参数类型，并在调用 <code>f1()</code> 时使用了这种类型。<br>我们可能想知道这项技术是否可以用于写入，但是这要求在传递 <code>Holder&lt;?&gt;</code> 时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即在方法内部，我们需要使用确切的类型。注意，不能从 <code>f2()</code> 中返回 <strong>T</strong>，因为 <strong>T</strong> 对于 <code>f2()</code> 来说是未知的。捕获转换十分有趣，但是非常受限。</p>
<!-- Issues -->

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>本节将阐述在使用 Java 泛型时会出现的各类问题。</p>
<h3 id="任何基本类型都不能作为类型参数"><a href="#任何基本类型都不能作为类型参数" class="headerlink" title="任何基本类型都不能作为类型参数"></a>任何基本类型都不能作为类型参数</h3><p>正如本章早先提到的，Java 泛型的限制之一是不能将基本类型用作类型参数。因此，不能创建  <code>ArrayList&lt;int&gt;</code> 之类的东西。<br>解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 <code>ArrayList&lt;Integer&gt;</code>，并将基本类型 <strong>int</strong> 应用于这个集合，那么我们将发现自动装箱机制将自动地实现 <strong>int</strong> 到 <strong>Integer</strong> 的双向转换——因此，这几乎就像是有一个 <code>ArrayList&lt;int&gt;</code> 一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ListOfInt.java</span></span><br><span class="line"><span class="comment">// Autoboxing compensates for the inability</span></span><br><span class="line"><span class="comment">// to use primitives in generics</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfInt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; li = IntStream.range(<span class="number">38</span>, <span class="number">48</span>)</span><br><span class="line">            .boxed() <span class="comment">// Converts ints to Integers</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">        System.out.println(li);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[38, 39, 40, 41, 42, 43, 44, 45, 46, 47]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>通常，这种解决方案工作得很好——能够成功地存储和读取 <strong>int</strong>，自动装箱隐藏了转换的过程。但是如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本的集合；一个开源版本的实现是 <strong>org.apache.commons.collections.primitives</strong>。<br>下面是另外一种方式，它可以创建持有 <strong>Byte</strong> 的 <strong>Set</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ByteSet.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteSet</span> </span>&#123;</span><br><span class="line">    Byte[] possibles = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    Set&lt;Byte&gt; mySet = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(possibles));</span><br><span class="line">    <span class="comment">// But you can't do this:</span></span><br><span class="line">    <span class="comment">// Set&lt;Byte&gt; mySet2 = new HashSet&lt;&gt;(</span></span><br><span class="line">    <span class="comment">// Arrays.&lt;Byte&gt;asList(1,2,3,4,5,6,7,8,9));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动装箱机制解决了一些问题，但并没有解决所有问题。</p>
<p>在下面的示例中，<strong>FillArray</strong> 接口包含一些通用方法，这些方法使用 <strong>Supplier</strong> 来用对象填充数组（这使得类泛型在本例中无法工作，因为这个方法是静态的）。<strong>Supplier</strong> 实现来自 <a href="book/21-Arrays.md">数组</a> 一章,并且在 <code>main()</code> 中，可以看到 <code>FillArray.fill()</code> 使用对象填充了数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/PrimitiveGenericTest.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill an array using a generator:</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FillArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; T[] fill(T[] a, Supplier&lt;T&gt; gen) &#123;</span><br><span class="line">        Arrays.setAll(a, n -&gt; gen.get());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] fill(<span class="keyword">int</span>[] a, IntSupplier gen) &#123;</span><br><span class="line">        Arrays.setAll(a, n -&gt; gen.getAsInt());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span>[] fill(<span class="keyword">long</span>[] a, LongSupplier gen) &#123;</span><br><span class="line">        Arrays.setAll(a, n -&gt; gen.getAsLong());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span>[] fill(<span class="keyword">double</span>[] a, DoubleSupplier gen) &#123;</span><br><span class="line">        Arrays.setAll(a, n -&gt; gen.getAsDouble());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveGenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strings = FillArray.fill(</span><br><span class="line">            <span class="keyword">new</span> String[<span class="number">5</span>], <span class="keyword">new</span> Rand.String(<span class="number">9</span>));</span><br><span class="line">        System.out.println(Arrays.toString(strings));</span><br><span class="line">        <span class="keyword">int</span>[] integers = FillArray.fill(</span><br><span class="line">            <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>], <span class="keyword">new</span> Rand.Pint());</span><br><span class="line">        System.out.println(Arrays.toString(integers));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl]</span></span><br><span class="line"><span class="comment">[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>自动装箱不适用于数组，因此我们必须创建 <code>FillArray.fill()</code> 的重载版本，或创建产生 <strong>Wrapped</strong> 输出的生成器。 <strong>FillArray</strong> 仅比 <code>java.util.Arrays.setAll()</code> 有用一点，因为它返回填充的数组。</p>
<h3 id="实现参数化接口"><a href="#实现参数化接口" class="headerlink" title="实现参数化接口"></a>实现参数化接口</h3><p>一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/MultipleInterfaceVariants.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">package</span> generics;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Payable</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hourly</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Hourly</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Hourly</strong> 不能编译，因为擦除会将  <code>Payable&lt;Employe&gt;</code> 和 <code>Payable&lt;Hourly&gt;</code> 简化为相同的类 <strong>Payable</strong>，这样，上面的代码就意味着在重复两次地实现相同的接口。十分有趣的是，如果从 <strong>Payable</strong> 的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。</p>
<p>在使用某些更基本的 Java 接口，例如 <code>Comparable&lt;T&gt;</code> 时，这个问题可能会变得十分令人恼火，就像我们在本节稍后看到的那样。</p>
<h3 id="转型和警告"><a href="#转型和警告" class="headerlink" title="转型和警告"></a>转型和警告</h3><p>使用带有泛型类型参数的转型或 <strong>instanceof</strong> 不会有任何效果。下面的集合在内部将各个值存储为 <strong>Object</strong>，并在获取这些值时，再将它们转型回 <strong>T</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericCast.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedSizeStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Object[] storage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    FixedSizeStack(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        storage = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; size)</span><br><span class="line">            storage[index++] = item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index == <span class="number">0</span> ? <span class="keyword">null</span> : (T)storage[--index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Stream&lt;T&gt;)Arrays.stream(storage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericCast</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String[] letters = <span class="string">"ABCDEFGHIJKLMNOPQRS"</span>.split(<span class="string">""</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FixedSizeStack&lt;String&gt; strings =</span><br><span class="line">            <span class="keyword">new</span> FixedSizeStack&lt;&gt;(letters.length);</span><br><span class="line">        Arrays.stream(<span class="string">"ABCDEFGHIJKLMNOPQRS"</span>.split(<span class="string">""</span>))</span><br><span class="line">            .forEach(strings::push);</span><br><span class="line">        System.out.println(strings.pop());</span><br><span class="line">        strings.stream()</span><br><span class="line">            .map(s -&gt; s + <span class="string">" "</span>)</span><br><span class="line">            .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">S</span></span><br><span class="line"><span class="comment">A B C D E F G H I J K L M N O P Q R S</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果没有 <strong>@SuppressWarnings</strong> 注解，编译器将对 <code>pop()</code> 产生 “unchecked cast” 警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且 <code>pop()</code> 方法实际上并没有执行任何转型。<br>这是因为，<strong>T</strong> 被擦除到它的第一个边界，默认情况下是 <strong>Object</strong> ，因此 <code>pop()</code> 实际上只是将 <strong>Object</strong> 转型为 <strong>Object</strong>。<br>有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/NeedCasting.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        List&lt;Widget&gt; shapes = (List&lt;Widget&gt;)in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如我们将在 <a href="book/Appendix-Object-Serialization.md">附录：对象序列化</a> 中学到的那样，<code>readObject()</code> 无法知道它正在读取的是什么，因此它返回的是必须转型的对象。但是当注释掉 <strong>@SuppressWarnings</strong> 注解并编译这个程序时，就会得到下面的警告。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NeedCasting.java uses unchecked or unsafe operations.</span><br><span class="line">Recompile with -Xlint:unchecked for details.</span><br><span class="line"></span><br><span class="line">And if you follow the instructions and recompile with  -</span><br><span class="line">Xlint:unchecked :(如果遵循这条指示，使用-Xlint:unchecked来重新编译：)</span><br><span class="line"></span><br><span class="line">NeedCasting.java:10: warning: [unchecked] unchecked cast</span><br><span class="line">    List&lt;Widget&gt; shapes = (List&lt;Widget&gt;)in.readObject();</span><br><span class="line">    required: List&lt;Widget&gt;</span><br><span class="line">    found: Object</span><br><span class="line">1 warning</span><br></pre></td></tr></table></figure>

<p>我们会被强制要求转型，但是又被告知不应该转型。为了解决这个问题，必须使用 Java 5 引入的新的转型形式，既通过泛型类来转型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ClassCasting.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">// Won't Compile:</span></span><br><span class="line">        <span class="comment">//    List&lt;Widget&gt; lw1 =</span></span><br><span class="line">        <span class="comment">//    List&lt;&gt;.class.cast(in.readObject());</span></span><br><span class="line">        List&lt;Widget&gt; lw2 = List.class.cast(in.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，不能转型到实际类型（ <code>List&lt;Widget&gt;</code> ）。也就是说，不能声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Widget&gt;.class.cast(in.readobject())</span><br></pre></td></tr></table></figure>

<p>甚至当我们添加一个像下面这样的另一个转型时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(List&lt;Widget&gt;)List.class.cast(in.readobject())</span><br></pre></td></tr></table></figure>

<p>仍旧会得到一个警告。</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>下面的程序是不能编译的，即使它看起来是合理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/UseList.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList</span>&lt;<span class="title">W</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为擦除，所以重载方法产生了相同的类型签名。</p>
<p>因而，当擦除后的参数不能产生唯一的参数列表时，我们必须提供不同的方法名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/UseList2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList2</span>&lt;<span class="title">W</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>幸运的是，编译器可以检测到这类问题。</p>
<h3 id="基类劫持接口"><a href="#基类劫持接口" class="headerlink" title="基类劫持接口"></a>基类劫持接口</h3><p>假设我们有一个实现了 <strong>Comparable</strong> 接口的 <strong>Pet</strong> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ComparablePet.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试缩小 <strong>ComparablePet</strong> 子类的比较类型是有意义的。例如，<strong>Cat</strong> 类可以与其他的 <strong>Cat</strong> 比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/HijackedInterface.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// error: Comparable cannot be inherited with</span></span><br><span class="line">    <span class="comment">// different arguments: &lt;Cat&gt; and &lt;ComparablePet&gt;</span></span><br><span class="line">    <span class="comment">// class Cat</span></span><br><span class="line">    <span class="comment">// ^</span></span><br><span class="line">    <span class="comment">// 1 error</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Cat arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不幸的是，这不能工作。一旦 <strong>Comparable</strong> 的类型参数设置为 <strong>ComparablePet</strong>，其他的实现类只能比较 <strong>ComparablePet</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/RestrictedComparablePets.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hamster</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Or just:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gecko</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Hamster</strong> 显示了重新实现 <strong>ComparableSet</strong> 中相同的接口是可能的，只要接口完全相同，包括参数类型。然而正如 <strong>Gecko</strong> 中所示，这与直接覆写基类的方法完全相同。</p>
<!-- Self-Bounded Types -->

<h2 id="自限定的类型"><a href="#自限定的类型" class="headerlink" title="自限定的类型"></a>自限定的类型</h2><p>在 Java 泛型中，有一个似乎经常性出现的惯用法，它相当令人费解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123; <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。<strong>SelfBounded</strong> 类接受泛型参数 <strong>T</strong>，而 <strong>T</strong> 由一个边界类限定，这个边界就是拥有 <strong>T</strong> 作为其参数的 <strong>SelfBounded</strong>。</p>
<p>当我们首次看到它时，很难去解析它，它强调的是当 <strong>extends</strong> 关键字用于边界与用来创建子类明显是不同的。</p>
<h3 id="古怪的循环泛型"><a href="#古怪的循环泛型" class="headerlink" title="古怪的循环泛型"></a>古怪的循环泛型</h3><p>为了理解自限定类型的含义，我们从这个惯用法的一个简单版本入手，它没有自限定的边界。</p>
<p>不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类。也就是说，可以声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CuriouslyRecurringGeneric.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericType</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuriouslyRecurringGeneric</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">GenericType</span>&lt;<span class="title">CuriouslyRecurringGeneric</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这可以按照 Jim Coplien 在 C++ 中的<em>古怪的循环模版模式</em>的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。<br>为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 <strong>Object</strong> 的类型。下面是表示了这种情况的一个泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/BasicHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123; element = arg; &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个普通的泛型类型，它的一些方法将接受和产生具有其参数类型的对象，还有一个方法在其存储的域上执行操作（尽管只是在这个域上执行 <strong>Object</strong> 操作）。<br>我们可以在一个古怪的循环泛型中使用 <strong>BasicHolder</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CRGWithBasicHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subtype</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Subtype</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRGWithBasicHolder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subtype st1 = <span class="keyword">new</span> Subtype(), st2 = <span class="keyword">new</span> Subtype();</span><br><span class="line">        st1.set(st2);</span><br><span class="line">        Subtype st3 = st1.get();</span><br><span class="line">        st1.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Subtype</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意，这里有些东西很重要：新类 <strong>Subtype</strong> 接受的参数和返回的值具有 <strong>Subtype</strong> 类型而不仅仅是基类 <strong>BasicHolder</strong> 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在<strong>Subtype</strong> 中，传递给 <code>set()</code> 的参数和从 <code>get()</code> 返回的类型都是确切的 <strong>Subtype</strong>。</p>
<h3 id="自限定"><a href="#自限定" class="headerlink" title="自限定"></a>自限定</h3><p><strong>BasicHolder</strong> 可以使用任何类型作为其泛型参数，就像下面看到的那样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Unconstrained.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicOther</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Other</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unconstrained</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BasicOther b = <span class="keyword">new</span> BasicOther();</span><br><span class="line">        BasicOther b2 = <span class="keyword">new</span> BasicOther();</span><br><span class="line">        b.set(<span class="keyword">new</span> Other());</span><br><span class="line">        Other other = b.get();</span><br><span class="line">        b.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Other</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。观察所产生的类可以如何使用以及不可以如何使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SelfBounding.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        element = arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125; <span class="comment">// Also OK</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">setAndGet</span><span class="params">(C arg)</span> </span>&#123; </span><br><span class="line">        set(arg); </span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Can't do this:</span></span><br><span class="line"><span class="comment">// class E extends SelfBounded&lt;D&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="comment">//   Type parameter D is not within its bound</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Alas, you can do this, so you cannot force the idiom:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBounding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.set(<span class="keyword">new</span> A());</span><br><span class="line">        a = a.set(<span class="keyword">new</span> A()).get();</span><br><span class="line">        a = a.get();</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        c = c.setAndGet(<span class="keyword">new</span> C());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自限定所做的，就是要求在继承关系中，像下面这样使用这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这会强制要求将正在定义的类当作参数传递给基类。</p>
<p>自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如我们在 B 类的定义中所看到的，还可以从使用了另一个 <strong>SelfBounded</strong> 参数的 <strong>SelfBounded</strong> 中导出，尽管在 <strong>A</strong> 类看到的用法看起来是主要的用法。对定义 <strong>E</strong> 的尝试说明不能使用不是 <strong>SelfBounded</strong> 的类型参数。<br>遗憾的是， <strong>F</strong> 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。<br>注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 <strong>E</strong> 也会因此而变得可编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/NotSelfBounded.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">NotSelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        element = arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element; &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A2</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A2</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">C2</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">C2 <span class="title">setAndGet</span><span class="params">(C2 arg)</span> </span>&#123; </span><br><span class="line">        set(arg); </span><br><span class="line">        <span class="keyword">return</span> get(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Now this is OK:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">D2</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>因此很明显，自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。<br>还可以将自限定用于泛型方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SelfBoundingMethods.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T extends SelfBounded&lt;T&gt;&gt; <span class="function">T <span class="title">f</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg.set(arg).get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = f(<span class="keyword">new</span> A());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可以防止这个方法被应用于除上述形式的自限定参数之外的任何事物上。</p>
<h3 id="参数协变"><a href="#参数协变" class="headerlink" title="参数协变"></a>参数协变</h3><p>自限定类型的价值在于它们可以产生<em>协变参数类型</em>——方法参数类型会随子类而变化。</p>
<p>尽管自限定类型还可以产生与子类类型相同的返回类型，但是这并不十分重要，因为<em>协变返回类型</em>是在 Java 5 引入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CovariantReturnTypes.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OrdinaryGetter</span> </span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DerivedGetter</span> <span class="keyword">extends</span> <span class="title">OrdinaryGetter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Overridden method return type can vary:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Derived <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturnTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(DerivedGetter d)</span> </span>&#123;</span><br><span class="line">        Derived d2 = d.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DerivedGetter</strong> 中的 <code>get()</code> 方法覆盖了 <strong>OrdinaryGetter</strong> 中的 <code>get()</code> ，并返回了一个从 <code>OrdinaryGetter.get()</code> 的返回类型中导出的类型。尽管这是完全合乎逻辑的事情（导出类方法应该能够返回比它覆盖的基类方法更具体的类型）但是这在早先的 Java 版本中是不合法的。</p>
<p>自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 <code>get()</code> 中所看到的一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericsAndReturnTypes.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Getter</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">Getter</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndReturnTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Getter g)</span> </span>&#123;</span><br><span class="line">        Getter result = g.get();</span><br><span class="line">        GenericGetter gg = g.get(); <span class="comment">// Also the base type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这段代码不能编译，除非是使用囊括了协变返回类型的 Java 5。</p>
<p>然而，在非泛型代码中，参数类型不能随子类型发生变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/OrdinaryArguments.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Base base)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OrdinarySetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedSetter</span> <span class="keyword">extends</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedSetter.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrdinaryArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = <span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived = <span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedSetter ds = <span class="keyword">new</span> DerivedSetter();</span><br><span class="line">        ds.set(derived);</span><br><span class="line">        <span class="comment">// Compiles--overloaded, not overridden!:</span></span><br><span class="line">        ds.set(base);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">DerivedSetter.set(Derived)</span></span><br><span class="line"><span class="comment">OrdinarySetter.set(Base)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>set(derived)</code> 和 <code>set(base)</code> 都是合法的，因此 <code>DerivedSetter.set()</code> 没有覆盖 <code>OrdinarySetter.set()</code> ，而是重载了这个方法。从输出中可以看到，在 <strong>DerivedSetter</strong> 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。<br>但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SelfBoundingAndCovariantArguments.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Setter</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">Setter</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingAndCovariantArguments</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span></span><br><span class="line">    testA(Setter s1, Setter s2, SelfBoundSetter sbs) &#123;</span><br><span class="line">        s1.set(s2);</span><br><span class="line">        <span class="comment">//- s1.set(sbs);</span></span><br><span class="line">        <span class="comment">// error: method set in interface SelfBoundSetter&lt;T&gt;</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     s1.set(sbs);</span></span><br><span class="line">        <span class="comment">//       ^</span></span><br><span class="line">        <span class="comment">//   required: Setter</span></span><br><span class="line">        <span class="comment">//   found: SelfBoundSetter</span></span><br><span class="line">        <span class="comment">//   reason: argument mismatch;</span></span><br><span class="line">        <span class="comment">// SelfBoundSetter cannot be converted to Setter</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends SelfBoundSetter&lt;T&gt; declared in</span></span><br><span class="line">        <span class="comment">//     interface SelfBoundSetter</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器不能识别将基类型当作参数传递给 <code>set()</code> 的尝试，因为没有任何方法具有这样的签名。实际上，这个参数已经被覆盖。<br>如果不使用自限定类型，普通的继承机制就会介入，而我们将能够重载，就像在非泛型的情况下一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/PlainGenericInheritance.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericSetter</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="comment">// Not self-bounded</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GenericSetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedGS</span> <span class="keyword">extends</span> <span class="title">GenericSetter</span>&lt;<span class="title">Base</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedGS.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainGenericInheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = <span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived = <span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedGS dgs = <span class="keyword">new</span> DerivedGS();</span><br><span class="line">        dgs.set(derived);</span><br><span class="line">        dgs.set(base); <span class="comment">// Overloaded, not overridden!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">DerivedGS.set(Derived)</span></span><br><span class="line"><span class="comment">GenericSetter.set(Base)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这段代码在模仿 <strong>OrdinaryArguments.java</strong>；在那个示例中，<strong>DerivedSetter</strong> 继承自包含一个 <code>set(Base)</code> 的<strong>OrdinarySetter</strong> 。而这里，<strong>DerivedGS</strong> 继承自泛型创建的也包含有一个 <code>set(Base)</code>的 <code>GenericSetter&lt;Base&gt;</code>。就像 <strong>OrdinaryArguments.java</strong> 一样，我们可以从输出中看到， <strong>DerivedGS</strong> 包含两个  <code>set()</code> 的重载版本。如果不使用自限定，将重载参数类型。如果使用了自限定，只能获得方法的一个版本，它将接受确切的参数类型。</p>
<!-- Dynamic Type Safety -->

<h2 id="动态类型安全"><a href="#动态类型安全" class="headerlink" title="动态类型安全"></a>动态类型安全</h2><p>因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏我们的集合。Java 5 的 <strong>java.util.Collections</strong> 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 <code>checkedCollection()</code> 、<code>checkedList()</code>、 <code>checkedMap()</code> 、 <code>checkedSet()</code> 、<code>checkedSortedMap()</code>和 <code>checkedSortedSet()</code>。这些方法每一个都会将我们希望动态检查的集合当作第一个参数接受，并将我们希望强制要求的类型作为第二个参数接受。</p>
<p>受检查的集合在我们试图插入类型不正确的对象时抛出 <strong>ClassCastException</strong> ，这与泛型之前的（原生）集合形成了对比，对于后者来说，当我们将对象从集合中取出时，才会通知我们出现了问题。在后一种情况中，我们知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的集合，就可以发现谁在试图插入不良对象。<br>让我们用受检查的集合来看看“将猫插入到狗列表中”这个问题。这里，<code>oldStyleMethod()</code> 表示遗留代码，因为它接受的是原生的 <strong>List</strong> ，而 <strong>@SuppressWarnings（“unchecked”）</strong> 注解对于压制所产生的警告是必需的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CheckedList.java</span></span><br><span class="line"><span class="comment">// Using Collection.checkedList()</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckedList</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldStyleMethod</span><span class="params">(List probablyDogs)</span> </span>&#123;</span><br><span class="line">        probablyDogs.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Dog&gt; dogs1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        oldStyleMethod(dogs1); <span class="comment">// Quietly accepts a Cat</span></span><br><span class="line">        List&lt;Dog&gt; dogs2 = Collections.checkedList(</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(), Dog.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oldStyleMethod(dogs2); <span class="comment">// Throws an exception</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Expected: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Derived types work fine:</span></span><br><span class="line">        List&lt;Pet&gt; pets = Collections.checkedList(</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(), Pet.class);</span><br><span class="line">        pets.add(<span class="keyword">new</span> Dog());</span><br><span class="line">        pets.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Expected: java.lang.ClassCastException: Attempt to</span></span><br><span class="line"><span class="comment">insert class typeinfo.pets.Cat element into collection</span></span><br><span class="line"><span class="comment">with element type class typeinfo.pets.Dog</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>运行这个程序时，我们会发现插入一个 <strong>Cat</strong> 对于 <strong>dogs1</strong> 来说没有任何问题，而 <strong>dogs2</strong> 立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。</p>
<!-- Exceptions -->

<h2 id="泛型异常"><a href="#泛型异常" class="headerlink" title="泛型异常"></a>泛型异常</h2><p>由于擦除的原因，<strong>catch</strong> 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自 <strong>Throwable</strong>（这将进一步阻止我们去定义不能捕获的泛型异常）。<br>但是，类型参数可能会在一个方法的 <strong>throws</strong> 子句中用到。这使得我们可以编写随检查型异常类型变化的泛型代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ThrowGenericException.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>, <span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;T&gt; resultCollector)</span> <span class="keyword">throws</span> E</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessRunner</span>&lt;<span class="title">T</span>, <span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Processor</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">processAll</span><span class="params">()</span> <span class="keyword">throws</span> E </span>&#123;</span><br><span class="line">        List&lt;T&gt; resultCollector = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Processor&lt;T, E&gt; processor : <span class="keyword">this</span>)</span><br><span class="line">            processor.process(resultCollector);</span><br><span class="line">        <span class="keyword">return</span> resultCollector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure1</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor1</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">String</span>, <span class="title">Failure1</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">3</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; resultCollector)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Failure1 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count-- &gt; <span class="number">1</span>)</span><br><span class="line">            resultCollector.add(<span class="string">"Hep!"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="string">"Ho!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(count &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure2</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor2</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">Integer</span>, <span class="title">Failure2</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; resultCollector)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Failure2 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count-- == <span class="number">0</span>)</span><br><span class="line">            resultCollector.add(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            resultCollector.add(<span class="number">11</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowGenericException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProcessRunner&lt;String, Failure1&gt; runner =</span><br><span class="line">            <span class="keyword">new</span> ProcessRunner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            runner.add(<span class="keyword">new</span> Processor1());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(runner.processAll());</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Failure1 e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ProcessRunner&lt;Integer, Failure2&gt; runner2 =</span><br><span class="line">            <span class="keyword">new</span> ProcessRunner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            runner2.add(<span class="keyword">new</span> Processor2());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(runner2.processAll());</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Failure2 e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Hep!, Hep!, Ho!]</span></span><br><span class="line"><span class="comment">Failure2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>Processor</strong> 执行 <code>process()</code> 方法，并且可能会抛出具有类型 <strong>E</strong> 的异常。<code>process()</code> 的结果存储在 <code>List&lt;T&gt;resultCollector</code> 中（这被称为<em>收集参数</em>）。<strong>ProcessRunner</strong> 有一个 <code>processAll()</code> 方法，它会在所持有的每个 <strong>Process</strong> 对象执行，并返回 <strong>resultCollector</strong> 。<br>如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。</p>
<!-- Mixins -->

<h2 id="混型"><a href="#混型" class="headerlink" title="混型"></a>混型</h2><p>术语<em>混型<em>随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是我们最后的手段，它将使组装多个类变得简单易行。<br>混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点</em>面向切面编程</em> （AOP） 的味道，而切面经常被建议用来解决混型问题。</p>
<h3 id="C-中的混型"><a href="#C-中的混型" class="headerlink" title="C++ 中的混型"></a>C++ 中的混型</h3><p>在 C++ 中，使用多重继承的最大理由，就是为了使用混型。但是，对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。在 C++ 中，可以很容易地创建混型，因为 C++ 能够记住其模版参数的类型。<br>下面是一个 C++ 示例，它有两个混型类型：一个使得我们可以在每个对象中混入拥有一个时间戳这样的属性，而另一个可以混入一个序列号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Mixins.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">TimeStamped</span> :</span> <span class="keyword">public</span> T &#123;</span><br><span class="line">    <span class="keyword">long</span> timeStamp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TimeStamped() &#123; timeStamp = time(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> timeStamp; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">SerialNumbered</span> :</span> <span class="keyword">public</span> T &#123;</span><br><span class="line">    <span class="keyword">long</span> serialNumber;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SerialNumbered() &#123; serialNumber = counter++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> serialNumber; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define and initialize the static storage:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">long</span> <span class="title">SerialNumbered</span>&lt;T&gt;:</span>:counter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basic</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="built_in">string</span> val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TimeStamped&lt;SerialNumbered&lt;Basic&gt;&gt; mixin1, mixin2;</span><br><span class="line">    mixin1.<span class="built_in">set</span>(<span class="string">"test string 1"</span>);</span><br><span class="line">    mixin2.<span class="built_in">set</span>(<span class="string">"test string 2"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mixin1.get() &lt;&lt; <span class="string">" "</span> &lt;&lt; mixin1.getStamp() &lt;&lt;</span><br><span class="line">      <span class="string">" "</span> &lt;&lt; mixin1.getSerialNumber() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mixin2.get() &lt;&lt; <span class="string">" "</span> &lt;&lt; mixin2.getStamp() &lt;&lt;</span><br><span class="line">      <span class="string">" "</span> &lt;&lt; mixin2.getSerialNumber() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">test string 1 1452987605 1</span></span><br><span class="line"><span class="comment">test string 2 1452987605 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在 <code>main()</code> 中， <strong>mixin1</strong> 和 <strong>mixin2</strong> 所产生的类型拥有所混入类型的所有方法。可以将混型看作是一种功能，它可以将现有类映射到新的子类上。注意，使用这种技术来创建一个混型是多么的轻而易举。基本上，只需要声明“这就是我想要的”，紧跟着它就发生了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeStamped&lt;SerialNumbered&lt;Basic&gt;&gt; mixin1，mixin2；</span><br></pre></td></tr></table></figure>

<p>遗憾的是，Java 泛型不允许这样。擦除会忘记基类类型，因此</p>
<blockquote>
<p> 泛型类不能直接继承自一个泛型参数</p>
</blockquote>
<p>这突显了许多我在 Java 语言设计决策（以及与这些功能一起发布）中遇到的一大问题：处理一件事很有希望，但是当您实际尝试做一些有趣的事情时，您会发现自己做不到。</p>
<h3 id="与接口混合"><a href="#与接口混合" class="headerlink" title="与接口混合"></a>与接口混合</h3><p>一种更常见的推荐解决方案是使用接口来产生混型效果，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Mixins.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TimeStamped</span> </span>&#123; <span class="function"><span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeStampedImp</span> <span class="keyword">implements</span> <span class="title">TimeStamped</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    TimeStampedImp() &#123;</span><br><span class="line">        timeStamp = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> timeStamp; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SerialNumbered</span> </span>&#123; <span class="function"><span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialNumberedImp</span> <span class="keyword">implements</span> <span class="title">SerialNumbered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> serialNumber = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> serialNumber; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicImp</span> <span class="keyword">implements</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mixin</span> <span class="keyword">extends</span> <span class="title">BasicImp</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">TimeStamped</span>, <span class="title">SerialNumbered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TimeStamped timeStamp = <span class="keyword">new</span> TimeStampedImp();</span><br><span class="line">    <span class="keyword">private</span> SerialNumbered serialNumber =</span><br><span class="line">        <span class="keyword">new</span> SerialNumberedImp();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamp.getStamp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber.getSerialNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mixins</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mixin mixin1 = <span class="keyword">new</span> Mixin(), mixin2 = <span class="keyword">new</span> Mixin();</span><br><span class="line">        mixin1.set(<span class="string">"test string 1"</span>);</span><br><span class="line">        mixin2.set(<span class="string">"test string 2"</span>);</span><br><span class="line">        System.out.println(mixin1.get() + <span class="string">" "</span> +</span><br><span class="line">            mixin1.getStamp() +  <span class="string">" "</span> + mixin1.getSerialNumber());</span><br><span class="line">        System.out.println(mixin2.get() + <span class="string">" "</span> +</span><br><span class="line">            mixin2.getStamp() +  <span class="string">" "</span> + mixin2.getSerialNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">test string 1 1494331663026 1</span></span><br><span class="line"><span class="comment">test string 2 1494331663027 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>Mixin</strong> 类基本上是在使用<em>委托</em>，因此每个混入类型都要求在 <strong>Mixin</strong> 中有一个相应的域，而我们必须在 <strong>Mixin</strong> 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。</p>
<h3 id="使用装饰器模式"><a href="#使用装饰器模式" class="headerlink" title="使用装饰器模式"></a>使用装饰器模式</h3><p>当我们观察混型的使用方式时，就会发现混型概念好像与<em>装饰器</em>设计模式关系很近。装饰器经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。<br>装饰器模式使用分层对象来动态透明地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。这使得对装饰器的使用是透明的——无论对象是否被装饰，我们都拥有一个可以向对象发送的公共消息集。装饰类也可以添加新方法，但是正如我们所见，这将是受限的。<br>装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。<br>前面的示例可以被改写为使用装饰器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/decorator/Decoration.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;java generics.decorator.Decoration&#125;</span></span><br><span class="line"><span class="keyword">package</span> generics.decorator;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Basic basic;</span><br><span class="line">    Decorator(Basic basic) &#123; <span class="keyword">this</span>.basic = basic; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123; basic.set(val); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> basic.get(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeStamped</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    TimeStamped(Basic basic) &#123;</span><br><span class="line">        <span class="keyword">super</span>(basic);</span><br><span class="line">        timeStamp = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> timeStamp; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialNumbered</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> serialNumber = counter++;</span><br><span class="line">    SerialNumbered(Basic basic) &#123; <span class="keyword">super</span>(basic); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> serialNumber; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decoration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeStamped t = <span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> Basic());</span><br><span class="line">        TimeStamped t2 = <span class="keyword">new</span> TimeStamped(</span><br><span class="line">            <span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> Basic()));</span><br><span class="line">        <span class="comment">//- t2.getSerialNumber(); // Not available</span></span><br><span class="line">        SerialNumbered s = <span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> Basic());</span><br><span class="line">        SerialNumbered s2 = <span class="keyword">new</span> SerialNumbered(</span><br><span class="line">            <span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> Basic()));</span><br><span class="line">        <span class="comment">//- s2.getStamp(); // Not available</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>产生自泛型的类包含所有感兴趣的方法，但是由使用装饰器所产生的对象类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案。</p>
<h3 id="与动态代理混合"><a href="#与动态代理混合" class="headerlink" title="与动态代理混合"></a>与动态代理混合</h3><p>可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 <a href="book/19-Type-Information.md">类型信息</a> 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。<br>由于动态代理的限制，每个被混入的类都必须是某个接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/DynamicProxyMixin.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.Tuple.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixinProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; delegatesByMethod;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    MixinProxy(Tuple2&lt;Object, Class&lt;?&gt;&gt;... pairs) &#123;</span><br><span class="line">        delegatesByMethod = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Tuple2&lt;Object, Class&lt;?&gt;&gt; pair : pairs) &#123;</span><br><span class="line">            <span class="keyword">for</span>(Method method : pair.a2.getMethods()) &#123;</span><br><span class="line">                String methodName = method.getName();</span><br><span class="line">                <span class="comment">// The first interface in the map</span></span><br><span class="line">                <span class="comment">// implements the method.</span></span><br><span class="line">                <span class="keyword">if</span>(!delegatesByMethod.containsKey(methodName))</span><br><span class="line">                    delegatesByMethod.put(methodName, pair.a1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        Object delegate = delegatesByMethod.get(methodName);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(delegate, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Tuple2... pairs)</span> </span>&#123;</span><br><span class="line">        Class[] interfaces = <span class="keyword">new</span> Class[pairs.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.length; i++) &#123;</span><br><span class="line">            interfaces[i] = (Class)pairs[i].a2;</span><br><span class="line">        &#125;</span><br><span class="line">        ClassLoader cl = pairs[<span class="number">0</span>].a1.getClass().getClassLoader();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(cl, interfaces, <span class="keyword">new</span> MixinProxy(pairs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyMixin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object mixin = MixinProxy.newInstance(</span><br><span class="line">          tuple(<span class="keyword">new</span> BasicImp(), Basic.class),</span><br><span class="line">          tuple(<span class="keyword">new</span> TimeStampedImp(), TimeStamped.class),</span><br><span class="line">          tuple(<span class="keyword">new</span> SerialNumberedImp(), SerialNumbered.class));</span><br><span class="line">        Basic b = (Basic)mixin;</span><br><span class="line">        TimeStamped t = (TimeStamped)mixin;</span><br><span class="line">        SerialNumbered s = (SerialNumbered)mixin;</span><br><span class="line">        b.set(<span class="string">"Hello"</span>);</span><br><span class="line">        System.out.println(b.get());</span><br><span class="line">        System.out.println(t.getStamp());</span><br><span class="line">        System.out.println(s.getSerialNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Hello</span></span><br><span class="line"><span class="comment">1494331653339</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，我们被强制要求必须先将这些对象向下转型到恰当的类型。但是，它明显地更接近于真正的混型。<br>为了让 Java 支持混型，人们已经做了大量的工作朝着这个目标努力，包括创建了至少一种附加语言（ Jam 语言），它是专门用来支持混型的。</p>
<!-- Latent Typing -->

<h2 id="潜在类型机制"><a href="#潜在类型机制" class="headerlink" title="潜在类型机制"></a>潜在类型机制</h2><p>在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。</p>
<p>Java 泛型看起来是向这一方向迈进了一步。当我们在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如我们所见到的，自动装箱机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心我们是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。</p>
<p>还是正如我们所见到的，当要在泛型类型上执行操作（即调用 <strong>Object</strong> 方法之外的方法）时，就会产生问题。擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制我们的泛型类型，使它们继承自特定的类，或者实现特定的接口。在某些情况下，我们最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。</p>
<p>某些编程语言提供的一种解决方案称为<em>潜在类型机制</em>或<em>结构化类型机制</em>，而更古怪的术语称为<em>鸭子类型机制</em>，即“如果它走起来像鸭子，并且叫起来也像鸭子，那么我们就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。</p>
<p>泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得我们可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心我们是什么类型，只要我们可以 <code>speak()</code> 和 <code>sit()</code> 即可。”由于不要求具体类型，因此代码就可以更加泛化。</p>
<p>潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。</p>
<p>支持潜在类型机制的语言包括 Python（可以从 <a href="http://www.Python.org" target="_blank" rel="noopener">www.Python.org</a> 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。</p>
<h3 id="pyhton-中的潜在类型"><a href="#pyhton-中的潜在类型" class="headerlink" title="pyhton 中的潜在类型"></a>pyhton 中的潜在类型</h3><p>如果我们将上面的描述用 Python 来表示，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generics/DogsAndRobots.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Arf!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Sitting"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reproduce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Click!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Clank!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oilChange</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perform</span><span class="params">(anything)</span>:</span></span><br><span class="line">    anything.speak()</span><br><span class="line">    anything.sit()</span><br><span class="line"></span><br><span class="line">a = Dog()</span><br><span class="line">b = Robot()</span><br><span class="line">perform(a)</span><br><span class="line">perform(b)</span><br><span class="line"></span><br><span class="line">output = <span class="string">"""</span></span><br><span class="line"><span class="string">Arf!</span></span><br><span class="line"><span class="string">Sitting</span></span><br><span class="line"><span class="string">Click!</span></span><br><span class="line"><span class="string">Clank!</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>Python 使用缩进来确定作用域（因此不需要任何花括号），而冒号将表示新的作用域的开始。“<strong>#</strong>” 表示注释到行尾，就像Java中的 “ <strong>//</strong> ”。类的方法需要显式地指定 <strong>this</strong> 引用的等价物作为第一个参数，按惯例成为 <strong>self</strong> 。构造器调用不要求任何类型的“ <strong>new</strong> ”关键字，并且 Python 允许普通（非成员）函数，就像 <code>perform()</code> 所表明的那样。注意，在 <code>perform(anything)</code> 中，没有任何针对 <strong>anything</strong> 的类型，<strong>anything</strong> 只是一个标识符，它必须能够执行 <code>perform()</code> 期望它执行的操作，因此这里隐含着一个接口。但是我们从来都不必显式地写出这个接口——它是潜在的。<code>perform()</code> 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持  <code>speak()</code> 和 <code>sit()</code> 方法。如果传递给 <code>perform()</code> 的对象不支持这些操作，那么将会得到运行时异常。</p>
<p>输出规定使用三重引号创建带有内嵌换行符的字符串。</p>
<h3 id="C-中的潜在类型"><a href="#C-中的潜在类型" class="headerlink" title="C++ 中的潜在类型"></a>C++ 中的潜在类型</h3><p>我们可以用 C++ 产生相同的效果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/DogsAndRobots.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Arf!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sitting"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Click!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Clank!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oilChange</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">perform</span>(<span class="title">T</span> <span class="title">anything</span>) &#123;</span></span><br><span class="line">    anything.speak();</span><br><span class="line">    anything.sit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog d;</span><br><span class="line">    Robot r;</span><br><span class="line">    perform(d);</span><br><span class="line">    perform(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Arf!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在 Python 和 C++ 中，<strong>Dog</strong> 和 <strong>Robot</strong> 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，<code>perform()</code> 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。<br>C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给我们一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。潜在类型机制没有损害强类型机制。</p>
<h3 id="Go-中的潜在类型"><a href="#Go-中的潜在类型" class="headerlink" title="Go 中的潜在类型"></a>Go 中的潜在类型</h3><p>这里用 Go 语言编写相同的程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/dogsandrobots.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Dog)</span> <span class="title">speak</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"Arf!\n"</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Dog)</span> <span class="title">sit</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"Sitting\n"</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Dog)</span> <span class="title">reproduce</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Robot <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Robot)</span> <span class="title">speak</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"Click!\n"</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Robot)</span> <span class="title">sit</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"Clank!\n"</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Robot)</span> <span class="title">oilChange</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(speaker <span class="keyword">interface</span> &#123; speak()</span>; <span class="title">sit</span><span class="params">()</span> &#125;)</span> &#123;</span><br><span class="line">  speaker.speak();</span><br><span class="line">  speaker.sit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  perform(Dog&#123;&#125;)</span><br><span class="line">  perform(Robot&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Arf!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Go 没有 <strong>class</strong> 关键字，但是可以使用上述形式创建等效的基本类：它通常不定义为类，而是定义为 <strong>struct</strong> ，在其中定义数据字段（此处不存在）。 对于每种方法，都以 <strong>func</strong> 关键字开头，然后（为了将该方法附加到您的类上）放在括号中，该括号包含对象引用，该对象引用可以是任何标识符，但是我在这里使用 <strong>this</strong> 来提醒您，就像在 C ++ 或 Java 中的 <strong>this</strong> 一样。 然后，在Go中像这样定义其余的函数。</p>
<p>Go也没有继承关系，因此这种“面向对象的目标”形式是相对原始的，并且可能是我无法花更多的时间来学习该语言的主要原因。 但是，Go 的组成很简单。</p>
<p><code>perform()</code> 函数使用潜在类型：参数的确切类型并不重要，只要它包含了 <code>speak()</code> 和  <code>sit()</code> 方法即可。 该接口在此处匿名定义，内联，如 <code>perform()</code> 的参数列表所示。</p>
<p><code>main()</code> 证明 <code>perform()</code> 确实对其参数的确切类型不在乎，只要可以在该参数上调用 <code>talk()</code> 和 <code>sit()</code> 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。</p>
<p>语法 <strong>Dog {}</strong> 和 <strong>Robot {}</strong> 创建匿名的 <strong>Dog</strong> 和 <strong>Robot</strong> 结构。</p>
<h3 id="java中的直接潜在类型"><a href="#java中的直接潜在类型" class="headerlink" title="java中的直接潜在类型"></a>java中的直接潜在类型</h3><p>因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8  之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Performs.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Performs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/DogsAndRobots.java</span></span><br><span class="line"><span class="comment">// No (direct) latent typing in Java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerformingDog</span> <span class="keyword">extends</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Performs</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Woof!"</span>); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Sitting"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span> <span class="keyword">implements</span> <span class="title">Performs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Click!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Clank!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oilChange</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Communicate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Performs&gt;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">(T performer)</span> </span>&#123;</span><br><span class="line">        performer.speak();</span><br><span class="line">        performer.sit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogsAndRobots</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Communicate.perform(<span class="keyword">new</span> PerformingDog());</span><br><span class="line">        Communicate.perform(<span class="keyword">new</span> Robot());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Woof!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>但是要注意，<code>perform()</code> 不需要使用泛型来工作，它可以被简单地指定为接受一个 <strong>Performs</strong> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SimpleDogsAndRobots.java</span></span><br><span class="line"><span class="comment">// Removing the generic; code still works</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateSimply</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Performs performer)</span> </span>&#123;</span><br><span class="line">        performer.speak();</span><br><span class="line">        performer.sit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDogsAndRobots</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommunicateSimply.perform(<span class="keyword">new</span> PerformingDog());</span><br><span class="line">        CommunicateSimply.perform(<span class="keyword">new</span> Robot());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Woof!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在本例中，泛型不是必需的，因为这些类已经被强制要求实现 <strong>Performs</strong> 接口。</p>
<!-- Compensating for the Lack of (Direct) Latent -->

<h2 id="对缺乏潜在类型机制的补偿"><a href="#对缺乏潜在类型机制的补偿" class="headerlink" title="对缺乏潜在类型机制的补偿"></a>对缺乏潜在类型机制的补偿</h2><p>尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>可以使用的一种方式是反射，下面的 <code>perform()</code> 方法就是用了潜在类型机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/LatentReflection.java</span></span><br><span class="line"><span class="comment">// Using reflection for latent typing</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Does not implement Performs:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mime</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walkAgainstTheWind</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Pretending to sit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushInvisibleWalls</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Mime"</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Does not implement Performs:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartDog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Woof!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Sitting"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateReflectively</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Object speaker)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; spkr = speaker.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method speak = spkr.getMethod(<span class="string">"speak"</span>);</span><br><span class="line">                speak.invoke(speaker);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(speaker + <span class="string">" cannot speak"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method sit = spkr.getMethod(<span class="string">"sit"</span>);</span><br><span class="line">                sit.invoke(speaker);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(speaker + <span class="string">" cannot sit"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SecurityException |</span><br><span class="line">            IllegalAccessException |</span><br><span class="line">            IllegalArgumentException |</span><br><span class="line">            InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(speaker.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatentReflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> SmartDog());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Robot());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Mime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Woof!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">Mime cannot speak</span></span><br><span class="line"><span class="comment">Pretending to sit</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上例中，这些类完全是彼此分离的，没有任何公共基类（除了 <strong>Object</strong> ）或接口。通过反射, <code>CommunicateReflectively.perform()</code> 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 <strong>Mime</strong> 只具有一个必需的方法这一事实，并能够部分实现其目标。</p>
<h3 id="将一个方法应用于序列"><a href="#将一个方法应用于序列" class="headerlink" title="将一个方法应用于序列"></a>将一个方法应用于序列</h3><p>反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？</p>
<p>让我们看一个说明这个问题的示例。假设想要创建一个 <code>apply()</code> 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为我们想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。如何用 Java 来实现这个需求呢？</p>
<p>最初，我们可以用反射来解决这个问题，由于有了 Java 的可变参数，这种方式被证明是相当优雅的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Apply.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, S extends Iterable&lt;T&gt;&gt;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(S seq, Method f, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(T t: seq)</span><br><span class="line">                f.invoke(t, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalAccessException |</span><br><span class="line">            IllegalArgumentException |</span><br><span class="line">            InvocationTargetException e) &#123;</span><br><span class="line">            <span class="comment">// Failures are programmer errors</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <strong>Apply.java</strong> 中，异常被转换为 <strong>RuntimeException</strong> ，因为没有多少办法可以从这种异常中恢复——在这种情况下，它们实际上代表着程序员的错误。</p>
<p>为什么我们不只使用 Java 8 方法参考（稍后显示）而不是反射方法 <strong>f</strong> ？ 注意，<code>invoke()</code> 和 <code>apply()</code> 的优点是它们可以接受任意数量的参数。 在某些情况下，灵活性可能至关重要。</p>
<p>为了测试 <strong>Apply</strong> ，我们首先创建一个 <strong>Shape</strong> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Shape.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName() + <span class="string">" "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">" rotate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">" resize "</span> + newSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被一个子类 <strong>Square</strong> 继承：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Square.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>通过这些，我们可以测试 <strong>Apply</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ApplyTest.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Shape&gt; shapes =</span><br><span class="line">          Suppliers.create(ArrayList::<span class="keyword">new</span>, Shape::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        Apply.apply(shapes, Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">        Apply.apply(shapes, Shape.class.getMethod(<span class="string">"resize"</span>, <span class="keyword">int</span>.class), <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Square&gt; squares =</span><br><span class="line">          Suppliers.create(ArrayList::<span class="keyword">new</span>, Square::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        Apply.apply(squares, Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">        Apply.apply(squares, Shape.class.getMethod(<span class="string">"resize"</span>, <span class="keyword">int</span>.class), <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;&gt;(Shape::<span class="keyword">new</span>, <span class="number">3</span>),</span><br><span class="line">          Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;&gt;(Square::<span class="keyword">new</span>, <span class="number">3</span>),</span><br><span class="line">          Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line"></span><br><span class="line">        SimpleQueue&lt;Shape&gt; shapeQ = Suppliers.fill(</span><br><span class="line">          <span class="keyword">new</span> SimpleQueue&lt;&gt;(), SimpleQueue::add,</span><br><span class="line">          Shape::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        Suppliers.fill(shapeQ, SimpleQueue::add,</span><br><span class="line">          Square::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        Apply.apply(shapeQ, Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Shape 0 rotate</span></span><br><span class="line"><span class="comment">Shape 1 rotate</span></span><br><span class="line"><span class="comment">Shape 2 rotate</span></span><br><span class="line"><span class="comment">Shape 0 resize 7</span></span><br><span class="line"><span class="comment">Shape 1 resize 7</span></span><br><span class="line"><span class="comment">Shape 2 resize 7</span></span><br><span class="line"><span class="comment">Square 3 rotate</span></span><br><span class="line"><span class="comment">Square 4 rotate</span></span><br><span class="line"><span class="comment">Square 5 rotate</span></span><br><span class="line"><span class="comment">Square 3 resize 7</span></span><br><span class="line"><span class="comment">Square 4 resize 7</span></span><br><span class="line"><span class="comment">Square 5 resize 7</span></span><br><span class="line"><span class="comment">Shape 6 rotate</span></span><br><span class="line"><span class="comment">Shape 7 rotate</span></span><br><span class="line"><span class="comment">Shape 8 rotate</span></span><br><span class="line"><span class="comment">Square 9 rotate</span></span><br><span class="line"><span class="comment">Square 10 rotate</span></span><br><span class="line"><span class="comment">Square 11 rotate</span></span><br><span class="line"><span class="comment">Shape 12 rotate</span></span><br><span class="line"><span class="comment">Shape 13 rotate</span></span><br><span class="line"><span class="comment">Shape 14 rotate</span></span><br><span class="line"><span class="comment">Square 15 rotate</span></span><br><span class="line"><span class="comment">Square 16 rotate</span></span><br><span class="line"><span class="comment">Square 17 rotate</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在 <strong>Apply</strong> 中，我们运气很好，因为碰巧在 Java 中内建了一个由 Java 集合类库使用的 <strong>Iterable</strong> 接口。正由于此， <code>apply()</code> 方法可以接受任何实现了 <strong>Iterable</strong> 接口的事物，包括诸如 <strong>List</strong> 这样的所有 <strong>Collection</strong> 类。但是它还可以接受其他任何事物，只要能够使这些事物是 <strong>Iterable</strong> 的——例如，在 <code>main()</code> 中使用下面定义的 <strong>SimpleQueue</strong> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SimpleQueue.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A different kind of Iterable collection</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; storage = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123; storage.offer(t); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> storage.poll(); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如反射解决方案看起来那样优雅，我们必须观察到反射（尽管在 Java 的最新版本中得到了显着改进）通常比非反射实现要慢，因为在运行时发生了很多事情。 但它不应阻止您尝试这种解决方案，这依然是值得考虑的一点。</p>
<p>几乎可以肯定，我们会首先使用 Java 8 的函数式方法，并且只有在解决了特殊需求时才诉诸反射。 这里对 <strong>ApplyTest.java</strong> 进行了重写，以利用 Java 8 的流和函数工具：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ApplyFunctional.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplyFunctional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.of(</span><br><span class="line">          Stream.generate(Shape::<span class="keyword">new</span>).limit(<span class="number">2</span>),</span><br><span class="line">          Stream.generate(Square::<span class="keyword">new</span>).limit(<span class="number">2</span>))</span><br><span class="line">        .flatMap(c -&gt; c) <span class="comment">// flatten into one stream</span></span><br><span class="line">        .peek(Shape::rotate)</span><br><span class="line">        .forEach(s -&gt; s.resize(<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> FilledList&lt;&gt;(Shape::<span class="keyword">new</span>, <span class="number">2</span>)</span><br><span class="line">          .forEach(Shape::rotate);</span><br><span class="line">        <span class="keyword">new</span> FilledList&lt;&gt;(Square::<span class="keyword">new</span>, <span class="number">2</span>)</span><br><span class="line">          .forEach(Shape::rotate);</span><br><span class="line"></span><br><span class="line">        SimpleQueue&lt;Shape&gt; shapeQ = Suppliers.fill(</span><br><span class="line">          <span class="keyword">new</span> SimpleQueue&lt;&gt;(), SimpleQueue::add,</span><br><span class="line">          Shape::<span class="keyword">new</span>, <span class="number">2</span>);</span><br><span class="line">        Suppliers.fill(shapeQ, SimpleQueue::add,</span><br><span class="line">          Square::<span class="keyword">new</span>, <span class="number">2</span>);</span><br><span class="line">        shapeQ.forEach(Shape::rotate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Shape 0 rotate</span></span><br><span class="line"><span class="comment">Shape 0 resize 7</span></span><br><span class="line"><span class="comment">Shape 1 rotate</span></span><br><span class="line"><span class="comment">Shape 1 resize 7</span></span><br><span class="line"><span class="comment">Square 2 rotate</span></span><br><span class="line"><span class="comment">Square 2 resize 7</span></span><br><span class="line"><span class="comment">Square 3 rotate</span></span><br><span class="line"><span class="comment">Square 3 resize 7</span></span><br><span class="line"><span class="comment">Shape 4 rotate</span></span><br><span class="line"><span class="comment">Shape 5 rotate</span></span><br><span class="line"><span class="comment">Square 6 rotate</span></span><br><span class="line"><span class="comment">Square 7 rotate</span></span><br><span class="line"><span class="comment">Shape 8 rotate</span></span><br><span class="line"><span class="comment">Shape 9 rotate</span></span><br><span class="line"><span class="comment">Square 10 rotate</span></span><br><span class="line"><span class="comment">Square 11 rotate</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>由于使用 Java 8，因此不需要 <code>Apply.apply()</code> 。</p>
<p>我们首先生成两个 <strong>Stream</strong> ： 一个是 <strong>Shape</strong> ，一个是 <strong>Square</strong> ，并将它们展平为单个流。 尽管 Java 缺少功能语言中经常出现的 <code>flatten()</code> ，但是我们可以使用 <code>flatMap(c-&gt; c)</code> 产生相同的结果，后者使用身份映射将操作简化为“  <strong>flatten</strong> ”。</p>
<p>我们使用 <code>peek()</code> 当做对 <code>rotate()</code> 的调用，因为 <code>peek()</code> 执行一个操作（此处是出于副作用），并在未更改的情况下传递对象。</p>
<p>注意，使用 <strong>FilledList</strong> 和 <strong>shapeQ</strong> 调用 <code>forEach()</code> 比 <code>Apply.apply()</code> 代码整洁得多。 在代码简单性和可读性方面，结果比以前的方法好得多。 并且，现在也不可能从  <code>main()</code> 引发异常。</p>
<!-- Assisted Latent Typing in Java 8 -->

<h2 id="Java8-中的辅助潜在类型"><a href="#Java8-中的辅助潜在类型" class="headerlink" title="Java8 中的辅助潜在类型"></a>Java8 中的辅助潜在类型</h2><p>先前声明关于 Java 缺乏对潜在类型的支持在 Java 8 之前是完全正确的。但是，Java 8 中的非绑定方法引用使我们能够产生一种潜在类型的形式，以满足创建一段可工作在不相干类型上的代码。因为 Java 最初并不是如此设计，所以结果可想而知，比其他语言中要尴尬一些。但是，至少现在成为了可能，只是缺乏令人惊艳之处。</p>
<p>我在其他地方从没遇过这种技术，因此我将其称为辅助潜在类型。</p>
<p>我们将重写 <strong>DogsAndRobots.java</strong> 来演示该技术。 为使外观看起来与原始示例尽可能相似，我仅向每个原始类名添加了 <strong>A</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/DogsAndRobotMethodReferences.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "Assisted Latent Typing"</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerformingDogA</span> <span class="keyword">extends</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Woof!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Sitting"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Click!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Clank!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oilChange</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;P&gt; <span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">(P performer,</span></span></span><br><span class="line"><span class="function"><span class="params">      Consumer&lt;P&gt; action1, Consumer&lt;P&gt; action2)</span> </span>&#123;</span><br><span class="line">        action1.accept(performer);</span><br><span class="line">        action2.accept(performer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogsAndRobotMethodReferences</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommunicateA.perform(<span class="keyword">new</span> PerformingDogA(),</span><br><span class="line">          PerformingDogA::speak, PerformingDogA::sit);</span><br><span class="line">        CommunicateA.perform(<span class="keyword">new</span> RobotA(),</span><br><span class="line">          RobotA::speak, RobotA::sit);</span><br><span class="line">        CommunicateA.perform(<span class="keyword">new</span> Mime(),</span><br><span class="line">          Mime::walkAgainstTheWind,</span><br><span class="line">          Mime::pushInvisibleWalls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Woof!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>PerformingDogA</strong> 和 <strong>RobotA</strong> 与 <strong>DogsAndRobots.java</strong> 中的相同，不同之处在于它们不继承通用接口 <strong>Performs</strong> ，因此它们没有通用性。</p>
<p><code>CommunicateA.perform()</code> 在没有约束的 <strong>P</strong> 上生成。 只要可以使用 <code>Consumer &lt;P&gt;</code>，它在这里就可以是任何东西，这些 <code>Consumer&lt;P&gt;</code> 代表不带参数的 <strong>P</strong> 方法的未绑定方法引用。当您调用 <strong>Consumer</strong>  的 <code>accept()</code> 方法时，它将方法引用绑定到执行者对象并调用该方法。 由于 <a href="book/13-Functional-Programming.md">函数式编程</a> 一章中描述的“魔术”，我们可以将任何符合签名的未绑定方法引用传递给 <code>CommunicateA.perform()</code> 。</p>
<p>之所以称其为“辅助”，是因为您必须显式地为 <code>perform()</code> 提供要使用的方法引用。 它不能只按名称调用方法。</p>
<p>尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 <code>CommunicateA.perform()</code> ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。</p>
<p>为了证明这一点，我还从 <strong>LatentReflection.java</strong> 中引入了 <strong>Mime</strong>。</p>
<h3 id="使用Suppliers类的通用方法"><a href="#使用Suppliers类的通用方法" class="headerlink" title="使用Suppliers类的通用方法"></a>使用<strong>Suppliers</strong>类的通用方法</h3><p>通过辅助潜在类型，我们可以定义本章其他部分中使用的 <strong>Suppliers</strong> 类。 此类包含使用生成器填充 <strong>Collection</strong> 的工具方法。 泛化这些操作很有意义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Suppliers.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility to use with Suppliers</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Suppliers</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a collection and fill it:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt; C</span><br><span class="line">      create(Supplier&lt;C&gt; factory, Supplier&lt;T&gt; gen, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.generate(gen)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .collect(factory, C::add, C::addAll);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fill an existing collection:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt;</span><br><span class="line">      <span class="function">C <span class="title">fill</span><span class="params">(C coll, Supplier&lt;T&gt; gen, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Stream.generate(gen)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .forEach(coll::add);</span><br><span class="line">        <span class="keyword">return</span> coll;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Use an unbound method reference to</span></span><br><span class="line">    <span class="comment">// produce a more general method:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;H, A&gt; <span class="function">H <span class="title">fill</span><span class="params">(H holder,</span></span></span><br><span class="line"><span class="function"><span class="params">      BiConsumer&lt;H, A&gt; adder, Supplier&lt;A&gt; gen, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Stream.generate(gen)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .forEach(a -&gt; adder.accept(holder, a));</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>create()</code> 为我们创建一个新的 <strong>Collection</strong> 子类型，而 <code>fill()</code> 的第一个版本将元素放入 <strong>Collection</strong> 的现有子类型中。 请注意，还会返回传入的容器的确切类型，因此不会丢失类型信息。</p>
<p>前两种方法一般都受约束，只能与 <strong>Collection</strong> 子类型一起使用。<code>fill()</code> 的第二个版本适用于任何类型的 <strong>holder</strong> 。 它需要一个附加参数：未绑定方法引用 <code>adder. fill()</code> ，使用辅助潜在类型来使其与任何具有添加元素方法的 <strong>holder</strong> 类型一起使用。因为此未绑定方法 <strong>adder</strong> 必须带有一个参数（要添加到 <strong>holder</strong> 的元素），所以 <strong>adder</strong> 必须是 <code>BiConsumer &lt;H，A&gt;</code> ，其中 <strong>H</strong> 是要绑定到的 <strong>holder</strong> 对象的类型，而 <strong>A</strong> 是要被添加的绑定元素类型。 对 <code>accept()</code> 的调用将使用参数 a 调用对象 <strong>holder</strong> 上的未绑定方法 <strong>holder</strong>。</p>
<p>在一个稍作模拟的测试中对 <strong>Suppliers</strong> 工具程序进行了测试，该仿真还使用了本章前面定义的 <strong>RandomList</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/BankTeller.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A very simple bank teller simulation</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Customer "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Teller "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;BankTeller&gt; tellers =</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(BankTeller bt)</span> </span>&#123;</span><br><span class="line">        tellers.add(bt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTeller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">(Teller t, Customer c)</span> </span>&#123;</span><br><span class="line">        System.out.println(t + <span class="string">" serves "</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Demonstrate create():</span></span><br><span class="line">        RandomList&lt;Teller&gt; tellers =</span><br><span class="line">            Suppliers.create(</span><br><span class="line">            RandomList::<span class="keyword">new</span>, Teller::<span class="keyword">new</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Demonstrate fill():</span></span><br><span class="line">        List&lt;Customer&gt; customers = Suppliers.fill(</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(), Customer::<span class="keyword">new</span>, <span class="number">12</span>);</span><br><span class="line">        customers.forEach(c -&gt;</span><br><span class="line">            serve(tellers.select(), c));</span><br><span class="line">        <span class="comment">// Demonstrate assisted latent typing:</span></span><br><span class="line">        Bank bank = Suppliers.fill(</span><br><span class="line">            <span class="keyword">new</span> Bank(), Bank::put, BankTeller::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// Can also use second version of fill():</span></span><br><span class="line">        List&lt;Customer&gt; customers2 = Suppliers.fill(</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(),</span><br><span class="line">            List::add, Customer::<span class="keyword">new</span>, <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 1</span></span><br><span class="line"><span class="comment">Teller 2 serves Customer 2</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 3</span></span><br><span class="line"><span class="comment">Teller 1 serves Customer 4</span></span><br><span class="line"><span class="comment">Teller 1 serves Customer 5</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 6</span></span><br><span class="line"><span class="comment">Teller 1 serves Customer 7</span></span><br><span class="line"><span class="comment">Teller 2 serves Customer 8</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 9</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 10</span></span><br><span class="line"><span class="comment">Teller 2 serves Customer 11</span></span><br><span class="line"><span class="comment">Teller 4 serves Customer 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以看到 <code>create()</code> 生成一个新的 <strong>Collection</strong> 对象，而 <code>fill()</code> 添加到现有 <strong>Collection</strong> 中。第二个版本<code>fill()</code> 显示，它不仅与无关的新类型 <strong>Bank</strong> 一起使用，还能与 <strong>List</strong> 一起使用。因此，从技术上讲，<code>fill()</code> 的第一个版本在技术上不是必需的，但在使用 <strong>Collection</strong> 时提供了较短的语法。</p>
<!-- Summary: Is Casting Really So Bad? -->

<h2 id="总结：类型转换真的如此之糟吗？"><a href="#总结：类型转换真的如此之糟吗？" class="headerlink" title="总结：类型转换真的如此之糟吗？"></a>总结：类型转换真的如此之糟吗？</h2><p>自从 C++ 模版出现以来，我就一直在致力于解释它，我可能比大多数人都更早地提出了下面的论点。直到最近，我才停下来，去思考这个论点到底在多少时间内是有效的——我将要描述的问题到底有多少次可以穿越障碍得以解决。</p>
<p>这个论点就是：使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 <strong>List</strong> 、各种 <strong>Set</strong> 、各种 <strong>Map</strong> 等我们在 <a href="book/12-Collections.md">集合</a> 和 <a href="book/Appendix-Collection-Topics.md">附录：集合主题</a> 这两章所见。在 Java 5 之前，当我们将一个对象放置到集合中时，这个对象就会被向上转型为 <strong>Object</strong> ，因此我们会丢失类型信息。当我们想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 <strong>Cat</strong> 的 <strong>List</strong> （这个示例的一种使用苹果和桔子的变体在 <a href="book/12-Collections.md">集合</a> 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，我们放到容集里和从集合中取回的都是 <strong>Object</strong> 。因此，我们很可能会将一个 <strong>Dog</strong> 放置到 <strong>Cat</strong> 的 <strong>List</strong> 中。</p>
<p>但是，泛型出现之前的 Java 并不会让我们误用放入到集合中的对象。如果将一个 <strong>Dog</strong> 扔到 <strong>Cat</strong> 的集合中，并且试图将这个集合中的所有东西都当作 <strong>Cat</strong> 处理，那么当我们从这个 <strong>Cat</strong> 集合中取回那个 <strong>Dog</strong> 引用，并试图将其转型为 <strong>Cat</strong> 时，就会得到一个 <strong>RuntimeException</strong> 。我们仍旧可以发现问题，但是是在运行时而非编译期发现它的。</p>
<p>在本书以前的版本中，我曾经说过：</p>
<blockquote>
<p>这不止令人恼火，它还可能会产生难以发现的缺陷。如果这个程序的某个部分（或数个部分）向集合中插入了对象，并且通过异常，我们在程序的另一个独立的部分中发现有不良对象被放置到了集合中，那么必须发现这个不良插入到底是在何处发生的。</p>
</blockquote>
<p>但是，随着对这个论点的进一步检查，我开始怀疑它了。首先，这会多么频繁地发生呢？我记得这类事情从未发生在我身上，并且当我在会议上询问其他人时，我也从来没有听说过有人碰上过。另一本书使用了一个称为 <strong>files</strong> 的 list 示例，它包含 <strong>String</strong> 对象。在这个示例中，向 <strong>files</strong> 中添加一个 <strong>File</strong> 对象看起来相当自然，因此这个对象的名字可能叫 <strong>fileNames</strong> 更好。无论 Java 提供了多少类型检查，仍旧可能会写出晦涩的程序，而编写差劲儿的程序即便可以编译，它仍旧是编写差劲儿的程序。可能大多数人都会使用命名良好的集合，例如 <strong>cats</strong> ，因为它们可以向试图添加非 <strong>Cat</strong> 对象的程序员提供可视的警告。并且即便这类事情发生了，它真正又能潜伏多久呢？只要我们开始用真实数据来运行测试，就会非常快地看到异常。</p>
<p>有一位作者甚至断言，这样的缺陷将“<em>潜伏数年</em>”。但是我不记得有任何大量的相关报告，来说明人们在查找“狗在猫列表中”这类缺陷时困难重重，或者是说明人们会非常频繁地产生这种错误。然而，我们将在 <a href="book/24-Concurrent-Programming.md">多线程编程</a> 章节中看到，在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且，对于到底出了什么错，这些缺陷只能给我们一个很模糊的概念。因此，对于泛型是添加到 Java 中的非常显著和相当复杂的特性这一点，“狗在猫列表中”这个论据真的能够成为它的理由吗？<br>我相信被称为<em>泛型</em>的通用语言特性（并非必须是其在 Java 中的特定实现）的目的在于可表达性，而不仅仅是为了创建类型安全的集合。类型安全的集合是能够创建更通用代码这一能力所带来的副作用。<br>因此，即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。正如我们在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。</p>
<p>还要注意到，因为泛型是后来添加到 Java 中，而不是从一开始就设计到这种语言中的，所以某些容器无法达到它们应该具备的健壮性。例如，观察一下 <strong>Map</strong> ，在特定的方法 <code>containsKey(Object key)</code>和 <code>get(Object key)</code> 中就包含这类情况。如果这些类是使用在它们之前就存在的泛型设计的，那么这些方法将会使用参数化类型而不是 <strong>Object</strong> ，因此也就可以提供这些泛型假设会提供的编译期检查。例如，在 C++ 的 <strong>map</strong> 中，键的类型总是在编译期检查的。</p>
<p>有一件事很明显：在一种语言已经被广泛应用之后，在其较新的版本中引入任何种类的泛型机制，都会是一项非常非常棘手的任务，并且是一项不付出艰辛就无法完成的任务。在 C++ 中，模版是在其最初的 ISO 版本中就引入的（即便如此，也引发了阵痛，因为在第一个标准 C++ 出现之前，有很多非模版版本在使用），因此实际上模版一直都是这种语言的一部分。在 Java 中，泛型是在这种语言首次发布大约 10 年之后才引入的，因此向泛型迁移的问题特别多，并且对泛型的设计产生了明显的影响。其结果就是，程序员将承受这些痛苦，而这一切都是由于 Java 设计者在设计 1.0 版本时所表现出来的短视造成的。当 Java 最初被创建时，它的设计者们当然了解 C++ 的模版，他们甚至考虑将其囊括到 Java 语言中，但是出于这样或那样的原因，他们决定将模版排除在外（其迹象就是他们过于匆忙）。因此， Java 语言和使用它的程序员都将承受这些痛苦。只有时间将会说明 Java 的泛型方式对这种语言所造成的最终影响。<br>某些语言，已经融入了更简洁、影响更小的方式，来实现参数化类型。我们不可能不去想象这样的语言将会成为 Java 的继任者，因为它们采用的方式，与 C++ 通过 C 来实现的方式相同：按原样使用它，然后对其进行改进。</p>
<h2 id="进阶阅读"><a href="#进阶阅读" class="headerlink" title="进阶阅读"></a>进阶阅读</h2><p>泛型的入门文档是 《Generics in the Java Programming Language》，作者是 Gilad Bracha，可以从 <a href="http://java.oracle.com" target="_blank" rel="noopener">http://java.oracle.com</a> 获取。</p>
<p>Angelika Langer 的《Java Generics FAQs》是一份非常有帮助的资料，可以从 <a href="http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html" target="_blank" rel="noopener">http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html</a> 获取。</p>
<p>我们可以从 《Adding Wildcards to the Java Programming Language》中学到更多关于通配符的知识，作者是 Torgerson、Ernst、Hansen、von der Ahe、Bracha 和 Gafter，地址是 <a href="http://www.jot.fm/issues/issue_2004_12/article5。" target="_blank" rel="noopener">http://www.jot.fm/issues/issue_2004_12/article5。</a></p>
<p>Neal After 对于 Java 问题（尤其是擦除）的看法可以从这里找到：<a href="http://www.infoq.com/articles/neal-gafter-on-java。" target="_blank" rel="noopener">http://www.infoq.com/articles/neal-gafter-on-java。</a></p>
<!-- 分页 -->

<div style="page-break-after: always;"></div>

      
      
        <div class="page-reward">
          <p><a href="javascript:void(0)" onclick="dashangToggle()" class="dashang">赏</a></p>
          <div class="hide_box"></div>
          <div class="shang_box">
            <a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()">×</a>
            <div class="shang_tit">
              <p>纯属好玩</p>
            </div>
            <div class="shang_payimg">
              <img src="/img/alipayimg.jpg" alt="扫码支持" title="扫一扫" />
            </div>
              <div class="pay_explain">扫码打赏，你说多少就多少</div>
            <div class="shang_payselect">
              
                <div class="pay_item checked" data-id="alipay">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/alipay.png" alt="支付宝" /></span>
                </div>
              
              
                <div class="pay_item" data-id="wechat">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/weixin.png" alt="微信" /></span>
                </div>
              
            </div>
            <div class="shang_info">
              <p>打开<span id="shang_pay_txt">支付宝</span>扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
        <script type="text/javascript">
          $(".pay_item").click(function(){
            $(this).addClass('checked').siblings('.pay_item').removeClass('checked');
            var dataid=$(this).attr('data-id');
            $(".shang_payimg img").attr("src","/img/"+dataid+"img.jpg");
            $("#shang_pay_txt").text(dataid=="alipay"?"支付宝":"微信");
          });
          function dashangToggle(){

            $(".hide_box").fadeToggle();
            $(".shang_box").fadeToggle();
          }
        </script>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2020/06/28/Java编程思想-第二十章 泛型阅读笔记/">Java编程思想-第二十章 泛型阅读笔记</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 Yiye Li 的个人博客">Yiye Li</a></p>
        <p><span>发布时间:</span>2020年06月28日 - 10时53分</p>
        <p><span>最后更新:</span>2020年06月29日 - 14时23分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2020/06/28/Java编程思想-第二十章 泛型阅读笔记/" title="Java编程思想-第二十章 泛型阅读笔记">http://yoursite.com/2020/06/28/Java编程思想-第二十章 泛型阅读笔记/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2020/06/28/Java编程思想-第二十章 泛型阅读笔记/　　作者: Yiye Li" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2020/06/28/Java编程思想-第二十三章 注解阅读笔记/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Java编程思想-第二十三章 注解阅读笔记
        
      </div>
    </a>
  
  
    <a href="/2020/06/27/79. 单词搜索/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">79. 单词搜索</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第二十章-泛型"><span class="toc-number">1.</span> <span class="toc-text">第二十章 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#与-C-的比较"><span class="toc-number">1.0.1.</span> <span class="toc-text">与 C++ 的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简单泛型"><span class="toc-number">1.1.</span> <span class="toc-text">简单泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一个元组类库"><span class="toc-number">1.1.1.</span> <span class="toc-text">一个元组类库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个堆栈类"><span class="toc-number">1.1.2.</span> <span class="toc-text">一个堆栈类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RandomList"><span class="toc-number">1.1.3.</span> <span class="toc-text">RandomList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型接口"><span class="toc-number">1.2.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型方法"><span class="toc-number">1.3.</span> <span class="toc-text">泛型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#变长参数和泛型方法"><span class="toc-number">1.3.1.</span> <span class="toc-text">变长参数和泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个泛型的-Supplier"><span class="toc-number">1.3.2.</span> <span class="toc-text">一个泛型的 Supplier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简化元组的使用"><span class="toc-number">1.3.3.</span> <span class="toc-text">简化元组的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个-Set-工具"><span class="toc-number">1.3.4.</span> <span class="toc-text">一个 Set 工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建复杂模型"><span class="toc-number">1.4.</span> <span class="toc-text">构建复杂模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型擦除"><span class="toc-number">1.5.</span> <span class="toc-text">泛型擦除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-的方式"><span class="toc-number">1.5.1.</span> <span class="toc-text">C++ 的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迁移兼容性"><span class="toc-number">1.5.2.</span> <span class="toc-text">迁移兼容性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#擦除的问题"><span class="toc-number">1.5.3.</span> <span class="toc-text">擦除的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#边界处的动作"><span class="toc-number">1.5.4.</span> <span class="toc-text">边界处的动作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#补偿擦除"><span class="toc-number">1.6.</span> <span class="toc-text">补偿擦除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建类型的实例"><span class="toc-number">1.6.1.</span> <span class="toc-text">创建类型的实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型数组"><span class="toc-number">1.6.2.</span> <span class="toc-text">泛型数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#边界"><span class="toc-number">1.7.</span> <span class="toc-text">边界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通配符"><span class="toc-number">1.8.</span> <span class="toc-text">通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编译器有多聪明"><span class="toc-number">1.8.1.</span> <span class="toc-text">编译器有多聪明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逆变"><span class="toc-number">1.8.2.</span> <span class="toc-text">逆变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无界通配符"><span class="toc-number">1.8.3.</span> <span class="toc-text">无界通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#捕获转换"><span class="toc-number">1.8.4.</span> <span class="toc-text">捕获转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题"><span class="toc-number">1.9.</span> <span class="toc-text">问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#任何基本类型都不能作为类型参数"><span class="toc-number">1.9.1.</span> <span class="toc-text">任何基本类型都不能作为类型参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现参数化接口"><span class="toc-number">1.9.2.</span> <span class="toc-text">实现参数化接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转型和警告"><span class="toc-number">1.9.3.</span> <span class="toc-text">转型和警告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重载"><span class="toc-number">1.9.4.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基类劫持接口"><span class="toc-number">1.9.5.</span> <span class="toc-text">基类劫持接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自限定的类型"><span class="toc-number">1.10.</span> <span class="toc-text">自限定的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#古怪的循环泛型"><span class="toc-number">1.10.1.</span> <span class="toc-text">古怪的循环泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自限定"><span class="toc-number">1.10.2.</span> <span class="toc-text">自限定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参数协变"><span class="toc-number">1.10.3.</span> <span class="toc-text">参数协变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态类型安全"><span class="toc-number">1.11.</span> <span class="toc-text">动态类型安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型异常"><span class="toc-number">1.12.</span> <span class="toc-text">泛型异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#混型"><span class="toc-number">1.13.</span> <span class="toc-text">混型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-中的混型"><span class="toc-number">1.13.1.</span> <span class="toc-text">C++ 中的混型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与接口混合"><span class="toc-number">1.13.2.</span> <span class="toc-text">与接口混合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用装饰器模式"><span class="toc-number">1.13.3.</span> <span class="toc-text">使用装饰器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与动态代理混合"><span class="toc-number">1.13.4.</span> <span class="toc-text">与动态代理混合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#潜在类型机制"><span class="toc-number">1.14.</span> <span class="toc-text">潜在类型机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pyhton-中的潜在类型"><span class="toc-number">1.14.1.</span> <span class="toc-text">pyhton 中的潜在类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-中的潜在类型"><span class="toc-number">1.14.2.</span> <span class="toc-text">C++ 中的潜在类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-中的潜在类型"><span class="toc-number">1.14.3.</span> <span class="toc-text">Go 中的潜在类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java中的直接潜在类型"><span class="toc-number">1.14.4.</span> <span class="toc-text">java中的直接潜在类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对缺乏潜在类型机制的补偿"><span class="toc-number">1.15.</span> <span class="toc-text">对缺乏潜在类型机制的补偿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#反射"><span class="toc-number">1.15.1.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将一个方法应用于序列"><span class="toc-number">1.15.2.</span> <span class="toc-text">将一个方法应用于序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java8-中的辅助潜在类型"><span class="toc-number">1.16.</span> <span class="toc-text">Java8 中的辅助潜在类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Suppliers类的通用方法"><span class="toc-number">1.16.1.</span> <span class="toc-text">使用Suppliers类的通用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结：类型转换真的如此之糟吗？"><span class="toc-number">1.17.</span> <span class="toc-text">总结：类型转换真的如此之糟吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进阶阅读"><span class="toc-number">1.18.</span> <span class="toc-text">进阶阅读</span></a></li></ol></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    
        <div id="gitments"></div>
<script src="/js/gitment.browser.js"></script>
<script>
    var gitment = new Gitment({
      id: window.location.pathname,
      owner: 'yiye',
      repo: 'liyiye012.github.io',
      oauth: {
        client_id: '',
        client_secret: '',
      },
    })
    gitment.render('gitments')
</script>
    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2020/06/28/Java编程思想-第二十三章 注解阅读笔记/" title="上一篇: Java编程思想-第二十三章 注解阅读笔记">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2020/06/27/79. 单词搜索/" title="下一篇: 79. 单词搜索">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/09/09/127. 单词接龙/">127. 单词接龙</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/08/322. 零钱兑换/">322. 零钱兑换</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/08/329. 矩阵中的最长递增路径/">329. 矩阵中的最长递增路径</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/08/300. 最长上升子序列/">300. 最长上升子序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/03/279. 完全平方数/">279. 完全平方数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/03/337. 打家劫舍III/">337. 打家劫舍III</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/03/213. 打家劫舍II/">213. 打家劫舍II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/03/198. 打家劫舍/">198. 打家劫舍</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/31/124. 二叉树中的最大路径和/">124. 二叉树中的最大路径和</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/31/128. 最长连续序列/">128. 最长连续序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/31/395. 至少有K个重复字符的最长子串/">395. 至少有K个重复字符的最长子串</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/26/剑指 offer51.数组中的逆序对/">剑指 offer51.数组中的逆序对</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/26/315. 计算右侧小于当前元素的个数/">315. 计算右侧小于当前元素的个数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/25/287. 寻找重复数/">287. 寻找重复数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/24/162. 寻找峰值/">162. 寻找峰值</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/24/324. 摆动排序 II/">324. 摆动排序 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/24/179. 最大数/">179. 最大数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/24/297. 二叉树的序列化与反序列化/">297. 二叉树的序列化与反序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/24/236. 二叉树的最近公共祖先/">236. 二叉树的最近公共祖先</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/22/230. 二叉搜索树中第K小的元素/">230. 二叉搜索树中第K小的元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/21/380. 常数时间插入、删除和获取随机元素/">380. 常数时间插入、删除和获取随机元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/21/454. 四数相加 II/">454. 四数相加 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/21/Excel表列序号/">171. Excel表列序号</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/21/328. 奇偶链表/">328. 奇偶链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/21/237. 删除链表中的节点/">237. 删除链表中的节点</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/20/234. 回文链表/">234. 回文链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/19/92. 反转链表II/">92. 反转链表II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/18/206. 反转链表/">206. 反转链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/18/160. 相交链表/">160. 相交链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/25/142. 环形链表II/">142. 环形链表II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/25/148. 排序链表/">148. 排序链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/24/141. 环形链表/">141. 环形链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/23/138. 复制带随机指针的链表/">138. 复制带随机指针的链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/23/150. 逆波兰表达式求值/">150. 逆波兰表达式求值</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/23/341. 扁平化嵌套列表迭代器/">341. 扁平化嵌套列表迭代器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/23/227. 基本计算器 II/">基本计算器 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/19/239. 滑动窗口最大值/">239. 滑动窗口最大值</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/18/347. 前 K 个高频元素/">347. 前 K 个高频元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/12/Java编程思想-第二十二章 枚举阅读笔记/">Java编程思想-第二十二章 枚举阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/10/Latex极简教程/">Latex极简教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/09/378. 有序矩阵中第K小的元素/">378. 有序矩阵中第K小的元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/06/295. 数据流的中位数/">295. 数据流的中位数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/06/215. 数组中的第K个最大元素/">215. 数组中的第K个最大元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/238. 除自身以外数组的乘积/">238. 除自身以外数组的乘积</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/155.  最小栈/">155. 最小栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/30/240. 搜索二维矩阵II/">240. 搜索二维矩阵II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/30/74. 搜索二维矩阵/">74. 搜索二维矩阵</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/30/334.递增的三元子序列/">334. 递增的三元子序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/350. 两个数组的交集II/">350. 两个数组的交集II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/349. 两个数组的交集/">349. 两个数组的交集</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/384. 打乱数组/">384. 打乱数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/283. 移动零/">283. 移动零</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/Java之TreeSet类/">Java之TreeSet类</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/220. 存在重复元素III/">220. 存在重复元素III</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/217. 存在重复元素/">217. 存在重复元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/219. 存在重复元素II/">219. 存在重复元素II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/152. 乘积最大子数组/">152. 乘积最大子数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/189. 旋转数组/">189. 旋转数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/63. 不同路径II/">63. 不同路径II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/980. 不同路径 III/">980. 不同路径 III</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/62. 不同路径/">62. 不同路径</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/212. 单词搜索II/">212. 单词搜索II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/Java编程思想-第二十三章 注解阅读笔记/">Java编程思想-第二十三章 注解阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/Java编程思想-第二十章 泛型阅读笔记/">Java编程思想-第二十章 泛型阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/27/79. 单词搜索/">79. 单词搜索</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/26/Java之数组/">Java之数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/26/《生事之屋：白宫回忆录》节选/">《生事之屋：白宫回忆录》节选</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/24/208. 实现 Trie (前缀树)/">208. 实现 Trie (前缀树)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/数据库学习笔记-Sql_Mode/">数据库学习笔记-Sql_Mode</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/18/ Java之String类/">Java之String类</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/18/Java之可变参数/">Java之可变参数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/15/Java之Queue、Deque、ArrayDeque/">Java之Queue、Deque、ArrayDeque</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/15/Java之instanceof关键字/">Java之instanceof关键字</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/14/Java之transient关键字/">Java之transient关键字</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/Java编程思想-第十章 接口阅读笔记/">Java编程思想-第十章 接口阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/Java集合之HashMap/">Java集合之HashMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/12/数据库基础概念III-事务并发控制/">数据库基础概念III-事务并发控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/12/数据库学习笔记-聚合函数/">数据库学习笔记-聚合函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/12/数据库基础概念-索引/">数据库基础概念-索引</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/12/数据库学习笔记-INTERSECT/">数据库学习笔记-INTERSECT</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/11/数据库学习笔记-UNION/">数据库学习笔记-UNION</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/11/数据库学习笔记-连接/">数据库学习笔记-连接</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/10/数据库学习笔记-MySQL安装与使用/">数据库学习笔记-MySQL安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/10/数据库基础概念II-范式-关系代数-三值逻辑/">数据库基础概念II-范式-关系代数-三值逻辑</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/09/数据库学习笔记-SQL约束(Constraints)/">数据库学习笔记-SQL约束(Constraints)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/06/Java编程思想-第九章 多态阅读笔记/">Java编程思想-第九章 多态阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/06/Java编程思想-第二十四章 并发编程阅读笔记/">Java编程思想-第二十四章 并发编程阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/05/Maven快照机制(SNAPSHOT)/">Maven快照机制（SNAPSHOT）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/29/140. 单词拆分II/">140. 单词拆分II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/28/139. 单词拆分/">139. 单词拆分</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/28/5. 最长回文子串/">5. 最长回文子串</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/28/131. 分割回文串/">131. 分割回文串</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/28/887. 鸡蛋掉落/">887. 鸡蛋掉落</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/27/21. 合并两个有序链表/">21. 合并两个有序链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/26/685.冗余链接II/">685.冗余链接II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/26/1226. 哲学家进餐/">1226. 哲学家进餐</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/24/1195. 交替打印字符串/">1195. 交替打印字符串</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/24/1117. H2O 生成/">1117. H2O 生成</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/24/1116. 打印零与奇偶数/">1116. 打印零与奇偶数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/22/1115. 交替打印FooBar/">1115. 交替打印FooBar</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/21/Java并发编程/">Java并发编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/21/1114.按序打印/">1114.按序打印</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/19/684.冗余链接/">684.冗余链接</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/18/Lombok的基本注解使用/">Lombok的基本注解使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/18/后端开发常用调试技巧集锦/">后端开发常用调试技巧集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/29/405. 数字转化为十六进制数/">405. 数字转化为十六进制数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/17/SpringBoot学习笔记VIII-MybatisPlus教程/">SpringBoot学习笔记VIII-MybatisPlus教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/13/设计模式学习笔记V-策略模式/">设计模式学习笔记V-策略模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/16/1046. 最后一块石头的重量/">1046. 最后一块石头的重量</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/24/Java学习笔记XIV/">Java学习笔记XIV</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/24/257.二叉树的所有路径/">257.二叉树的所有路径</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/22/24.两两交换链表中的节点/">24.两两交换链表中的节点</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/20/微信公众平台开发学习笔记I/">微信公众平台开发学习笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/20/601.Human Traffic of Stadium体育馆的人流量/">601.Human Traffic of Stadium体育馆的人流量</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/20/185.Department Top Three Salaries/">185.Department Top Three Salaries</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/19/数据库学习笔记IX/">数据库学习笔记IX</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/19/184.Department Highest Salary/">184.Department Highest Salary</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/17/数据库学习笔记VIII/">数据库学习笔记VIII</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/17/1179. Reformat Department Table/">1179. Reformat Department Table</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/17/Effective-Java阅读笔记XVII/">Effective-Java阅读笔记XVII</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/17/Effective-Java阅读笔记XVI/">Effective-Java阅读笔记XVI</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/17/Effective-Java阅读笔记XV/">Effective-Java阅读笔记XV</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/16/Effective-Java阅读笔记XIV/">Effective-Java阅读笔记XIV</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/16/Effective-Java阅读笔记XIII/">Effective-Java阅读笔记XIII</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/16/Effective-Java阅读笔记XII/">Effective-Java阅读笔记XII</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/16/Effective-Java阅读笔记XI/">Effective-Java阅读笔记XI</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/16/Effective-Java阅读笔记X/">Effective-Java阅读笔记X</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/16/Effective-Java阅读笔记IX/">Effective-Java阅读笔记IX</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/16/Effective-Java阅读笔记VIII/">Effective-Java阅读笔记VIII</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/15/Hexo的spfk主题修改/">Hexo的spfk主题修改</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/15/Effective-Java阅读笔记VII/">Effective-Java阅读笔记VII</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/14/Effective-Java阅读笔记VI/">Effective-Java阅读笔记VI</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/13/Git学习笔记III/">Git学习笔记III</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/06/Effective-Java阅读笔记V/">Effective-Java阅读笔记V</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/Hexo标签与md文件冲突问题解决/">Hexo标签与md文件冲突问题解决</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/Java开发中的易错点/">Java开发中的易错点</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/设计模式学习笔记IV/">设计模式学习笔记IV</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/数据库学习笔记VII/">数据库学习笔记VII</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/02/Java开发规范/">Java开发规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/31/Effective-Java阅读笔记III/">Effective-Java阅读笔记III</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/31/Effective-Java阅读笔记IV/">Effective-Java阅读笔记IV</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/31/Effective-Java阅读笔记II/">Effective-Java阅读笔记II</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/30/设计模式学习笔记III/">设计模式学习笔记III</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/30/Effective-Java阅读笔记I/">Effective-Java阅读笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/27/Scala学习笔记V/">Scala学习笔记V</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/24/Java学习笔记XII/">Java学习笔记XII</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/24/Java学习笔记XIII/">Java学习笔记XIII</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/23/Scala学习笔记IV/">Scala学习笔记IV</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/23/Java学习笔记XI/">Java学习笔记XI</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/23/Scala学习笔记III/">Scala学习笔记III</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/17/Java学习笔记X/">Java学习笔记X</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/数据库学习笔记VI/">数据库学习笔记VI</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/设计模式学习笔记II/">设计模式学习笔记II</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/17/设计模式学习笔记I/">设计模式学习笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/25/Scala学习笔记II/">Scala学习笔记II</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/20/Java学习笔记IX/">Java学习笔记IX</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/Shell学习笔记I/">Shell学习笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/Scala学习笔记I/">Scala学习笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/Java学习笔记VIII/">Java学习笔记VIII</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/Java学习笔记VII/">Java学习笔记VII</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/05/Java学习笔记VI/">Java学习笔记VI</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/05/Git学习笔记II-Git版本回滚/">Git学习笔记II-Git版本回滚</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/05/数据库学习笔记V/">数据库学习笔记V</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/Git学习笔记I/">Git学习笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/数据库学习笔记IV/">数据库学习笔记IV</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/27/数据库学习笔记III/">数据库学习笔记III</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/12/Java学习笔记V/">Java学习笔记V</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/12/Java学习笔记IV/">Java学习笔记IV</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/12/Java学习笔记III/">Java学习笔记III</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/09/数据库学习笔记II/">数据库学习笔记II</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/07/Java学习笔记II/">Java学习笔记II</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/Java学习笔记I/">Java学习笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/01/SpringBoot学习笔记VII/">SpringBoot学习笔记VII</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/31/数据库学习笔记I-查询/">数据库学习笔记I-查询</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/30/SpringBoot学习笔记V/">SpringBoot学习笔记V</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/26/SpringBoot学习笔记IV/">SpringBoot学习笔记IV</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/25/SpringBoot学习笔记III/">SpringBoot学习笔记III</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/17/SpringBoot学习笔记I/">SpringBoot学习笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/03/Linux配置问题小结/">Linux配置问题小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/02/操作系统基础概念I/">操作系统基础概念I</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/28/Hexo博客多终端更新问题/">Hexo博客多终端更新问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/TensorFlow入门-Mnist手写数字识别/">TensorFlow入门-Mnist手写数字识别</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/30/235.Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先/">235.Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/22/Linux学习笔记I/">Linux学习笔记I</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/11/Permutations全排列问题总结/">Permutations全排列问题总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/09/84.Largest Rectangle in Histogram柱状图中最大的矩形/">84.Largest Rectangle in Histogram柱状图中最大的矩形</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/05/52. N-QueensIIN皇后II/">52. N-QueensNII皇后II</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/05/51. N-QueensN皇后/">51. N-QueensN皇后</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/04/102.Binary Tree Level Order Traversal二叉树的层次遍历 /">102.Binary Tree Level Order Traversal二叉树的层次遍历</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/04/117.Populating Next Right Pointers in Each NodeII填充同一层的兄弟节点II/">117.Populating Next Right Pointers in Each NodeII填充同一层的兄弟节点II</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/04/199.Binary Tree Right Side View二叉树的右视图/">199.Binary Tree Right Side View二叉树的右视图</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/04/545.Boundary of Binary Tree 二叉树的边界/">545.Boundary of Binary Tree 二叉树的边界</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/04/116.Populating Next Right Pointers in Each Node填充同一层的兄弟节点/">116.Populating Next Right Pointers in Each Node填充同一层的兄弟节点</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/21/操作系统面试高频题/">操作系统面试高频题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/21/数据库面试高频题/">数据库面试高频题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/21/C++面试高频题/">C++面试高频题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/20/792. Number of Matching Subsequences匹配子序列的单词数/">792. Number of Matching Subsequences匹配子序列的单词数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/20/392. Is Subsequence判断子序列/">392. Is Subsequence判断子序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/Linux基础面试高频题/">Linux基础面试高频题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/算法面试高频题/">算法面试高频题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/计算机网络面试高频题/">计算机网络面试高频题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/设计模式面试高频题/">设计模式面试高频题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/回溯法问题通解/">回溯法问题通解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/78. Subsets子集/">78. Subsets子集</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/90. SubsetsII子集II/">90. SubsetsII子集II</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/72. Edit Distance编辑距离/">72. Edit Distance编辑距离</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/13/277.Find the Celebrity寻找名人/">277.Find the Celebrity寻找名人</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/13/148. Sort List排序链表/">148. Sort List排序链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/12/692. Top K Frequent Words前K个高频单词/">692. Top K Frequent Words前K个高频单词</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/12/450. Delete Node in a BST删除二叉搜索树中的节点/">450. Delete Node in a BST删除二叉搜索树中的节点</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/435. Non-overlapping Intervals无重叠区间/">435. Non-overlapping Intervals无重叠区间</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/C++基础概念VI/">C++基础概念VI</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/75. Sort Colors颜色分类/">75. Sort Colors颜色分类</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/275. H-Index II H指数 II/">275. H-Index II H指数 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/10/274. H-IndexH指数/">274. H-IndexH指数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/10/C++基础概念V/">STL源码剖析之vector</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/06/Git分区概念/">Git分区概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/06/486. Predict the Winner预测赢家/">486. Predict the Winner预测赢家</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/快速排序及其优化/">快速排序及其优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/31/C++基础概念IV/">C++基础概念IV</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/30/682. Baseball Game棒球比赛/">682. Baseball Game棒球比赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/30/542. 01 Matrix 01 矩阵/">542. 01 Matrix 01 矩阵</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/29/C++输入/">C++输入总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/27/688. Knight Probability in Chessboard“马”在棋盘上的概率/">688. Knight Probability in Chessboard“马”在棋盘上的概率</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/139. Word Break单词拆分/">139. Word Break单词拆分</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/626. Exchange Seats换座位/">626. Exchange Seats换座位</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/Kickstart-Round-E-2018-ProblemA.Yogurt/">Kickstart-Round-E-2018-ProblemA.Yogurt</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树/">865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/485. Max Consecutive Ones/">485. Max Consecutive Ones最大连续1的个数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/538. Convert BST to Greater Tree把二叉搜索树转换为累加树/">538. Convert BST to Greater Tree把二叉搜索树转换为累加树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/697. Degree of an Array数组的度/">697. Degree of an Array数组的度</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/885. Spiral Matrix III/">885. Spiral Matrix III螺旋矩阵 III</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/数据库基础概念I/">数据库基础概念I</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/计算机网络概念I/">计算机网络概念I</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/剑指Offer20.顺时针打印矩阵/">20.PrintMatrix顺时针打印矩阵(CodingInterview)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/59. Spiral Matrix II螺旋矩阵 II/">59. Spiral Matrix II螺旋矩阵 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/650. 2 Keys Keyboard只有两个键的键盘/">650. 2 Keys Keyboard只有两个键的键盘</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/23/在浏览器地址栏输入URL，按下回车后发生了什么/">在浏览器地址栏输入URL，按下回车后发生了什么</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/23/剑指Offer59.对称的二叉树/">59.SymmetricalBinaryTree对称的二叉树(CodingInterview)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/23/剑指offer思路总结/">剑指offer思路总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/300. Longest Increasing Subsequence最长上升子序列/">300. Longest Increasing Subsequence最长上升子序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/354. Russian Doll Envelopes俄罗斯套娃信封/">354. Russian Doll Envelopes俄罗斯套娃</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/剑指Offer64.数据流中的中位数/">64.StreamMedian数据流中的中位数(Coding Interviews )</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/21/C++基础概念II/">C++基础概念II</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/21/C++基础概念I/">C++基础概念I</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/21/C++基础概念III/">C++基础概念III</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/21/Hexo+github搭建个人博客问题总结/">Hexo+github搭建个人博客问题总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/21/股票交易问题通解小结/">股票交易问题通解小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/16/前言/">前言</a></li></ul>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2020 Yiye Li
            </div>
                <i class="fas fa-chart-area"></i>
                    <span class="post-count">总字数：594.1k</span>
                <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
                    <script>
                        var now = new Date();
                        function createtime() {
                            var grt= new Date("11/16/2017 21:14:20");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
                            now.setTime(now.getTime()+250);
                            days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
                            hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
                            if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
                            mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
                            seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                            snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
                            document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
                            document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
                        }
                    setInterval("createtime()",250);
                    </script>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_uv" style='display:none'>
                        <span id="site-visit" >本站访客数:
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量:
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>



  </div>
</body>
</html>